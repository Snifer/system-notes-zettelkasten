/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a3, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp.call(b3, prop))
      __defNormalProp(a3, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp(a3, prop, b3[prop]);
    }
  return a3;
};
var __spreadProps = (a3, b3) => __defProps(a3, __getOwnPropDescs(b3));
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var step = (x4) => x4.done ? resolve(x4.value) : Promise.resolve(x4.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/preact/dist/preact.module.js
function a(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
function h(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function v(l3, u3, i3) {
  var t3, o3, r3, f3 = {};
  for (r3 in u3)
    r3 == "key" ? t3 = u3[r3] : r3 == "ref" ? o3 = u3[r3] : f3[r3] = u3[r3];
  if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), typeof l3 == "function" && l3.defaultProps != null)
    for (r3 in l3.defaultProps)
      f3[r3] === void 0 && (f3[r3] = l3.defaultProps[r3]);
  return y(l3, f3, t3, o3, null);
}
function y(n2, i3, t3, o3, r3) {
  var f3 = { type: n2, props: i3, key: t3, ref: o3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: r3 == null ? ++u : r3 };
  return r3 == null && l.vnode != null && l.vnode(f3), f3;
}
function p() {
  return { current: null };
}
function d(n2) {
  return n2.children;
}
function _(n2, l3) {
  this.props = n2, this.context = l3;
}
function k(n2, l3) {
  if (l3 == null)
    return n2.__ ? k(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if ((u3 = n2.__k[l3]) != null && u3.__e != null)
      return u3.__e;
  return typeof n2.type == "function" ? k(n2) : null;
}
function b(n2) {
  var l3, u3;
  if ((n2 = n2.__) != null && n2.__c != null) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if ((u3 = n2.__k[l3]) != null && u3.__e != null) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return b(n2);
  }
}
function m(n2) {
  (!n2.__d && (n2.__d = true) && t.push(n2) && !g.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)(g);
}
function g() {
  for (var n2; g.__r = t.length; )
    n2 = t.sort(function(n3, l3) {
      return n3.__v.__b - l3.__v.__b;
    }), t = [], n2.some(function(n3) {
      var l3, u3, i3, t3, o3, r3;
      n3.__d && (o3 = (t3 = (l3 = n3).__v).__e, (r3 = l3.__P) && (u3 = [], (i3 = a({}, t3)).__v = t3.__v + 1, j(r3, t3, i3, l3.__n, r3.ownerSVGElement !== void 0, t3.__h != null ? [o3] : null, u3, o3 == null ? k(t3) : o3, t3.__h), z(u3, t3), t3.__e != o3 && b(t3)));
    });
}
function w(n2, l3, u3, i3, t3, o3, r3, f3, s3, a3) {
  var h3, v3, p3, _3, b3, m3, g4, w4 = i3 && i3.__k || c, A4 = w4.length;
  for (u3.__k = [], h3 = 0; h3 < l3.length; h3++)
    if ((_3 = u3.__k[h3] = (_3 = l3[h3]) == null || typeof _3 == "boolean" ? null : typeof _3 == "string" || typeof _3 == "number" || typeof _3 == "bigint" ? y(null, _3, null, null, _3) : Array.isArray(_3) ? y(d, { children: _3 }, null, null, null) : _3.__b > 0 ? y(_3.type, _3.props, _3.key, null, _3.__v) : _3) != null) {
      if (_3.__ = u3, _3.__b = u3.__b + 1, (p3 = w4[h3]) === null || p3 && _3.key == p3.key && _3.type === p3.type)
        w4[h3] = void 0;
      else
        for (v3 = 0; v3 < A4; v3++) {
          if ((p3 = w4[v3]) && _3.key == p3.key && _3.type === p3.type) {
            w4[v3] = void 0;
            break;
          }
          p3 = null;
        }
      j(n2, _3, p3 = p3 || e, t3, o3, r3, f3, s3, a3), b3 = _3.__e, (v3 = _3.ref) && p3.ref != v3 && (g4 || (g4 = []), p3.ref && g4.push(p3.ref, null, _3), g4.push(v3, _3.__c || b3, _3)), b3 != null ? (m3 == null && (m3 = b3), typeof _3.type == "function" && _3.__k === p3.__k ? _3.__d = s3 = x(_3, s3, n2) : s3 = P(n2, _3, p3, w4, b3, s3), typeof u3.type == "function" && (u3.__d = s3)) : s3 && p3.__e == s3 && s3.parentNode != n2 && (s3 = k(p3));
    }
  for (u3.__e = m3, h3 = A4; h3--; )
    w4[h3] != null && (typeof u3.type == "function" && w4[h3].__e != null && w4[h3].__e == u3.__d && (u3.__d = k(i3, h3 + 1)), N(w4[h3], w4[h3]));
  if (g4)
    for (h3 = 0; h3 < g4.length; h3++)
      M(g4[h3], g4[++h3], g4[++h3]);
}
function x(n2, l3, u3) {
  for (var i3, t3 = n2.__k, o3 = 0; t3 && o3 < t3.length; o3++)
    (i3 = t3[o3]) && (i3.__ = n2, l3 = typeof i3.type == "function" ? x(i3, l3, u3) : P(u3, i3, i3, t3, i3.__e, l3));
  return l3;
}
function A(n2, l3) {
  return l3 = l3 || [], n2 == null || typeof n2 == "boolean" || (Array.isArray(n2) ? n2.some(function(n3) {
    A(n3, l3);
  }) : l3.push(n2)), l3;
}
function P(n2, l3, u3, i3, t3, o3) {
  var r3, f3, e3;
  if (l3.__d !== void 0)
    r3 = l3.__d, l3.__d = void 0;
  else if (u3 == null || t3 != o3 || t3.parentNode == null)
    n:
      if (o3 == null || o3.parentNode !== n2)
        n2.appendChild(t3), r3 = null;
      else {
        for (f3 = o3, e3 = 0; (f3 = f3.nextSibling) && e3 < i3.length; e3 += 2)
          if (f3 == t3)
            break n;
        n2.insertBefore(t3, o3), r3 = o3;
      }
  return r3 !== void 0 ? r3 : t3.nextSibling;
}
function C(n2, l3, u3, i3, t3) {
  var o3;
  for (o3 in u3)
    o3 === "children" || o3 === "key" || o3 in l3 || H(n2, o3, null, u3[o3], i3);
  for (o3 in l3)
    t3 && typeof l3[o3] != "function" || o3 === "children" || o3 === "key" || o3 === "value" || o3 === "checked" || u3[o3] === l3[o3] || H(n2, o3, l3[o3], u3[o3], i3);
}
function $(n2, l3, u3) {
  l3[0] === "-" ? n2.setProperty(l3, u3) : n2[l3] = u3 == null ? "" : typeof u3 != "number" || s.test(l3) ? u3 : u3 + "px";
}
function H(n2, l3, u3, i3, t3) {
  var o3;
  n:
    if (l3 === "style")
      if (typeof u3 == "string")
        n2.style.cssText = u3;
      else {
        if (typeof i3 == "string" && (n2.style.cssText = i3 = ""), i3)
          for (l3 in i3)
            u3 && l3 in u3 || $(n2.style, l3, "");
        if (u3)
          for (l3 in u3)
            i3 && u3[l3] === i3[l3] || $(n2.style, l3, u3[l3]);
      }
    else if (l3[0] === "o" && l3[1] === "n")
      o3 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + o3] = u3, u3 ? i3 || n2.addEventListener(l3, o3 ? T : I, o3) : n2.removeEventListener(l3, o3 ? T : I, o3);
    else if (l3 !== "dangerouslySetInnerHTML") {
      if (t3)
        l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (l3 !== "href" && l3 !== "list" && l3 !== "form" && l3 !== "tabIndex" && l3 !== "download" && l3 in n2)
        try {
          n2[l3] = u3 == null ? "" : u3;
          break n;
        } catch (n3) {
        }
      typeof u3 == "function" || (u3 != null && (u3 !== false || l3[0] === "a" && l3[1] === "r") ? n2.setAttribute(l3, u3) : n2.removeAttribute(l3));
    }
}
function I(n2) {
  this.l[n2.type + false](l.event ? l.event(n2) : n2);
}
function T(n2) {
  this.l[n2.type + true](l.event ? l.event(n2) : n2);
}
function j(n2, u3, i3, t3, o3, r3, f3, e3, c3) {
  var s3, h3, v3, y3, p3, k4, b3, m3, g4, x4, A4, P3 = u3.type;
  if (u3.constructor !== void 0)
    return null;
  i3.__h != null && (c3 = i3.__h, e3 = u3.__e = i3.__e, u3.__h = null, r3 = [e3]), (s3 = l.__b) && s3(u3);
  try {
    n:
      if (typeof P3 == "function") {
        if (m3 = u3.props, g4 = (s3 = P3.contextType) && t3[s3.__c], x4 = s3 ? g4 ? g4.props.value : s3.__ : t3, i3.__c ? b3 = (h3 = u3.__c = i3.__c).__ = h3.__E : ("prototype" in P3 && P3.prototype.render ? u3.__c = h3 = new P3(m3, x4) : (u3.__c = h3 = new _(m3, x4), h3.constructor = P3, h3.render = O), g4 && g4.sub(h3), h3.props = m3, h3.state || (h3.state = {}), h3.context = x4, h3.__n = t3, v3 = h3.__d = true, h3.__h = []), h3.__s == null && (h3.__s = h3.state), P3.getDerivedStateFromProps != null && (h3.__s == h3.state && (h3.__s = a({}, h3.__s)), a(h3.__s, P3.getDerivedStateFromProps(m3, h3.__s))), y3 = h3.props, p3 = h3.state, v3)
          P3.getDerivedStateFromProps == null && h3.componentWillMount != null && h3.componentWillMount(), h3.componentDidMount != null && h3.__h.push(h3.componentDidMount);
        else {
          if (P3.getDerivedStateFromProps == null && m3 !== y3 && h3.componentWillReceiveProps != null && h3.componentWillReceiveProps(m3, x4), !h3.__e && h3.shouldComponentUpdate != null && h3.shouldComponentUpdate(m3, h3.__s, x4) === false || u3.__v === i3.__v) {
            h3.props = m3, h3.state = h3.__s, u3.__v !== i3.__v && (h3.__d = false), h3.__v = u3, u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n3) {
              n3 && (n3.__ = u3);
            }), h3.__h.length && f3.push(h3);
            break n;
          }
          h3.componentWillUpdate != null && h3.componentWillUpdate(m3, h3.__s, x4), h3.componentDidUpdate != null && h3.__h.push(function() {
            h3.componentDidUpdate(y3, p3, k4);
          });
        }
        h3.context = x4, h3.props = m3, h3.state = h3.__s, (s3 = l.__r) && s3(u3), h3.__d = false, h3.__v = u3, h3.__P = n2, s3 = h3.render(h3.props, h3.state, h3.context), h3.state = h3.__s, h3.getChildContext != null && (t3 = a(a({}, t3), h3.getChildContext())), v3 || h3.getSnapshotBeforeUpdate == null || (k4 = h3.getSnapshotBeforeUpdate(y3, p3)), A4 = s3 != null && s3.type === d && s3.key == null ? s3.props.children : s3, w(n2, Array.isArray(A4) ? A4 : [A4], u3, i3, t3, o3, r3, f3, e3, c3), h3.base = u3.__e, u3.__h = null, h3.__h.length && f3.push(h3), b3 && (h3.__E = h3.__ = null), h3.__e = false;
      } else
        r3 == null && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = L(i3.__e, u3, i3, t3, o3, r3, f3, c3);
    (s3 = l.diffed) && s3(u3);
  } catch (n3) {
    u3.__v = null, (c3 || r3 != null) && (u3.__e = e3, u3.__h = !!c3, r3[r3.indexOf(e3)] = null), l.__e(n3, u3, i3);
  }
}
function z(n2, u3) {
  l.__c && l.__c(u3, n2), n2.some(function(u4) {
    try {
      n2 = u4.__h, u4.__h = [], n2.some(function(n3) {
        n3.call(u4);
      });
    } catch (n3) {
      l.__e(n3, u4.__v);
    }
  });
}
function L(l3, u3, i3, t3, o3, r3, f3, c3) {
  var s3, a3, v3, y3 = i3.props, p3 = u3.props, d3 = u3.type, _3 = 0;
  if (d3 === "svg" && (o3 = true), r3 != null) {
    for (; _3 < r3.length; _3++)
      if ((s3 = r3[_3]) && "setAttribute" in s3 == !!d3 && (d3 ? s3.localName === d3 : s3.nodeType === 3)) {
        l3 = s3, r3[_3] = null;
        break;
      }
  }
  if (l3 == null) {
    if (d3 === null)
      return document.createTextNode(p3);
    l3 = o3 ? document.createElementNS("http://www.w3.org/2000/svg", d3) : document.createElement(d3, p3.is && p3), r3 = null, c3 = false;
  }
  if (d3 === null)
    y3 === p3 || c3 && l3.data === p3 || (l3.data = p3);
  else {
    if (r3 = r3 && n.call(l3.childNodes), a3 = (y3 = i3.props || e).dangerouslySetInnerHTML, v3 = p3.dangerouslySetInnerHTML, !c3) {
      if (r3 != null)
        for (y3 = {}, _3 = 0; _3 < l3.attributes.length; _3++)
          y3[l3.attributes[_3].name] = l3.attributes[_3].value;
      (v3 || a3) && (v3 && (a3 && v3.__html == a3.__html || v3.__html === l3.innerHTML) || (l3.innerHTML = v3 && v3.__html || ""));
    }
    if (C(l3, p3, y3, o3, c3), v3)
      u3.__k = [];
    else if (_3 = u3.props.children, w(l3, Array.isArray(_3) ? _3 : [_3], u3, i3, t3, o3 && d3 !== "foreignObject", r3, f3, r3 ? r3[0] : i3.__k && k(i3, 0), c3), r3 != null)
      for (_3 = r3.length; _3--; )
        r3[_3] != null && h(r3[_3]);
    c3 || ("value" in p3 && (_3 = p3.value) !== void 0 && (_3 !== l3.value || d3 === "progress" && !_3 || d3 === "option" && _3 !== y3.value) && H(l3, "value", _3, y3.value, false), "checked" in p3 && (_3 = p3.checked) !== void 0 && _3 !== l3.checked && H(l3, "checked", _3, y3.checked, false));
  }
  return l3;
}
function M(n2, u3, i3) {
  try {
    typeof n2 == "function" ? n2(u3) : n2.current = u3;
  } catch (n3) {
    l.__e(n3, i3);
  }
}
function N(n2, u3, i3) {
  var t3, o3;
  if (l.unmount && l.unmount(n2), (t3 = n2.ref) && (t3.current && t3.current !== n2.__e || M(t3, null, u3)), (t3 = n2.__c) != null) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u3);
      }
    t3.base = t3.__P = null;
  }
  if (t3 = n2.__k)
    for (o3 = 0; o3 < t3.length; o3++)
      t3[o3] && N(t3[o3], u3, typeof n2.type != "function");
  i3 || n2.__e == null || h(n2.__e), n2.__e = n2.__d = void 0;
}
function O(n2, l3, u3) {
  return this.constructor(n2, u3);
}
function S(u3, i3, t3) {
  var o3, r3, f3;
  l.__ && l.__(u3, i3), r3 = (o3 = typeof t3 == "function") ? null : t3 && t3.__k || i3.__k, f3 = [], j(i3, u3 = (!o3 && t3 || i3).__k = v(d, null, [u3]), r3 || e, e, i3.ownerSVGElement !== void 0, !o3 && t3 ? [t3] : r3 ? null : i3.firstChild ? n.call(i3.childNodes) : null, f3, !o3 && t3 ? t3 : r3 ? r3.__e : i3.firstChild, o3), z(f3, u3);
}
function q(n2, l3) {
  S(n2, l3, q);
}
function B(l3, u3, i3) {
  var t3, o3, r3, f3 = a({}, l3.props);
  for (r3 in u3)
    r3 == "key" ? t3 = u3[r3] : r3 == "ref" ? o3 = u3[r3] : f3[r3] = u3[r3];
  return arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), y(l3.type, f3, t3 || l3.key, o3 || l3.ref, null);
}
function D(n2, l3) {
  var u3 = { __c: l3 = "__cC" + f++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var u4, i3;
    return this.getChildContext || (u4 = [], (i3 = {})[l3] = this, this.getChildContext = function() {
      return i3;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u4.some(m);
    }, this.sub = function(n4) {
      u4.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u4.splice(u4.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  } };
  return u3.Provider.__ = u3.Consumer.contextType = u3;
}
var n, l, u, i, t, o, r, f, e, c, s;
var init_preact_module = __esm({
  "node_modules/preact/dist/preact.module.js"() {
    e = {};
    c = [];
    s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
    n = c.slice, l = { __e: function(n2, l3, u3, i3) {
      for (var t3, o3, r3; l3 = l3.__; )
        if ((t3 = l3.__c) && !t3.__)
          try {
            if ((o3 = t3.constructor) && o3.getDerivedStateFromError != null && (t3.setState(o3.getDerivedStateFromError(n2)), r3 = t3.__d), t3.componentDidCatch != null && (t3.componentDidCatch(n2, i3 || {}), r3 = t3.__d), r3)
              return t3.__E = t3;
          } catch (l4) {
            n2 = l4;
          }
      throw n2;
    } }, u = 0, i = function(n2) {
      return n2 != null && n2.constructor === void 0;
    }, _.prototype.setState = function(n2, l3) {
      var u3;
      u3 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = a({}, this.state), typeof n2 == "function" && (n2 = n2(a({}, u3), this.props)), n2 && a(u3, n2), n2 != null && this.__v && (l3 && this.__h.push(l3), m(this));
    }, _.prototype.forceUpdate = function(n2) {
      this.__v && (this.__e = true, n2 && this.__h.push(n2), m(this));
    }, _.prototype.render = d, t = [], o = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g.__r = 0, f = 0;
  }
});

// node_modules/preact/hooks/dist/hooks.module.js
function l2(t3, r3) {
  l.__h && l.__h(u2, t3, o2 || r3), o2 = 0;
  var i3 = u2.__H || (u2.__H = { __: [], __h: [] });
  return t3 >= i3.__.length && i3.__.push({}), i3.__[t3];
}
function m2(n2) {
  return o2 = 1, p2(w2, n2);
}
function p2(n2, r3, o3) {
  var i3 = l2(t2++, 2);
  return i3.t = n2, i3.__c || (i3.__ = [o3 ? o3(r3) : w2(void 0, r3), function(n3) {
    var t3 = i3.t(i3.__[0], n3);
    i3.__[0] !== t3 && (i3.__ = [t3, i3.__[1]], i3.__c.setState({}));
  }], i3.__c = u2), i3.__;
}
function y2(r3, o3) {
  var i3 = l2(t2++, 3);
  !l.__s && k2(i3.__H, o3) && (i3.__ = r3, i3.__H = o3, u2.__H.__h.push(i3));
}
function d2(r3, o3) {
  var i3 = l2(t2++, 4);
  !l.__s && k2(i3.__H, o3) && (i3.__ = r3, i3.__H = o3, u2.__h.push(i3));
}
function h2(n2) {
  return o2 = 5, _2(function() {
    return { current: n2 };
  }, []);
}
function s2(n2, t3, u3) {
  o2 = 6, d2(function() {
    return typeof n2 == "function" ? (n2(t3()), function() {
      return n2(null);
    }) : n2 ? (n2.current = t3(), function() {
      return n2.current = null;
    }) : void 0;
  }, u3 == null ? u3 : u3.concat(n2));
}
function _2(n2, u3) {
  var r3 = l2(t2++, 7);
  return k2(r3.__H, u3) && (r3.__ = n2(), r3.__H = u3, r3.__h = n2), r3.__;
}
function A2(n2, t3) {
  return o2 = 8, _2(function() {
    return n2;
  }, t3);
}
function F(n2) {
  var r3 = u2.context[n2.__c], o3 = l2(t2++, 9);
  return o3.c = n2, r3 ? (o3.__ == null && (o3.__ = true, r3.sub(u2)), r3.props.value) : n2.__;
}
function T2(t3, u3) {
  l.useDebugValue && l.useDebugValue(u3 ? u3(t3) : t3);
}
function q2(n2) {
  var r3 = l2(t2++, 10), o3 = m2();
  return r3.__ = n2, u2.componentDidCatch || (u2.componentDidCatch = function(n3) {
    r3.__ && r3.__(n3), o3[1](n3);
  }), [o3[0], function() {
    o3[1](void 0);
  }];
}
function x2() {
  for (var t3; t3 = i2.shift(); )
    if (t3.__P)
      try {
        t3.__H.__h.forEach(g2), t3.__H.__h.forEach(j2), t3.__H.__h = [];
      } catch (u3) {
        t3.__H.__h = [], l.__e(u3, t3.__v);
      }
}
function g2(n2) {
  var t3 = u2, r3 = n2.__c;
  typeof r3 == "function" && (n2.__c = void 0, r3()), u2 = t3;
}
function j2(n2) {
  var t3 = u2;
  n2.__c = n2.__(), u2 = t3;
}
function k2(n2, t3) {
  return !n2 || n2.length !== t3.length || t3.some(function(t4, u3) {
    return t4 !== n2[u3];
  });
}
function w2(n2, t3) {
  return typeof t3 == "function" ? t3(n2) : t3;
}
var t2, u2, r2, o2, i2, c2, f2, e2, a2, v2, b2;
var init_hooks_module = __esm({
  "node_modules/preact/hooks/dist/hooks.module.js"() {
    init_preact_module();
    o2 = 0;
    i2 = [];
    c2 = l.__b;
    f2 = l.__r;
    e2 = l.diffed;
    a2 = l.__c;
    v2 = l.unmount;
    l.__b = function(n2) {
      u2 = null, c2 && c2(n2);
    }, l.__r = function(n2) {
      f2 && f2(n2), t2 = 0;
      var r3 = (u2 = n2.__c).__H;
      r3 && (r3.__h.forEach(g2), r3.__h.forEach(j2), r3.__h = []);
    }, l.diffed = function(t3) {
      e2 && e2(t3);
      var o3 = t3.__c;
      o3 && o3.__H && o3.__H.__h.length && (i2.push(o3) !== 1 && r2 === l.requestAnimationFrame || ((r2 = l.requestAnimationFrame) || function(n2) {
        var t4, u3 = function() {
          clearTimeout(r3), b2 && cancelAnimationFrame(t4), setTimeout(n2);
        }, r3 = setTimeout(u3, 100);
        b2 && (t4 = requestAnimationFrame(u3));
      })(x2)), u2 = null;
    }, l.__c = function(t3, u3) {
      u3.some(function(t4) {
        try {
          t4.__h.forEach(g2), t4.__h = t4.__h.filter(function(n2) {
            return !n2.__ || j2(n2);
          });
        } catch (r3) {
          u3.some(function(n2) {
            n2.__h && (n2.__h = []);
          }), u3 = [], l.__e(r3, t4.__v);
        }
      }), a2 && a2(t3, u3);
    }, l.unmount = function(t3) {
      v2 && v2(t3);
      var u3, r3 = t3.__c;
      r3 && r3.__H && (r3.__H.__.forEach(function(n2) {
        try {
          g2(n2);
        } catch (n3) {
          u3 = n3;
        }
      }), u3 && l.__e(u3, r3.__v));
    };
    b2 = typeof requestAnimationFrame == "function";
  }
});

// node_modules/preact/compat/dist/compat.module.js
var compat_module_exports = {};
__export(compat_module_exports, {
  Children: () => k3,
  Component: () => _,
  Fragment: () => d,
  PureComponent: () => E,
  StrictMode: () => cn,
  Suspense: () => L2,
  SuspenseList: () => M2,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => X,
  cloneElement: () => rn,
  createContext: () => D,
  createElement: () => v,
  createFactory: () => tn,
  createPortal: () => W,
  createRef: () => p,
  default: () => compat_module_default,
  findDOMNode: () => on,
  flushSync: () => fn,
  forwardRef: () => x3,
  hydrate: () => $2,
  isValidElement: () => en,
  lazy: () => F2,
  memo: () => g3,
  render: () => B2,
  unmountComponentAtNode: () => un,
  unstable_batchedUpdates: () => ln,
  useCallback: () => A2,
  useContext: () => F,
  useDebugValue: () => T2,
  useEffect: () => y2,
  useErrorBoundary: () => q2,
  useImperativeHandle: () => s2,
  useLayoutEffect: () => d2,
  useMemo: () => _2,
  useReducer: () => p2,
  useRef: () => h2,
  useState: () => m2,
  version: () => nn
});
function C2(n2, t3) {
  for (var e3 in t3)
    n2[e3] = t3[e3];
  return n2;
}
function S2(n2, t3) {
  for (var e3 in n2)
    if (e3 !== "__source" && !(e3 in t3))
      return true;
  for (var r3 in t3)
    if (r3 !== "__source" && n2[r3] !== t3[r3])
      return true;
  return false;
}
function E(n2) {
  this.props = n2;
}
function g3(n2, t3) {
  function e3(n3) {
    var e4 = this.props.ref, r4 = e4 == n3.ref;
    return !r4 && e4 && (e4.call ? e4(null) : e4.current = null), t3 ? !t3(this.props, n3) || !r4 : S2(this.props, n3);
  }
  function r3(t4) {
    return this.shouldComponentUpdate = e3, v(n2, t4);
  }
  return r3.displayName = "Memo(" + (n2.displayName || n2.name) + ")", r3.prototype.isReactComponent = true, r3.__f = true, r3;
}
function x3(n2) {
  function t3(t4) {
    var e3 = C2({}, t4);
    return delete e3.ref, n2(e3, t4.ref || null);
  }
  return t3.$$typeof = R, t3.render = t3, t3.prototype.isReactComponent = t3.__f = true, t3.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t3;
}
function L2() {
  this.__u = 0, this.t = null, this.__b = null;
}
function U(n2) {
  var t3 = n2.__.__c;
  return t3 && t3.__e && t3.__e(n2);
}
function F2(n2) {
  var t3, e3, r3;
  function u3(u4) {
    if (t3 || (t3 = n2()).then(function(n3) {
      e3 = n3.default || n3;
    }, function(n3) {
      r3 = n3;
    }), r3)
      throw r3;
    if (!e3)
      throw t3;
    return v(e3, u4);
  }
  return u3.displayName = "Lazy", u3.__f = true, u3;
}
function M2() {
  this.u = null, this.o = null;
}
function D2(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function I2(n2) {
  var t3 = this, e3 = n2.i;
  t3.componentWillUnmount = function() {
    S(null, t3.l), t3.l = null, t3.i = null;
  }, t3.i && t3.i !== e3 && t3.componentWillUnmount(), n2.__v ? (t3.l || (t3.i = e3, t3.l = { nodeType: 1, parentNode: e3, childNodes: [], appendChild: function(n3) {
    this.childNodes.push(n3), t3.i.appendChild(n3);
  }, insertBefore: function(n3, e4) {
    this.childNodes.push(n3), t3.i.appendChild(n3);
  }, removeChild: function(n3) {
    this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), t3.i.removeChild(n3);
  } }), S(v(D2, { context: t3.context }, n2.__v), t3.l)) : t3.l && t3.componentWillUnmount();
}
function W(n2, t3) {
  return v(I2, { __v: n2, i: t3 });
}
function B2(n2, t3, e3) {
  return t3.__k == null && (t3.textContent = ""), S(n2, t3), typeof e3 == "function" && e3(), n2 ? n2.__c : null;
}
function $2(n2, t3, e3) {
  return q(n2, t3), typeof e3 == "function" && e3(), n2 ? n2.__c : null;
}
function Z() {
}
function Y() {
  return this.cancelBubble;
}
function q3() {
  return this.defaultPrevented;
}
function tn(n2) {
  return v.bind(null, n2);
}
function en(n2) {
  return !!n2 && n2.$$typeof === P2;
}
function rn(n2) {
  return en(n2) ? B.apply(null, arguments) : n2;
}
function un(n2) {
  return !!n2.__k && (S(null, n2), true);
}
function on(n2) {
  return n2 && (n2.base || n2.nodeType === 1 && n2) || null;
}
var w3, R, N2, k3, A3, O2, T3, P2, V, j3, z2, H2, G, J, K, Q, X, nn, ln, fn, cn, compat_module_default;
var init_compat_module = __esm({
  "node_modules/preact/compat/dist/compat.module.js"() {
    init_hooks_module();
    init_hooks_module();
    init_preact_module();
    init_preact_module();
    (E.prototype = new _()).isPureReactComponent = true, E.prototype.shouldComponentUpdate = function(n2, t3) {
      return S2(this.props, n2) || S2(this.state, t3);
    };
    w3 = l.__b;
    l.__b = function(n2) {
      n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), w3 && w3(n2);
    };
    R = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.forward_ref") || 3911;
    N2 = function(n2, t3) {
      return n2 == null ? null : A(A(n2).map(t3));
    };
    k3 = { map: N2, forEach: N2, count: function(n2) {
      return n2 ? A(n2).length : 0;
    }, only: function(n2) {
      var t3 = A(n2);
      if (t3.length !== 1)
        throw "Children.only";
      return t3[0];
    }, toArray: A };
    A3 = l.__e;
    l.__e = function(n2, t3, e3, r3) {
      if (n2.then) {
        for (var u3, o3 = t3; o3 = o3.__; )
          if ((u3 = o3.__c) && u3.__c)
            return t3.__e == null && (t3.__e = e3.__e, t3.__k = e3.__k), u3.__c(n2, t3);
      }
      A3(n2, t3, e3, r3);
    };
    O2 = l.unmount;
    l.unmount = function(n2) {
      var t3 = n2.__c;
      t3 && t3.__R && t3.__R(), t3 && n2.__h === true && (n2.type = null), O2 && O2(n2);
    }, (L2.prototype = new _()).__c = function(n2, t3) {
      var e3 = t3.__c, r3 = this;
      r3.t == null && (r3.t = []), r3.t.push(e3);
      var u3 = U(r3.__v), o3 = false, i3 = function() {
        o3 || (o3 = true, e3.__R = null, u3 ? u3(l3) : l3());
      };
      e3.__R = i3;
      var l3 = function() {
        if (!--r3.__u) {
          if (r3.state.__e) {
            var n3 = r3.state.__e;
            r3.__v.__k[0] = function n4(t5, e4, r4) {
              return t5 && (t5.__v = null, t5.__k = t5.__k && t5.__k.map(function(t6) {
                return n4(t6, e4, r4);
              }), t5.__c && t5.__c.__P === e4 && (t5.__e && r4.insertBefore(t5.__e, t5.__d), t5.__c.__e = true, t5.__c.__P = r4)), t5;
            }(n3, n3.__c.__P, n3.__c.__O);
          }
          var t4;
          for (r3.setState({ __e: r3.__b = null }); t4 = r3.t.pop(); )
            t4.forceUpdate();
        }
      }, f3 = t3.__h === true;
      r3.__u++ || f3 || r3.setState({ __e: r3.__b = r3.__v.__k[0] }), n2.then(i3, i3);
    }, L2.prototype.componentWillUnmount = function() {
      this.t = [];
    }, L2.prototype.render = function(n2, t3) {
      if (this.__b) {
        if (this.__v.__k) {
          var e3 = document.createElement("div"), r3 = this.__v.__k[0].__c;
          this.__v.__k[0] = function n3(t4, e4, r4) {
            return t4 && (t4.__c && t4.__c.__H && (t4.__c.__H.__.forEach(function(n4) {
              typeof n4.__c == "function" && n4.__c();
            }), t4.__c.__H = null), (t4 = C2({}, t4)).__c != null && (t4.__c.__P === r4 && (t4.__c.__P = e4), t4.__c = null), t4.__k = t4.__k && t4.__k.map(function(t5) {
              return n3(t5, e4, r4);
            })), t4;
          }(this.__b, e3, r3.__O = r3.__P);
        }
        this.__b = null;
      }
      var u3 = t3.__e && v(d, null, n2.fallback);
      return u3 && (u3.__h = null), [v(d, null, t3.__e ? null : n2.children), u3];
    };
    T3 = function(n2, t3, e3) {
      if (++e3[1] === e3[0] && n2.o.delete(t3), n2.props.revealOrder && (n2.props.revealOrder[0] !== "t" || !n2.o.size))
        for (e3 = n2.u; e3; ) {
          for (; e3.length > 3; )
            e3.pop()();
          if (e3[1] < e3[0])
            break;
          n2.u = e3 = e3[2];
        }
    };
    (M2.prototype = new _()).__e = function(n2) {
      var t3 = this, e3 = U(t3.__v), r3 = t3.o.get(n2);
      return r3[0]++, function(u3) {
        var o3 = function() {
          t3.props.revealOrder ? (r3.push(u3), T3(t3, n2, r3)) : u3();
        };
        e3 ? e3(o3) : o3();
      };
    }, M2.prototype.render = function(n2) {
      this.u = null, this.o = /* @__PURE__ */ new Map();
      var t3 = A(n2.children);
      n2.revealOrder && n2.revealOrder[0] === "b" && t3.reverse();
      for (var e3 = t3.length; e3--; )
        this.o.set(t3[e3], this.u = [1, 0, this.u]);
      return n2.children;
    }, M2.prototype.componentDidUpdate = M2.prototype.componentDidMount = function() {
      var n2 = this;
      this.o.forEach(function(t3, e3) {
        T3(n2, e3, t3);
      });
    };
    P2 = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.element") || 60103;
    V = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
    j3 = typeof document != "undefined";
    z2 = function(n2) {
      return (typeof Symbol != "undefined" && typeof Symbol() == "symbol" ? /fil|che|rad/i : /fil|che|ra/i).test(n2);
    };
    _.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(n2) {
      Object.defineProperty(_.prototype, n2, { configurable: true, get: function() {
        return this["UNSAFE_" + n2];
      }, set: function(t3) {
        Object.defineProperty(this, n2, { configurable: true, writable: true, value: t3 });
      } });
    });
    H2 = l.event;
    l.event = function(n2) {
      return H2 && (n2 = H2(n2)), n2.persist = Z, n2.isPropagationStopped = Y, n2.isDefaultPrevented = q3, n2.nativeEvent = n2;
    };
    J = { configurable: true, get: function() {
      return this.class;
    } };
    K = l.vnode;
    l.vnode = function(n2) {
      var t3 = n2.type, e3 = n2.props, r3 = e3;
      if (typeof t3 == "string") {
        var u3 = t3.indexOf("-") === -1;
        for (var o3 in r3 = {}, e3) {
          var i3 = e3[o3];
          j3 && o3 === "children" && t3 === "noscript" || o3 === "value" && "defaultValue" in e3 && i3 == null || (o3 === "defaultValue" && "value" in e3 && e3.value == null ? o3 = "value" : o3 === "download" && i3 === true ? i3 = "" : /ondoubleclick/i.test(o3) ? o3 = "ondblclick" : /^onchange(textarea|input)/i.test(o3 + t3) && !z2(e3.type) ? o3 = "oninput" : /^onfocus$/i.test(o3) ? o3 = "onfocusin" : /^onblur$/i.test(o3) ? o3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(o3) ? o3 = o3.toLowerCase() : u3 && V.test(o3) ? o3 = o3.replace(/[A-Z0-9]/, "-$&").toLowerCase() : i3 === null && (i3 = void 0), r3[o3] = i3);
        }
        t3 == "select" && r3.multiple && Array.isArray(r3.value) && (r3.value = A(e3.children).forEach(function(n3) {
          n3.props.selected = r3.value.indexOf(n3.props.value) != -1;
        })), t3 == "select" && r3.defaultValue != null && (r3.value = A(e3.children).forEach(function(n3) {
          n3.props.selected = r3.multiple ? r3.defaultValue.indexOf(n3.props.value) != -1 : r3.defaultValue == n3.props.value;
        })), n2.props = r3, e3.class != e3.className && (J.enumerable = "className" in e3, e3.className != null && (r3.class = e3.className), Object.defineProperty(r3, "className", J));
      }
      n2.$$typeof = P2, K && K(n2);
    };
    Q = l.__r;
    l.__r = function(n2) {
      Q && Q(n2), G = n2.__c;
    };
    X = { ReactCurrentDispatcher: { current: { readContext: function(n2) {
      return G.__n[n2.__c].props.value;
    } } } };
    nn = "17.0.2";
    ln = function(n2, t3) {
      return n2(t3);
    };
    fn = function(n2, t3) {
      return n2(t3);
    };
    cn = d;
    compat_module_default = { useState: m2, useReducer: p2, useEffect: y2, useLayoutEffect: d2, useRef: h2, useImperativeHandle: s2, useMemo: _2, useCallback: A2, useContext: F, useDebugValue: T2, version: "17.0.2", Children: k3, render: B2, hydrate: $2, unmountComponentAtNode: un, createPortal: W, createElement: v, createContext: D, createFactory: tn, cloneElement: rn, createRef: p, Fragment: d, isValidElement: en, findDOMNode: on, Component: _, PureComponent: E, memo: g3, forwardRef: x3, flushSync: fn, unstable_batchedUpdates: ln, StrictMode: d, Suspense: L2, SuspenseList: M2, lazy: F2, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: X };
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    module2.exports = (init_compat_module(), __toCommonJS(compat_module_exports));
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i3 = 0; i3 < 10; i3++) {
          test2["_" + String.fromCharCode(i3)] = i3;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s3 = 1; s3 < arguments.length; s3++) {
        from = Object(arguments[s3]);
        for (var key in from) {
          if (hasOwnProperty2.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i3 = 0; i3 < symbols.length; i3++) {
            if (propIsEnumerable.call(from, symbols[i3])) {
              to[symbols[i3]] = from[symbols[i3]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module2) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module2.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module2) {
    module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module2) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x4) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module2.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module2) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x4) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module2.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x4, y3) {
        if (x4 === y3) {
          return x4 !== 0 || 1 / x4 === 1 / y3;
        } else {
          return x4 !== x4 && y3 !== y3;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), { expectedType });
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i3 = 0; i3 < propValue.length; i3++) {
            var error = typeChecker(propValue, i3, componentName, location, propFullName + "[" + i3 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i3 = 0; i3 < expectedValues.length; i3++) {
            if (is(propValue, expectedValues[i3])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
          var checker = arrayOfTypeCheckers[i3];
          if (typeof checker !== "function") {
            printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i3 + ".");
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i4 = 0; i4 < arrayOfTypeCheckers.length; i4++) {
            var checker2 = arrayOfTypeCheckers[i4];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError((componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`.");
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module2) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module2.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/type/value/is.js
var require_is = __commonJS({
  "node_modules/type/value/is.js"(exports, module2) {
    "use strict";
    var _undefined = void 0;
    module2.exports = function(value) {
      return value !== _undefined && value !== null;
    };
  }
});

// node_modules/type/object/is.js
var require_is2 = __commonJS({
  "node_modules/type/object/is.js"(exports, module2) {
    "use strict";
    var isValue = require_is();
    var possibleTypes = { "object": true, "function": true, "undefined": true };
    module2.exports = function(value) {
      if (!isValue(value))
        return false;
      return hasOwnProperty.call(possibleTypes, typeof value);
    };
  }
});

// node_modules/type/prototype/is.js
var require_is3 = __commonJS({
  "node_modules/type/prototype/is.js"(exports, module2) {
    "use strict";
    var isObject = require_is2();
    module2.exports = function(value) {
      if (!isObject(value))
        return false;
      try {
        if (!value.constructor)
          return false;
        return value.constructor.prototype === value;
      } catch (error) {
        return false;
      }
    };
  }
});

// node_modules/type/function/is.js
var require_is4 = __commonJS({
  "node_modules/type/function/is.js"(exports, module2) {
    "use strict";
    var isPrototype = require_is3();
    module2.exports = function(value) {
      if (typeof value !== "function")
        return false;
      if (!hasOwnProperty.call(value, "length"))
        return false;
      try {
        if (typeof value.length !== "number")
          return false;
        if (typeof value.call !== "function")
          return false;
        if (typeof value.apply !== "function")
          return false;
      } catch (error) {
        return false;
      }
      return !isPrototype(value);
    };
  }
});

// node_modules/type/plain-function/is.js
var require_is5 = __commonJS({
  "node_modules/type/plain-function/is.js"(exports, module2) {
    "use strict";
    var isFunction = require_is4();
    var classRe = /^\s*class[\s{/}]/;
    var functionToString = Function.prototype.toString;
    module2.exports = function(value) {
      if (!isFunction(value))
        return false;
      if (classRe.test(functionToString.call(value)))
        return false;
      return true;
    };
  }
});

// node_modules/es5-ext/object/assign/is-implemented.js
var require_is_implemented = __commonJS({
  "node_modules/es5-ext/object/assign/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      var assign = Object.assign, obj;
      if (typeof assign !== "function")
        return false;
      obj = { foo: "raz" };
      assign(obj, { bar: "dwa" }, { trzy: "trzy" });
      return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
    };
  }
});

// node_modules/es5-ext/object/keys/is-implemented.js
var require_is_implemented2 = __commonJS({
  "node_modules/es5-ext/object/keys/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      try {
        Object.keys("primitive");
        return true;
      } catch (e3) {
        return false;
      }
    };
  }
});

// node_modules/es5-ext/function/noop.js
var require_noop = __commonJS({
  "node_modules/es5-ext/function/noop.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
    };
  }
});

// node_modules/es5-ext/object/is-value.js
var require_is_value = __commonJS({
  "node_modules/es5-ext/object/is-value.js"(exports, module2) {
    "use strict";
    var _undefined = require_noop()();
    module2.exports = function(val) {
      return val !== _undefined && val !== null;
    };
  }
});

// node_modules/es5-ext/object/keys/shim.js
var require_shim = __commonJS({
  "node_modules/es5-ext/object/keys/shim.js"(exports, module2) {
    "use strict";
    var isValue = require_is_value();
    var keys = Object.keys;
    module2.exports = function(object) {
      return keys(isValue(object) ? Object(object) : object);
    };
  }
});

// node_modules/es5-ext/object/keys/index.js
var require_keys = __commonJS({
  "node_modules/es5-ext/object/keys/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented2()() ? Object.keys : require_shim();
  }
});

// node_modules/es5-ext/object/valid-value.js
var require_valid_value = __commonJS({
  "node_modules/es5-ext/object/valid-value.js"(exports, module2) {
    "use strict";
    var isValue = require_is_value();
    module2.exports = function(value) {
      if (!isValue(value))
        throw new TypeError("Cannot use null or undefined");
      return value;
    };
  }
});

// node_modules/es5-ext/object/assign/shim.js
var require_shim2 = __commonJS({
  "node_modules/es5-ext/object/assign/shim.js"(exports, module2) {
    "use strict";
    var keys = require_keys();
    var value = require_valid_value();
    var max = Math.max;
    module2.exports = function(dest, src) {
      var error, i3, length = max(arguments.length, 2), assign;
      dest = Object(value(dest));
      assign = function(key) {
        try {
          dest[key] = src[key];
        } catch (e3) {
          if (!error)
            error = e3;
        }
      };
      for (i3 = 1; i3 < length; ++i3) {
        src = arguments[i3];
        keys(src).forEach(assign);
      }
      if (error !== void 0)
        throw error;
      return dest;
    };
  }
});

// node_modules/es5-ext/object/assign/index.js
var require_assign = __commonJS({
  "node_modules/es5-ext/object/assign/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented()() ? Object.assign : require_shim2();
  }
});

// node_modules/es5-ext/object/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/es5-ext/object/normalize-options.js"(exports, module2) {
    "use strict";
    var isValue = require_is_value();
    var forEach = Array.prototype.forEach;
    var create = Object.create;
    var process2 = function(src, obj) {
      var key;
      for (key in src)
        obj[key] = src[key];
    };
    module2.exports = function(opts1) {
      var result = create(null);
      forEach.call(arguments, function(options) {
        if (!isValue(options))
          return;
        process2(Object(options), result);
      });
      return result;
    };
  }
});

// node_modules/es5-ext/string/#/contains/is-implemented.js
var require_is_implemented3 = __commonJS({
  "node_modules/es5-ext/string/#/contains/is-implemented.js"(exports, module2) {
    "use strict";
    var str = "razdwatrzy";
    module2.exports = function() {
      if (typeof str.contains !== "function")
        return false;
      return str.contains("dwa") === true && str.contains("foo") === false;
    };
  }
});

// node_modules/es5-ext/string/#/contains/shim.js
var require_shim3 = __commonJS({
  "node_modules/es5-ext/string/#/contains/shim.js"(exports, module2) {
    "use strict";
    var indexOf = String.prototype.indexOf;
    module2.exports = function(searchString) {
      return indexOf.call(this, searchString, arguments[1]) > -1;
    };
  }
});

// node_modules/es5-ext/string/#/contains/index.js
var require_contains = __commonJS({
  "node_modules/es5-ext/string/#/contains/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented3()() ? String.prototype.contains : require_shim3();
  }
});

// node_modules/d/index.js
var require_d = __commonJS({
  "node_modules/d/index.js"(exports, module2) {
    "use strict";
    var isValue = require_is();
    var isPlainFunction = require_is5();
    var assign = require_assign();
    var normalizeOpts = require_normalize_options();
    var contains = require_contains();
    var d3 = module2.exports = function(dscr, value) {
      var c3, e3, w4, options, desc;
      if (arguments.length < 2 || typeof dscr !== "string") {
        options = value;
        value = dscr;
        dscr = null;
      } else {
        options = arguments[2];
      }
      if (isValue(dscr)) {
        c3 = contains.call(dscr, "c");
        e3 = contains.call(dscr, "e");
        w4 = contains.call(dscr, "w");
      } else {
        c3 = w4 = true;
        e3 = false;
      }
      desc = { value, configurable: c3, enumerable: e3, writable: w4 };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
    d3.gs = function(dscr, get, set) {
      var c3, e3, options, desc;
      if (typeof dscr !== "string") {
        options = set;
        set = get;
        get = dscr;
        dscr = null;
      } else {
        options = arguments[3];
      }
      if (!isValue(get)) {
        get = void 0;
      } else if (!isPlainFunction(get)) {
        options = get;
        get = set = void 0;
      } else if (!isValue(set)) {
        set = void 0;
      } else if (!isPlainFunction(set)) {
        options = set;
        set = void 0;
      }
      if (isValue(dscr)) {
        c3 = contains.call(dscr, "c");
        e3 = contains.call(dscr, "e");
      } else {
        c3 = true;
        e3 = false;
      }
      desc = { get, set, configurable: c3, enumerable: e3 };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
  }
});

// node_modules/es5-ext/object/valid-callable.js
var require_valid_callable = __commonJS({
  "node_modules/es5-ext/object/valid-callable.js"(exports, module2) {
    "use strict";
    module2.exports = function(fn2) {
      if (typeof fn2 !== "function")
        throw new TypeError(fn2 + " is not a function");
      return fn2;
    };
  }
});

// node_modules/event-emitter/index.js
var require_event_emitter = __commonJS({
  "node_modules/event-emitter/index.js"(exports, module2) {
    "use strict";
    var d3 = require_d();
    var callable = require_valid_callable();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var defineProperties = Object.defineProperties;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var descriptor = { configurable: true, enumerable: false, writable: true };
    var on2;
    var once;
    var off;
    var emit;
    var methods;
    var descriptors;
    var base;
    on2 = function(type, listener) {
      var data;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__")) {
        data = descriptor.value = create(null);
        defineProperty(this, "__ee__", descriptor);
        descriptor.value = null;
      } else {
        data = this.__ee__;
      }
      if (!data[type])
        data[type] = listener;
      else if (typeof data[type] === "object")
        data[type].push(listener);
      else
        data[type] = [data[type], listener];
      return this;
    };
    once = function(type, listener) {
      var once2, self2;
      callable(listener);
      self2 = this;
      on2.call(this, type, once2 = function() {
        off.call(self2, type, once2);
        apply.call(listener, this, arguments);
      });
      once2.__eeOnceListener__ = listener;
      return this;
    };
    off = function(type, listener) {
      var data, listeners, candidate, i3;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__"))
        return this;
      data = this.__ee__;
      if (!data[type])
        return this;
      listeners = data[type];
      if (typeof listeners === "object") {
        for (i3 = 0; candidate = listeners[i3]; ++i3) {
          if (candidate === listener || candidate.__eeOnceListener__ === listener) {
            if (listeners.length === 2)
              data[type] = listeners[i3 ? 0 : 1];
            else
              listeners.splice(i3, 1);
          }
        }
      } else {
        if (listeners === listener || listeners.__eeOnceListener__ === listener) {
          delete data[type];
        }
      }
      return this;
    };
    emit = function(type) {
      var i3, l3, listener, listeners, args;
      if (!hasOwnProperty2.call(this, "__ee__"))
        return;
      listeners = this.__ee__[type];
      if (!listeners)
        return;
      if (typeof listeners === "object") {
        l3 = arguments.length;
        args = new Array(l3 - 1);
        for (i3 = 1; i3 < l3; ++i3)
          args[i3 - 1] = arguments[i3];
        listeners = listeners.slice();
        for (i3 = 0; listener = listeners[i3]; ++i3) {
          apply.call(listener, this, args);
        }
      } else {
        switch (arguments.length) {
          case 1:
            call.call(listeners, this);
            break;
          case 2:
            call.call(listeners, this, arguments[1]);
            break;
          case 3:
            call.call(listeners, this, arguments[1], arguments[2]);
            break;
          default:
            l3 = arguments.length;
            args = new Array(l3 - 1);
            for (i3 = 1; i3 < l3; ++i3) {
              args[i3 - 1] = arguments[i3];
            }
            apply.call(listeners, this, args);
        }
      }
    };
    methods = {
      on: on2,
      once,
      off,
      emit
    };
    descriptors = {
      on: d3(on2),
      once: d3(once),
      off: d3(off),
      emit: d3(emit)
    };
    base = defineProperties({}, descriptors);
    module2.exports = exports = function(o3) {
      return o3 == null ? create(base) : defineProperties(Object(o3), descriptors);
    };
    exports.methods = methods;
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
    "use strict";
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    var MIME_TYPE = freeze({
      HTML: "text/html",
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      XML_APPLICATION: "application/xml",
      XML_TEXT: "text/xml",
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      HTML: "http://www.w3.org/1999/xhtml",
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      SVG: "http://www.w3.org/2000/svg",
      XML: "http://www.w3.org/XML/1998/namespace",
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports.freeze = freeze;
    exports.MIME_TYPE = MIME_TYPE;
    exports.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
    var conventions = require_conventions();
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input)
        return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p3 in src) {
        dest[p3] = src[p3];
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t4 = function() {
        };
        var t3 = t4;
        ;
        t4.prototype = Super.prototype;
        t4 = new t4();
        copy(pt, t4);
        Class.prototype = pt = t4;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message)
        this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      length: 0,
      item: function(index) {
        return this[index] || null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i3 = 0; i3 < this.length; i3++) {
          serializeToString(this[i3], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc != inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i3) {
      _updateLiveList(this);
      return this[i3];
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i3 = list.length;
      while (i3--) {
        if (list[i3] === node) {
          return i3;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i3 = _findNodeIndex(list, attr);
      if (i3 >= 0) {
        var lastIndex = list.length - 1;
        while (i3 < lastIndex) {
          list[i3] = list[++i3];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i3 = this.length;
        while (i3--) {
          var attr = this[i3];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i3 = this.length;
        while (i3--) {
          var node = this[i3];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      hasFeature: function(feature, version) {
        return true;
      },
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node2() {
    }
    Node2.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        this.insertBefore(newChild, oldChild);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n2 in map) {
              if (map[n2] == namespaceURI) {
                return n2;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (prefix in map) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c3) {
      return c3 == "<" && "&lt;" || c3 == ">" && "&gt;" || c3 == "&" && "&amp;" || c3 == '"' && "&quot;" || "&#" + c3.charCodeAt() + ";";
    }
    copy(NodeType, Node2);
    copy(NodeType, Node2.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i3 = 0;
          while (child) {
            cs[i3++] = child;
            child = child.nextSibling;
          }
          cs.length = i3;
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function _insertBefore(parentNode, newChild, nextChild) {
      var cp = newChild.parentNode;
      if (cp) {
        cp.removeChild(newChild);
      }
      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = newChild.firstChild;
        if (newFirst == null) {
          return newChild;
        }
        var newLast = newChild.lastChild;
      } else {
        newFirst = newLast = newChild;
      }
      var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = nextChild;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parentNode.firstChild = newFirst;
      }
      if (nextChild == null) {
        parentNode.lastChild = newLast;
      } else {
        nextChild.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parentNode;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);
      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
        newChild.firstChild = newChild.lastChild = null;
      }
      return newChild;
    }
    function _appendSingleChild(parentNode, newChild) {
      var cp = newChild.parentNode;
      if (cp) {
        var pre = parentNode.lastChild;
        cp.removeChild(newChild);
        var pre = parentNode.lastChild;
      }
      var pre = parentNode.lastChild;
      newChild.parentNode = parentNode;
      newChild.previousSibling = pre;
      newChild.nextSibling = null;
      if (pre) {
        pre.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        if (this.documentElement == null && newChild.nodeType == ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return _insertBefore(this, newChild, refChild), newChild.ownerDocument = this, newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      createElement: function(tagName) {
        var node = new Element2();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element2();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node2);
    function Element2() {
      this._nsMap = {};
    }
    Element2.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element2.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element2.prototype.getElementsByTagNameNS;
    _extends(Element2, Node2);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node2);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node2);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node2);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node2);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node2);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node2);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node2);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node2);
    function XMLSerializer2() {
    }
    XMLSerializer2.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node2.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i3 = visibleNamespaces.length;
      while (i3--) {
        var ns = visibleNamespaces[i3];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<&"]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i3 = 0; i3 < len; i3++) {
            var attr = attrs.item(i3);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i3 = 0; i3 < len; i3++) {
            var attr = attrs.item(i3);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(node.data.replace(/[<&]/g, _xmlEncoder).replace(/]]>/g, "]]&gt;"));
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n2 in node) {
        var v3 = node[n2];
        if (typeof v3 != "object") {
          if (v3 != node2[n2]) {
            node2[n2] = v3;
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i3 = 0; i3 < len; i3++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i3), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node2.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e3) {
    }
    var getTextContent;
    exports.DocumentType = DocumentType;
    exports.DOMException = DOMException;
    exports.DOMImplementation = DOMImplementation;
    exports.Element = Element2;
    exports.Node = Node2;
    exports.NodeList = NodeList;
    exports.XMLSerializer = XMLSerializer2;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
    var freeze = require_conventions().freeze;
    exports.XML_ENTITIES = freeze({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' });
    exports.HTML_ENTITIES = freeze({
      lt: "<",
      gt: ">",
      amp: "&",
      quot: '"',
      apos: "'",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      times: "\xD7",
      divide: "\xF7",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      "int": "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      euro: "\u20AC",
      trade: "\u2122",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    });
    exports.entityMap = exports.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
        domBuilder.endDocument();
      }
    };
    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a4) {
        var k4 = a4.slice(1, -1);
        if (k4 in entityMap) {
          return entityMap[k4];
        } else if (k4.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k4.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a4);
          return a4;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position(p3, m3) {
        while (p3 >= lineEnd && (m3 = linePattern.exec(source))) {
          lineStart = m3.index;
          lineEnd = lineStart + m3[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p3 - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    domBuilder.endPrefixMapping(prefix);
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end++;
              break;
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i3 = 0; i3 < len; i3++) {
                  var a3 = el[i3];
                  position(a3.offset);
                  a3.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e3) {
          if (e3 instanceof ParseError) {
            throw e3;
          }
          errorHandler.error("element parse error: " + e3);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f3, t3) {
      t3.lineNumber = f3.lineNumber;
      t3.columnNumber = f3.columnNumber;
      return t3;
    }
    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(qname, value2, startIndex);
      }
      var attrName;
      var value;
      var p3 = ++start;
      var s3 = S_TAG;
      while (true) {
        var c3 = source.charAt(p3);
        switch (c3) {
          case "=":
            if (s3 === S_ATTR) {
              attrName = source.slice(start, p3);
              s3 = S_EQ;
            } else if (s3 === S_ATTR_SPACE) {
              s3 = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s3 === S_EQ || s3 === S_ATTR) {
              if (s3 === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p3);
              }
              start = p3 + 1;
              p3 = source.indexOf(c3, start);
              if (p3 > 0) {
                value = source.slice(start, p3).replace(/&#?\w+;/g, entityReplacer);
                addAttribute(attrName, value, start - 1);
                s3 = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c3 + "' match");
              }
            } else if (s3 == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p3).replace(/&#?\w+;/g, entityReplacer);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c3 + ")!!");
              start = p3 + 1;
              s3 = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s3) {
              case S_TAG:
                el.setTagName(source.slice(start, p3));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s3 = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
              case S_ATTR_SPACE:
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s3 == S_TAG) {
              el.setTagName(source.slice(start, p3));
            }
            return p3;
          case ">":
            switch (s3) {
              case S_TAG:
                el.setTagName(source.slice(start, p3));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                value = source.slice(start, p3);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s3 === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s3 == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value.replace(/&#?\w+;/g, entityReplacer), start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p3;
          case "\x80":
            c3 = " ";
          default:
            if (c3 <= " ") {
              switch (s3) {
                case S_TAG:
                  el.setTagName(source.slice(start, p3));
                  s3 = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p3);
                  s3 = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p3).replace(/&#?\w+;/g, entityReplacer);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s3 = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s3) {
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p3;
                  s3 = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s3 = S_ATTR;
                  start = p3;
                  break;
                case S_EQ:
                  s3 = S_ATTR_NOQUOT_VALUE;
                  start = p3;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p3++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i3 = el.length;
      while (i3--) {
        var a3 = el[i3];
        var qName = a3.qName;
        var value = a3.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a3.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a3.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a3.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i3 = el.length;
      while (i3--) {
        a3 = el[i3];
        var prefix = a3.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a3.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a3.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            domBuilder.endPrefixMapping(prefix);
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n2 in source) {
        target[n2] = source[n2];
      }
    }
    function parseDCC(source, start, domBuilder, errorHandler) {
      var next = source.charAt(start + 2);
      switch (next) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i3) {
        return this[i3].localName;
      },
      getLocator: function(i3) {
        return this[i3].locator;
      },
      getQName: function(i3) {
        return this[i3].qName;
      },
      getURI: function(i3) {
        return this[i3].uri;
      },
      getValue: function(i3) {
        return this[i3].value;
      }
    };
    function split(source, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1])
          return buf;
      }
    }
    exports.XMLReader = XMLReader;
    exports.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function DOMParser2(options) {
      this.options = options || { locator: {} };
    }
    DOMParser2.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      if (source && typeof source === "string") {
        sax2.parse(source, defaultNSMap, entityMap);
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn2 = errorImpl[key];
        if (!fn2 && isCallback) {
          fn2 = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn2 && function(msg) {
          fn2("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i3 = 0; i3 < len; i3++) {
          var namespaceURI = attrs.getURI(i3);
          var value = attrs.getValue(i3);
          var qName = attrs.getQName(i3);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i3), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l3) {
      if (l3) {
        return "\n@" + (l3.systemId || "") + "#[line:" + l3.lineNumber + ",col:" + l3.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports.__DOMHandler = DOMHandler;
    exports.DOMParser = DOMParser2;
    exports.DOMImplementation = dom.DOMImplementation;
    exports.XMLSerializer = dom.XMLSerializer;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports) {
    var dom = require_dom();
    exports.DOMImplementation = dom.DOMImplementation;
    exports.XMLSerializer = dom.XMLSerializer;
    exports.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/epubjs/lib/utils/core.js
var require_core = __commonJS({
  "node_modules/epubjs/lib/utils/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RangeObject = void 0;
    exports.blob2base64 = blob2base64;
    exports.borders = borders;
    exports.bounds = bounds;
    exports.createBase64Url = createBase64Url;
    exports.createBlob = createBlob;
    exports.createBlobUrl = createBlobUrl;
    exports.defaults = defaults;
    exports.defer = defer;
    exports.documentHeight = documentHeight;
    exports.extend = extend;
    exports.filterChildren = filterChildren;
    exports.findChildren = findChildren;
    exports.getParentByTagName = getParentByTagName;
    exports.indexOfElementNode = indexOfElementNode;
    exports.indexOfNode = indexOfNode;
    exports.indexOfSorted = indexOfSorted;
    exports.indexOfTextNode = indexOfTextNode;
    exports.insert = insert;
    exports.isElement = isElement;
    exports.isFloat = isFloat;
    exports.isNumber = isNumber;
    exports.isXml = isXml;
    exports.locationOf = locationOf;
    exports.nodeBounds = nodeBounds;
    exports.parents = parents;
    exports.parse = parse;
    exports.prefixed = prefixed;
    exports.qs = qs;
    exports.qsa = qsa;
    exports.qsp = qsp;
    exports.querySelectorByType = querySelectorByType;
    exports.requestAnimationFrame = void 0;
    exports.revokeBlobUrl = revokeBlobUrl;
    exports.sprint = sprint;
    exports.treeWalker = treeWalker;
    exports.type = type;
    exports.uuid = uuid;
    exports.walk = walk;
    exports.windowBounds = windowBounds;
    var _xmldom = require_lib();
    var requestAnimationFrame2 = typeof window != "undefined" ? window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame : false;
    exports.requestAnimationFrame = requestAnimationFrame2;
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var _URL = typeof URL != "undefined" ? URL : typeof window != "undefined" ? window.URL || window.webkitURL || window.mozURL : void 0;
    function uuid() {
      var d3 = new Date().getTime();
      var uuid2 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c3) {
        var r3 = (d3 + Math.random() * 16) % 16 | 0;
        d3 = Math.floor(d3 / 16);
        return (c3 == "x" ? r3 : r3 & 7 | 8).toString(16);
      });
      return uuid2;
    }
    function documentHeight() {
      return Math.max(document.documentElement.clientHeight, document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight);
    }
    function isElement(obj) {
      return !!(obj && obj.nodeType == 1);
    }
    function isNumber(n2) {
      return !isNaN(parseFloat(n2)) && isFinite(n2);
    }
    function isFloat(n2) {
      let f3 = parseFloat(n2);
      if (isNumber(n2) === false) {
        return false;
      }
      if (typeof n2 === "string" && n2.indexOf(".") > -1) {
        return true;
      }
      return Math.floor(f3) !== f3;
    }
    function prefixed(unprefixed) {
      var vendors = ["Webkit", "webkit", "Moz", "O", "ms"];
      var prefixes = ["-webkit-", "-webkit-", "-moz-", "-o-", "-ms-"];
      var lower = unprefixed.toLowerCase();
      var length = vendors.length;
      if (typeof document === "undefined" || typeof document.body.style[lower] != "undefined") {
        return unprefixed;
      }
      for (var i3 = 0; i3 < length; i3++) {
        if (typeof document.body.style[prefixes[i3] + lower] != "undefined") {
          return prefixes[i3] + lower;
        }
      }
      return unprefixed;
    }
    function defaults(obj) {
      for (var i3 = 1, length = arguments.length; i3 < length; i3++) {
        var source = arguments[i3];
        for (var prop in source) {
          if (obj[prop] === void 0)
            obj[prop] = source[prop];
        }
      }
      return obj;
    }
    function extend(target) {
      var sources = [].slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source)
          return;
        Object.getOwnPropertyNames(source).forEach(function(propName) {
          Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));
        });
      });
      return target;
    }
    function insert(item, array, compareFunction) {
      var location = locationOf(item, array, compareFunction);
      array.splice(location, 0, item);
      return location;
    }
    function locationOf(item, array, compareFunction, _start, _end) {
      var start = _start || 0;
      var end = _end || array.length;
      var pivot = parseInt(start + (end - start) / 2);
      var compared;
      if (!compareFunction) {
        compareFunction = function(a3, b3) {
          if (a3 > b3)
            return 1;
          if (a3 < b3)
            return -1;
          if (a3 == b3)
            return 0;
        };
      }
      if (end - start <= 0) {
        return pivot;
      }
      compared = compareFunction(array[pivot], item);
      if (end - start === 1) {
        return compared >= 0 ? pivot : pivot + 1;
      }
      if (compared === 0) {
        return pivot;
      }
      if (compared === -1) {
        return locationOf(item, array, compareFunction, pivot, end);
      } else {
        return locationOf(item, array, compareFunction, start, pivot);
      }
    }
    function indexOfSorted(item, array, compareFunction, _start, _end) {
      var start = _start || 0;
      var end = _end || array.length;
      var pivot = parseInt(start + (end - start) / 2);
      var compared;
      if (!compareFunction) {
        compareFunction = function(a3, b3) {
          if (a3 > b3)
            return 1;
          if (a3 < b3)
            return -1;
          if (a3 == b3)
            return 0;
        };
      }
      if (end - start <= 0) {
        return -1;
      }
      compared = compareFunction(array[pivot], item);
      if (end - start === 1) {
        return compared === 0 ? pivot : -1;
      }
      if (compared === 0) {
        return pivot;
      }
      if (compared === -1) {
        return indexOfSorted(item, array, compareFunction, pivot, end);
      } else {
        return indexOfSorted(item, array, compareFunction, start, pivot);
      }
    }
    function bounds(el) {
      var style = window.getComputedStyle(el);
      var widthProps = ["width", "paddingRight", "paddingLeft", "marginRight", "marginLeft", "borderRightWidth", "borderLeftWidth"];
      var heightProps = ["height", "paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"];
      var width = 0;
      var height = 0;
      widthProps.forEach(function(prop) {
        width += parseFloat(style[prop]) || 0;
      });
      heightProps.forEach(function(prop) {
        height += parseFloat(style[prop]) || 0;
      });
      return {
        height,
        width
      };
    }
    function borders(el) {
      var style = window.getComputedStyle(el);
      var widthProps = ["paddingRight", "paddingLeft", "marginRight", "marginLeft", "borderRightWidth", "borderLeftWidth"];
      var heightProps = ["paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"];
      var width = 0;
      var height = 0;
      widthProps.forEach(function(prop) {
        width += parseFloat(style[prop]) || 0;
      });
      heightProps.forEach(function(prop) {
        height += parseFloat(style[prop]) || 0;
      });
      return {
        height,
        width
      };
    }
    function nodeBounds(node) {
      let elPos;
      let doc = node.ownerDocument;
      if (node.nodeType == Node.TEXT_NODE) {
        let elRange = doc.createRange();
        elRange.selectNodeContents(node);
        elPos = elRange.getBoundingClientRect();
      } else {
        elPos = node.getBoundingClientRect();
      }
      return elPos;
    }
    function windowBounds() {
      var width = window.innerWidth;
      var height = window.innerHeight;
      return {
        top: 0,
        left: 0,
        right: width,
        bottom: height,
        width,
        height
      };
    }
    function indexOfNode(node, typeId) {
      var parent2 = node.parentNode;
      var children = parent2.childNodes;
      var sib;
      var index = -1;
      for (var i3 = 0; i3 < children.length; i3++) {
        sib = children[i3];
        if (sib.nodeType === typeId) {
          index++;
        }
        if (sib == node)
          break;
      }
      return index;
    }
    function indexOfTextNode(textNode) {
      return indexOfNode(textNode, TEXT_NODE);
    }
    function indexOfElementNode(elementNode) {
      return indexOfNode(elementNode, ELEMENT_NODE);
    }
    function isXml(ext) {
      return ["xml", "opf", "ncx"].indexOf(ext) > -1;
    }
    function createBlob(content, mime) {
      return new Blob([content], {
        type: mime
      });
    }
    function createBlobUrl(content, mime) {
      var tempUrl;
      var blob = createBlob(content, mime);
      tempUrl = _URL.createObjectURL(blob);
      return tempUrl;
    }
    function revokeBlobUrl(url) {
      return _URL.revokeObjectURL(url);
    }
    function createBase64Url(content, mime) {
      var data;
      var datauri;
      if (typeof content !== "string") {
        return;
      }
      data = btoa(content);
      datauri = "data:" + mime + ";base64," + data;
      return datauri;
    }
    function type(obj) {
      return Object.prototype.toString.call(obj).slice(8, -1);
    }
    function parse(markup, mime, forceXMLDom) {
      var doc;
      var Parser;
      if (typeof DOMParser === "undefined" || forceXMLDom) {
        Parser = _xmldom.DOMParser;
      } else {
        Parser = DOMParser;
      }
      if (markup.charCodeAt(0) === 65279) {
        markup = markup.slice(1);
      }
      doc = new Parser().parseFromString(markup, mime);
      return doc;
    }
    function qs(el, sel) {
      var elements;
      if (!el) {
        throw new Error("No Element Provided");
      }
      if (typeof el.querySelector != "undefined") {
        return el.querySelector(sel);
      } else {
        elements = el.getElementsByTagName(sel);
        if (elements.length) {
          return elements[0];
        }
      }
    }
    function qsa(el, sel) {
      if (typeof el.querySelector != "undefined") {
        return el.querySelectorAll(sel);
      } else {
        return el.getElementsByTagName(sel);
      }
    }
    function qsp(el, sel, props) {
      var q4, filtered;
      if (typeof el.querySelector != "undefined") {
        sel += "[";
        for (var prop in props) {
          sel += prop + "~='" + props[prop] + "'";
        }
        sel += "]";
        return el.querySelector(sel);
      } else {
        q4 = el.getElementsByTagName(sel);
        filtered = Array.prototype.slice.call(q4, 0).filter(function(el2) {
          for (var prop2 in props) {
            if (el2.getAttribute(prop2) === props[prop2]) {
              return true;
            }
          }
          return false;
        });
        if (filtered) {
          return filtered[0];
        }
      }
    }
    function sprint(root, func) {
      var doc = root.ownerDocument || root;
      if (typeof doc.createTreeWalker !== "undefined") {
        treeWalker(root, func, NodeFilter.SHOW_TEXT);
      } else {
        walk(root, function(node) {
          if (node && node.nodeType === 3) {
            func(node);
          }
        }, true);
      }
    }
    function treeWalker(root, func, filter) {
      var treeWalker2 = document.createTreeWalker(root, filter, null, false);
      let node;
      while (node = treeWalker2.nextNode()) {
        func(node);
      }
    }
    function walk(node, callback) {
      if (callback(node)) {
        return true;
      }
      node = node.firstChild;
      if (node) {
        do {
          let walked = walk(node, callback);
          if (walked) {
            return true;
          }
          node = node.nextSibling;
        } while (node);
      }
    }
    function blob2base64(blob) {
      return new Promise(function(resolve, reject) {
        var reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onloadend = function() {
          resolve(reader.result);
        };
      });
    }
    function defer() {
      this.resolve = null;
      this.reject = null;
      this.id = uuid();
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
      Object.freeze(this);
    }
    function querySelectorByType(html, element, type2) {
      var query;
      if (typeof html.querySelector != "undefined") {
        query = html.querySelector(`${element}[*|type="${type2}"]`);
      }
      if (!query || query.length === 0) {
        query = qsa(html, element);
        for (var i3 = 0; i3 < query.length; i3++) {
          if (query[i3].getAttributeNS("http://www.idpf.org/2007/ops", "type") === type2 || query[i3].getAttribute("epub:type") === type2) {
            return query[i3];
          }
        }
      } else {
        return query;
      }
    }
    function findChildren(el) {
      var result = [];
      var childNodes = el.childNodes;
      for (var i3 = 0; i3 < childNodes.length; i3++) {
        let node = childNodes[i3];
        if (node.nodeType === 1) {
          result.push(node);
        }
      }
      return result;
    }
    function parents(node) {
      var nodes = [node];
      for (; node; node = node.parentNode) {
        nodes.unshift(node);
      }
      return nodes;
    }
    function filterChildren(el, nodeName, single) {
      var result = [];
      var childNodes = el.childNodes;
      for (var i3 = 0; i3 < childNodes.length; i3++) {
        let node = childNodes[i3];
        if (node.nodeType === 1 && node.nodeName.toLowerCase() === nodeName) {
          if (single) {
            return node;
          } else {
            result.push(node);
          }
        }
      }
      if (!single) {
        return result;
      }
    }
    function getParentByTagName(node, tagname) {
      let parent2;
      if (node === null || tagname === "")
        return;
      parent2 = node.parentNode;
      while (parent2.nodeType === 1) {
        if (parent2.tagName.toLowerCase() === tagname) {
          return parent2;
        }
        parent2 = parent2.parentNode;
      }
    }
    var RangeObject = class {
      constructor() {
        this.collapsed = false;
        this.commonAncestorContainer = void 0;
        this.endContainer = void 0;
        this.endOffset = void 0;
        this.startContainer = void 0;
        this.startOffset = void 0;
      }
      setStart(startNode, startOffset) {
        this.startContainer = startNode;
        this.startOffset = startOffset;
        if (!this.endContainer) {
          this.collapse(true);
        } else {
          this.commonAncestorContainer = this._commonAncestorContainer();
        }
        this._checkCollapsed();
      }
      setEnd(endNode, endOffset) {
        this.endContainer = endNode;
        this.endOffset = endOffset;
        if (!this.startContainer) {
          this.collapse(false);
        } else {
          this.collapsed = false;
          this.commonAncestorContainer = this._commonAncestorContainer();
        }
        this._checkCollapsed();
      }
      collapse(toStart) {
        this.collapsed = true;
        if (toStart) {
          this.endContainer = this.startContainer;
          this.endOffset = this.startOffset;
          this.commonAncestorContainer = this.startContainer.parentNode;
        } else {
          this.startContainer = this.endContainer;
          this.startOffset = this.endOffset;
          this.commonAncestorContainer = this.endOffset.parentNode;
        }
      }
      selectNode(referenceNode) {
        let parent2 = referenceNode.parentNode;
        let index = Array.prototype.indexOf.call(parent2.childNodes, referenceNode);
        this.setStart(parent2, index);
        this.setEnd(parent2, index + 1);
      }
      selectNodeContents(referenceNode) {
        let end = referenceNode.childNodes[referenceNode.childNodes - 1];
        let endIndex = referenceNode.nodeType === 3 ? referenceNode.textContent.length : parent.childNodes.length;
        this.setStart(referenceNode, 0);
        this.setEnd(referenceNode, endIndex);
      }
      _commonAncestorContainer(startContainer, endContainer) {
        var startParents = parents(startContainer || this.startContainer);
        var endParents = parents(endContainer || this.endContainer);
        if (startParents[0] != endParents[0])
          return void 0;
        for (var i3 = 0; i3 < startParents.length; i3++) {
          if (startParents[i3] != endParents[i3]) {
            return startParents[i3 - 1];
          }
        }
      }
      _checkCollapsed() {
        if (this.startContainer === this.endContainer && this.startOffset === this.endOffset) {
          this.collapsed = true;
        } else {
          this.collapsed = false;
        }
      }
      toString() {
      }
    };
    exports.RangeObject = RangeObject;
  }
});

// node_modules/path-webpack/path.js
var require_path = __commonJS({
  "node_modules/path-webpack/path.js"(exports, module2) {
    "use strict";
    if (!process2) {
      process2 = {
        "cwd": function() {
          return "/";
        }
      };
    }
    var process2;
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + path);
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i3 = 0; i3 <= path.length; ++i3) {
        if (i3 < path.length)
          code = path.charCodeAt(i3);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i3 - 1 || dots === 1) {
          } else if (lastSlash !== i3 - 1 && dots === 2) {
            if (res.length < 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var start = res.length - 1;
                var j4 = start;
                for (; j4 >= 0; --j4) {
                  if (res.charCodeAt(j4) === 47)
                    break;
                }
                if (j4 !== start) {
                  if (j4 === -1)
                    res = "";
                  else
                    res = res.slice(0, j4);
                  lastSlash = i3;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSlash = i3;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i3);
            else
              res = path.slice(lastSlash + 1, i3);
          }
          lastSlash = i3;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i3 = arguments.length - 1; i3 >= -1 && !resolvedAbsolute; i3--) {
          var path;
          if (i3 >= 0)
            path = arguments[i3];
          else {
            if (cwd === void 0)
              cwd = process2.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute)
          path = ".";
        if (path.length > 0 && trailingSeparator)
          path += "/";
        if (isAbsolute)
          return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i3 = 0; i3 < arguments.length; ++i3) {
          var arg = arguments[i3];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to)
          return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i3 = 0;
        for (; i3 <= length; ++i3) {
          if (i3 === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i3) === 47) {
                return to.slice(toStart + i3 + 1);
              } else if (i3 === 0) {
                return to.slice(toStart + i3);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i3) === 47) {
                lastCommonSep = i3;
              } else if (i3 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i3);
          var toCode = to.charCodeAt(toStart + i3);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i3;
        }
        var out = "";
        for (i3 = fromStart + lastCommonSep + 1; i3 <= fromEnd; ++i3) {
          if (i3 === fromEnd || from.charCodeAt(i3) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i3 = path.length - 1; i3 >= 1; --i3) {
          code = path.charCodeAt(i3);
          if (code === 47) {
            if (!matchedSlash) {
              end = i3;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path.slice(0, end);
      },
      basename: function basename(path, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i3;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i3 = path.length - 1; i3 >= 0; --i3) {
            var code = path.charCodeAt(i3);
            if (code === 47) {
              if (!matchedSlash) {
                start = i3 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i3 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i3;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path.length;
          return path.slice(start, end);
        } else {
          for (i3 = path.length - 1; i3 >= 0; --i3) {
            if (path.charCodeAt(i3) === 47) {
              if (!matchedSlash) {
                start = i3 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i3 + 1;
            }
          }
          if (end === -1)
            return "";
          return path.slice(start, end);
        }
      },
      extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i3 = path.length - 1; i3 >= 0; --i3) {
          var code = path.charCodeAt(i3);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i3 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i3;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('Parameter "pathObject" must be an object, not ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
          return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i3 = path.length - 1;
        var preDotState = 0;
        for (; i3 >= start; --i3) {
          code = path.charCodeAt(i3);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i3 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i3;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path.slice(1, end);
            else
              ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      posix: null
    };
    module2.exports = posix;
  }
});

// node_modules/epubjs/lib/utils/path.js
var require_path2 = __commonJS({
  "node_modules/epubjs/lib/utils/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _pathWebpack = _interopRequireDefault(require_path());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Path = class {
      constructor(pathString) {
        var protocol;
        var parsed;
        protocol = pathString.indexOf("://");
        if (protocol > -1) {
          pathString = new URL(pathString).pathname;
        }
        parsed = this.parse(pathString);
        this.path = pathString;
        if (this.isDirectory(pathString)) {
          this.directory = pathString;
        } else {
          this.directory = parsed.dir + "/";
        }
        this.filename = parsed.base;
        this.extension = parsed.ext.slice(1);
      }
      parse(what) {
        return _pathWebpack.default.parse(what);
      }
      isAbsolute(what) {
        return _pathWebpack.default.isAbsolute(what || this.path);
      }
      isDirectory(what) {
        return what.charAt(what.length - 1) === "/";
      }
      resolve(what) {
        return _pathWebpack.default.resolve(this.directory, what);
      }
      relative(what) {
        var isAbsolute = what && what.indexOf("://") > -1;
        if (isAbsolute) {
          return what;
        }
        return _pathWebpack.default.relative(this.directory, what);
      }
      splitPath(filename) {
        return this.splitPathRe.exec(filename).slice(1);
      }
      toString() {
        return this.path;
      }
    };
    var _default = Path;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/url.js
var require_url = __commonJS({
  "node_modules/epubjs/lib/utils/url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _path = _interopRequireDefault(require_path2());
    var _pathWebpack = _interopRequireDefault(require_path());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Url = class {
      constructor(urlString, baseString) {
        var absolute = urlString.indexOf("://") > -1;
        var pathname = urlString;
        var basePath;
        this.Url = void 0;
        this.href = urlString;
        this.protocol = "";
        this.origin = "";
        this.hash = "";
        this.hash = "";
        this.search = "";
        this.base = baseString;
        if (!absolute && baseString !== false && typeof baseString !== "string" && window && window.location) {
          this.base = window.location.href;
        }
        if (absolute || this.base) {
          try {
            if (this.base) {
              this.Url = new URL(urlString, this.base);
            } else {
              this.Url = new URL(urlString);
            }
            this.href = this.Url.href;
            this.protocol = this.Url.protocol;
            this.origin = this.Url.origin;
            this.hash = this.Url.hash;
            this.search = this.Url.search;
            pathname = this.Url.pathname + (this.Url.search ? this.Url.search : "");
          } catch (e3) {
            this.Url = void 0;
            if (this.base) {
              basePath = new _path.default(this.base);
              pathname = basePath.resolve(pathname);
            }
          }
        }
        this.Path = new _path.default(pathname);
        this.directory = this.Path.directory;
        this.filename = this.Path.filename;
        this.extension = this.Path.extension;
      }
      path() {
        return this.Path;
      }
      resolve(what) {
        var isAbsolute = what.indexOf("://") > -1;
        var fullpath;
        if (isAbsolute) {
          return what;
        }
        fullpath = _pathWebpack.default.resolve(this.directory, what);
        return this.origin + fullpath;
      }
      relative(what) {
        return _pathWebpack.default.relative(what, this.directory);
      }
      toString() {
        return this.href;
      }
    };
    var _default = Url;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/epubcfi.js
var require_epubcfi = __commonJS({
  "node_modules/epubjs/lib/epubcfi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var DOCUMENT_NODE = 9;
    var EpubCFI = class {
      constructor(cfiFrom, base, ignoreClass) {
        var type;
        this.str = "";
        this.base = {};
        this.spinePos = 0;
        this.range = false;
        this.path = {};
        this.start = null;
        this.end = null;
        if (!(this instanceof EpubCFI)) {
          return new EpubCFI(cfiFrom, base, ignoreClass);
        }
        if (typeof base === "string") {
          this.base = this.parseComponent(base);
        } else if (typeof base === "object" && base.steps) {
          this.base = base;
        }
        type = this.checkType(cfiFrom);
        if (type === "string") {
          this.str = cfiFrom;
          return (0, _core.extend)(this, this.parse(cfiFrom));
        } else if (type === "range") {
          return (0, _core.extend)(this, this.fromRange(cfiFrom, this.base, ignoreClass));
        } else if (type === "node") {
          return (0, _core.extend)(this, this.fromNode(cfiFrom, this.base, ignoreClass));
        } else if (type === "EpubCFI" && cfiFrom.path) {
          return cfiFrom;
        } else if (!cfiFrom) {
          return this;
        } else {
          throw new TypeError("not a valid argument for EpubCFI");
        }
      }
      checkType(cfi) {
        if (this.isCfiString(cfi)) {
          return "string";
        } else if (cfi && typeof cfi === "object" && ((0, _core.type)(cfi) === "Range" || typeof cfi.startContainer != "undefined")) {
          return "range";
        } else if (cfi && typeof cfi === "object" && typeof cfi.nodeType != "undefined") {
          return "node";
        } else if (cfi && typeof cfi === "object" && cfi instanceof EpubCFI) {
          return "EpubCFI";
        } else {
          return false;
        }
      }
      parse(cfiStr) {
        var cfi = {
          spinePos: -1,
          range: false,
          base: {},
          path: {},
          start: null,
          end: null
        };
        var baseComponent, pathComponent, range;
        if (typeof cfiStr !== "string") {
          return {
            spinePos: -1
          };
        }
        if (cfiStr.indexOf("epubcfi(") === 0 && cfiStr[cfiStr.length - 1] === ")") {
          cfiStr = cfiStr.slice(8, cfiStr.length - 1);
        }
        baseComponent = this.getChapterComponent(cfiStr);
        if (!baseComponent) {
          return {
            spinePos: -1
          };
        }
        cfi.base = this.parseComponent(baseComponent);
        pathComponent = this.getPathComponent(cfiStr);
        cfi.path = this.parseComponent(pathComponent);
        range = this.getRange(cfiStr);
        if (range) {
          cfi.range = true;
          cfi.start = this.parseComponent(range[0]);
          cfi.end = this.parseComponent(range[1]);
        }
        cfi.spinePos = cfi.base.steps[1].index;
        return cfi;
      }
      parseComponent(componentStr) {
        var component = {
          steps: [],
          terminal: {
            offset: null,
            assertion: null
          }
        };
        var parts = componentStr.split(":");
        var steps = parts[0].split("/");
        var terminal;
        if (parts.length > 1) {
          terminal = parts[1];
          component.terminal = this.parseTerminal(terminal);
        }
        if (steps[0] === "") {
          steps.shift();
        }
        component.steps = steps.map(function(step) {
          return this.parseStep(step);
        }.bind(this));
        return component;
      }
      parseStep(stepStr) {
        var type, num, index, has_brackets, id;
        has_brackets = stepStr.match(/\[(.*)\]/);
        if (has_brackets && has_brackets[1]) {
          id = has_brackets[1];
        }
        num = parseInt(stepStr);
        if (isNaN(num)) {
          return;
        }
        if (num % 2 === 0) {
          type = "element";
          index = num / 2 - 1;
        } else {
          type = "text";
          index = (num - 1) / 2;
        }
        return {
          "type": type,
          "index": index,
          "id": id || null
        };
      }
      parseTerminal(termialStr) {
        var characterOffset, textLocationAssertion;
        var assertion = termialStr.match(/\[(.*)\]/);
        if (assertion && assertion[1]) {
          characterOffset = parseInt(termialStr.split("[")[0]);
          textLocationAssertion = assertion[1];
        } else {
          characterOffset = parseInt(termialStr);
        }
        if (!(0, _core.isNumber)(characterOffset)) {
          characterOffset = null;
        }
        return {
          "offset": characterOffset,
          "assertion": textLocationAssertion
        };
      }
      getChapterComponent(cfiStr) {
        var indirection = cfiStr.split("!");
        return indirection[0];
      }
      getPathComponent(cfiStr) {
        var indirection = cfiStr.split("!");
        if (indirection[1]) {
          let ranges = indirection[1].split(",");
          return ranges[0];
        }
      }
      getRange(cfiStr) {
        var ranges = cfiStr.split(",");
        if (ranges.length === 3) {
          return [ranges[1], ranges[2]];
        }
        return false;
      }
      getCharecterOffsetComponent(cfiStr) {
        var splitStr = cfiStr.split(":");
        return splitStr[1] || "";
      }
      joinSteps(steps) {
        if (!steps) {
          return "";
        }
        return steps.map(function(part) {
          var segment = "";
          if (part.type === "element") {
            segment += (part.index + 1) * 2;
          }
          if (part.type === "text") {
            segment += 1 + 2 * part.index;
          }
          if (part.id) {
            segment += "[" + part.id + "]";
          }
          return segment;
        }).join("/");
      }
      segmentString(segment) {
        var segmentString = "/";
        segmentString += this.joinSteps(segment.steps);
        if (segment.terminal && segment.terminal.offset != null) {
          segmentString += ":" + segment.terminal.offset;
        }
        if (segment.terminal && segment.terminal.assertion != null) {
          segmentString += "[" + segment.terminal.assertion + "]";
        }
        return segmentString;
      }
      toString() {
        var cfiString = "epubcfi(";
        cfiString += this.segmentString(this.base);
        cfiString += "!";
        cfiString += this.segmentString(this.path);
        if (this.range && this.start) {
          cfiString += ",";
          cfiString += this.segmentString(this.start);
        }
        if (this.range && this.end) {
          cfiString += ",";
          cfiString += this.segmentString(this.end);
        }
        cfiString += ")";
        return cfiString;
      }
      compare(cfiOne, cfiTwo) {
        var stepsA, stepsB;
        var terminalA, terminalB;
        var rangeAStartSteps, rangeAEndSteps;
        var rangeBEndSteps, rangeBEndSteps;
        var rangeAStartTerminal, rangeAEndTerminal;
        var rangeBStartTerminal, rangeBEndTerminal;
        if (typeof cfiOne === "string") {
          cfiOne = new EpubCFI(cfiOne);
        }
        if (typeof cfiTwo === "string") {
          cfiTwo = new EpubCFI(cfiTwo);
        }
        if (cfiOne.spinePos > cfiTwo.spinePos) {
          return 1;
        }
        if (cfiOne.spinePos < cfiTwo.spinePos) {
          return -1;
        }
        if (cfiOne.range) {
          stepsA = cfiOne.path.steps.concat(cfiOne.start.steps);
          terminalA = cfiOne.start.terminal;
        } else {
          stepsA = cfiOne.path.steps;
          terminalA = cfiOne.path.terminal;
        }
        if (cfiTwo.range) {
          stepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);
          terminalB = cfiTwo.start.terminal;
        } else {
          stepsB = cfiTwo.path.steps;
          terminalB = cfiTwo.path.terminal;
        }
        for (var i3 = 0; i3 < stepsA.length; i3++) {
          if (!stepsA[i3]) {
            return -1;
          }
          if (!stepsB[i3]) {
            return 1;
          }
          if (stepsA[i3].index > stepsB[i3].index) {
            return 1;
          }
          if (stepsA[i3].index < stepsB[i3].index) {
            return -1;
          }
        }
        if (stepsA.length < stepsB.length) {
          return -1;
        }
        if (terminalA.offset > terminalB.offset) {
          return 1;
        }
        if (terminalA.offset < terminalB.offset) {
          return -1;
        }
        return 0;
      }
      step(node) {
        var nodeType = node.nodeType === TEXT_NODE ? "text" : "element";
        return {
          "id": node.id,
          "tagName": node.tagName,
          "type": nodeType,
          "index": this.position(node)
        };
      }
      filteredStep(node, ignoreClass) {
        var filteredNode = this.filter(node, ignoreClass);
        var nodeType;
        if (!filteredNode) {
          return;
        }
        nodeType = filteredNode.nodeType === TEXT_NODE ? "text" : "element";
        return {
          "id": filteredNode.id,
          "tagName": filteredNode.tagName,
          "type": nodeType,
          "index": this.filteredPosition(filteredNode, ignoreClass)
        };
      }
      pathTo(node, offset, ignoreClass) {
        var segment = {
          steps: [],
          terminal: {
            offset: null,
            assertion: null
          }
        };
        var currentNode = node;
        var step;
        while (currentNode && currentNode.parentNode && currentNode.parentNode.nodeType != DOCUMENT_NODE) {
          if (ignoreClass) {
            step = this.filteredStep(currentNode, ignoreClass);
          } else {
            step = this.step(currentNode);
          }
          if (step) {
            segment.steps.unshift(step);
          }
          currentNode = currentNode.parentNode;
        }
        if (offset != null && offset >= 0) {
          segment.terminal.offset = offset;
          if (segment.steps[segment.steps.length - 1].type != "text") {
            segment.steps.push({
              "type": "text",
              "index": 0
            });
          }
        }
        return segment;
      }
      equalStep(stepA, stepB) {
        if (!stepA || !stepB) {
          return false;
        }
        if (stepA.index === stepB.index && stepA.id === stepB.id && stepA.type === stepB.type) {
          return true;
        }
        return false;
      }
      fromRange(range, base, ignoreClass) {
        var cfi = {
          range: false,
          base: {},
          path: {},
          start: null,
          end: null
        };
        var start = range.startContainer;
        var end = range.endContainer;
        var startOffset = range.startOffset;
        var endOffset = range.endOffset;
        var needsIgnoring = false;
        if (ignoreClass) {
          needsIgnoring = start.ownerDocument.querySelector("." + ignoreClass) != null;
        }
        if (typeof base === "string") {
          cfi.base = this.parseComponent(base);
          cfi.spinePos = cfi.base.steps[1].index;
        } else if (typeof base === "object") {
          cfi.base = base;
        }
        if (range.collapsed) {
          if (needsIgnoring) {
            startOffset = this.patchOffset(start, startOffset, ignoreClass);
          }
          cfi.path = this.pathTo(start, startOffset, ignoreClass);
        } else {
          cfi.range = true;
          if (needsIgnoring) {
            startOffset = this.patchOffset(start, startOffset, ignoreClass);
          }
          cfi.start = this.pathTo(start, startOffset, ignoreClass);
          if (needsIgnoring) {
            endOffset = this.patchOffset(end, endOffset, ignoreClass);
          }
          cfi.end = this.pathTo(end, endOffset, ignoreClass);
          cfi.path = {
            steps: [],
            terminal: null
          };
          var len = cfi.start.steps.length;
          var i3;
          for (i3 = 0; i3 < len; i3++) {
            if (this.equalStep(cfi.start.steps[i3], cfi.end.steps[i3])) {
              if (i3 === len - 1) {
                if (cfi.start.terminal === cfi.end.terminal) {
                  cfi.path.steps.push(cfi.start.steps[i3]);
                  cfi.range = false;
                }
              } else {
                cfi.path.steps.push(cfi.start.steps[i3]);
              }
            } else {
              break;
            }
          }
          cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);
          cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length);
        }
        return cfi;
      }
      fromNode(anchor, base, ignoreClass) {
        var cfi = {
          range: false,
          base: {},
          path: {},
          start: null,
          end: null
        };
        if (typeof base === "string") {
          cfi.base = this.parseComponent(base);
          cfi.spinePos = cfi.base.steps[1].index;
        } else if (typeof base === "object") {
          cfi.base = base;
        }
        cfi.path = this.pathTo(anchor, null, ignoreClass);
        return cfi;
      }
      filter(anchor, ignoreClass) {
        var needsIgnoring;
        var sibling;
        var parent2, previousSibling, nextSibling;
        var isText = false;
        if (anchor.nodeType === TEXT_NODE) {
          isText = true;
          parent2 = anchor.parentNode;
          needsIgnoring = anchor.parentNode.classList.contains(ignoreClass);
        } else {
          isText = false;
          needsIgnoring = anchor.classList.contains(ignoreClass);
        }
        if (needsIgnoring && isText) {
          previousSibling = parent2.previousSibling;
          nextSibling = parent2.nextSibling;
          if (previousSibling && previousSibling.nodeType === TEXT_NODE) {
            sibling = previousSibling;
          } else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {
            sibling = nextSibling;
          }
          if (sibling) {
            return sibling;
          } else {
            return anchor;
          }
        } else if (needsIgnoring && !isText) {
          return false;
        } else {
          return anchor;
        }
      }
      patchOffset(anchor, offset, ignoreClass) {
        if (anchor.nodeType != TEXT_NODE) {
          throw new Error("Anchor must be a text node");
        }
        var curr = anchor;
        var totalOffset = offset;
        if (anchor.parentNode.classList.contains(ignoreClass)) {
          curr = anchor.parentNode;
        }
        while (curr.previousSibling) {
          if (curr.previousSibling.nodeType === ELEMENT_NODE) {
            if (curr.previousSibling.classList.contains(ignoreClass)) {
              totalOffset += curr.previousSibling.textContent.length;
            } else {
              break;
            }
          } else {
            totalOffset += curr.previousSibling.textContent.length;
          }
          curr = curr.previousSibling;
        }
        return totalOffset;
      }
      normalizedMap(children, nodeType, ignoreClass) {
        var output = {};
        var prevIndex = -1;
        var i3, len = children.length;
        var currNodeType;
        var prevNodeType;
        for (i3 = 0; i3 < len; i3++) {
          currNodeType = children[i3].nodeType;
          if (currNodeType === ELEMENT_NODE && children[i3].classList.contains(ignoreClass)) {
            currNodeType = TEXT_NODE;
          }
          if (i3 > 0 && currNodeType === TEXT_NODE && prevNodeType === TEXT_NODE) {
            output[i3] = prevIndex;
          } else if (nodeType === currNodeType) {
            prevIndex = prevIndex + 1;
            output[i3] = prevIndex;
          }
          prevNodeType = currNodeType;
        }
        return output;
      }
      position(anchor) {
        var children, index;
        if (anchor.nodeType === ELEMENT_NODE) {
          children = anchor.parentNode.children;
          if (!children) {
            children = (0, _core.findChildren)(anchor.parentNode);
          }
          index = Array.prototype.indexOf.call(children, anchor);
        } else {
          children = this.textNodes(anchor.parentNode);
          index = children.indexOf(anchor);
        }
        return index;
      }
      filteredPosition(anchor, ignoreClass) {
        var children, index, map;
        if (anchor.nodeType === ELEMENT_NODE) {
          children = anchor.parentNode.children;
          map = this.normalizedMap(children, ELEMENT_NODE, ignoreClass);
        } else {
          children = anchor.parentNode.childNodes;
          if (anchor.parentNode.classList.contains(ignoreClass)) {
            anchor = anchor.parentNode;
            children = anchor.parentNode.childNodes;
          }
          map = this.normalizedMap(children, TEXT_NODE, ignoreClass);
        }
        index = Array.prototype.indexOf.call(children, anchor);
        return map[index];
      }
      stepsToXpath(steps) {
        var xpath = [".", "*"];
        steps.forEach(function(step) {
          var position = step.index + 1;
          if (step.id) {
            xpath.push("*[position()=" + position + " and @id='" + step.id + "']");
          } else if (step.type === "text") {
            xpath.push("text()[" + position + "]");
          } else {
            xpath.push("*[" + position + "]");
          }
        });
        return xpath.join("/");
      }
      stepsToQuerySelector(steps) {
        var query = ["html"];
        steps.forEach(function(step) {
          var position = step.index + 1;
          if (step.id) {
            query.push("#" + step.id);
          } else if (step.type === "text") {
          } else {
            query.push("*:nth-child(" + position + ")");
          }
        });
        return query.join(">");
      }
      textNodes(container, ignoreClass) {
        return Array.prototype.slice.call(container.childNodes).filter(function(node) {
          if (node.nodeType === TEXT_NODE) {
            return true;
          } else if (ignoreClass && node.classList.contains(ignoreClass)) {
            return true;
          }
          return false;
        });
      }
      walkToNode(steps, _doc, ignoreClass) {
        var doc = _doc || document;
        var container = doc.documentElement;
        var children;
        var step;
        var len = steps.length;
        var i3;
        for (i3 = 0; i3 < len; i3++) {
          step = steps[i3];
          if (step.type === "element") {
            if (step.id) {
              container = doc.getElementById(step.id);
            } else {
              children = container.children || (0, _core.findChildren)(container);
              container = children[step.index];
            }
          } else if (step.type === "text") {
            container = this.textNodes(container, ignoreClass)[step.index];
          }
          if (!container) {
            break;
          }
        }
        return container;
      }
      findNode(steps, _doc, ignoreClass) {
        var doc = _doc || document;
        var container;
        var xpath;
        if (!ignoreClass && typeof doc.evaluate != "undefined") {
          xpath = this.stepsToXpath(steps);
          container = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
        } else if (ignoreClass) {
          container = this.walkToNode(steps, doc, ignoreClass);
        } else {
          container = this.walkToNode(steps, doc);
        }
        return container;
      }
      fixMiss(steps, offset, _doc, ignoreClass) {
        var container = this.findNode(steps.slice(0, -1), _doc, ignoreClass);
        var children = container.childNodes;
        var map = this.normalizedMap(children, TEXT_NODE, ignoreClass);
        var child;
        var len;
        var lastStepIndex = steps[steps.length - 1].index;
        for (let childIndex in map) {
          if (!map.hasOwnProperty(childIndex))
            return;
          if (map[childIndex] === lastStepIndex) {
            child = children[childIndex];
            len = child.textContent.length;
            if (offset > len) {
              offset = offset - len;
            } else {
              if (child.nodeType === ELEMENT_NODE) {
                container = child.childNodes[0];
              } else {
                container = child;
              }
              break;
            }
          }
        }
        return {
          container,
          offset
        };
      }
      toRange(_doc, ignoreClass) {
        var doc = _doc || document;
        var range;
        var start, end, startContainer, endContainer;
        var cfi = this;
        var startSteps, endSteps;
        var needsIgnoring = ignoreClass ? doc.querySelector("." + ignoreClass) != null : false;
        var missed;
        if (typeof doc.createRange !== "undefined") {
          range = doc.createRange();
        } else {
          range = new _core.RangeObject();
        }
        if (cfi.range) {
          start = cfi.start;
          startSteps = cfi.path.steps.concat(start.steps);
          startContainer = this.findNode(startSteps, doc, needsIgnoring ? ignoreClass : null);
          end = cfi.end;
          endSteps = cfi.path.steps.concat(end.steps);
          endContainer = this.findNode(endSteps, doc, needsIgnoring ? ignoreClass : null);
        } else {
          start = cfi.path;
          startSteps = cfi.path.steps;
          startContainer = this.findNode(cfi.path.steps, doc, needsIgnoring ? ignoreClass : null);
        }
        if (startContainer) {
          try {
            if (start.terminal.offset != null) {
              range.setStart(startContainer, start.terminal.offset);
            } else {
              range.setStart(startContainer, 0);
            }
          } catch (e3) {
            missed = this.fixMiss(startSteps, start.terminal.offset, doc, needsIgnoring ? ignoreClass : null);
            range.setStart(missed.container, missed.offset);
          }
        } else {
          console.log("No startContainer found for", this.toString());
          return null;
        }
        if (endContainer) {
          try {
            if (end.terminal.offset != null) {
              range.setEnd(endContainer, end.terminal.offset);
            } else {
              range.setEnd(endContainer, 0);
            }
          } catch (e3) {
            missed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc, needsIgnoring ? ignoreClass : null);
            range.setEnd(missed.container, missed.offset);
          }
        }
        return range;
      }
      isCfiString(str) {
        if (typeof str === "string" && str.indexOf("epubcfi(") === 0 && str[str.length - 1] === ")") {
          return true;
        }
        return false;
      }
      generateChapterComponent(_spineNodeIndex, _pos, id) {
        var pos = parseInt(_pos), spineNodeIndex = (_spineNodeIndex + 1) * 2, cfi = "/" + spineNodeIndex + "/";
        cfi += (pos + 1) * 2;
        if (id) {
          cfi += "[" + id + "]";
        }
        return cfi;
      }
      collapse(toStart) {
        if (!this.range) {
          return;
        }
        this.range = false;
        if (toStart) {
          this.path.steps = this.path.steps.concat(this.start.steps);
          this.path.terminal = this.start.terminal;
        } else {
          this.path.steps = this.path.steps.concat(this.end.steps);
          this.path.terminal = this.end.terminal;
        }
      }
    };
    var _default = EpubCFI;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/hook.js
var require_hook = __commonJS({
  "node_modules/epubjs/lib/utils/hook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Hook = class {
      constructor(context) {
        this.context = context || this;
        this.hooks = [];
      }
      register() {
        for (var i3 = 0; i3 < arguments.length; ++i3) {
          if (typeof arguments[i3] === "function") {
            this.hooks.push(arguments[i3]);
          } else {
            for (var j4 = 0; j4 < arguments[i3].length; ++j4) {
              this.hooks.push(arguments[i3][j4]);
            }
          }
        }
      }
      deregister(func) {
        let hook;
        for (let i3 = 0; i3 < this.hooks.length; i3++) {
          hook = this.hooks[i3];
          if (hook === func) {
            this.hooks.splice(i3, 1);
            break;
          }
        }
      }
      trigger() {
        var args = arguments;
        var context = this.context;
        var promises = [];
        this.hooks.forEach(function(task) {
          try {
            var executing = task.apply(context, args);
          } catch (err) {
            console.log(err);
          }
          if (executing && typeof executing["then"] === "function") {
            promises.push(executing);
          }
        });
        return Promise.all(promises);
      }
      list() {
        return this.hooks;
      }
      clear() {
        return this.hooks = [];
      }
    };
    var _default = Hook;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/replacements.js
var require_replacements = __commonJS({
  "node_modules/epubjs/lib/utils/replacements.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.replaceBase = replaceBase;
    exports.replaceCanonical = replaceCanonical;
    exports.replaceLinks = replaceLinks;
    exports.replaceMeta = replaceMeta;
    exports.substitute = substitute;
    var _core = require_core();
    var _url = _interopRequireDefault(require_url());
    var _path = _interopRequireDefault(require_path2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function replaceBase(doc, section) {
      var base;
      var head;
      var url = section.url;
      var absolute = url.indexOf("://") > -1;
      if (!doc) {
        return;
      }
      head = (0, _core.qs)(doc, "head");
      base = (0, _core.qs)(head, "base");
      if (!base) {
        base = doc.createElement("base");
        head.insertBefore(base, head.firstChild);
      }
      if (!absolute && window && window.location) {
        url = window.location.origin + url;
      }
      base.setAttribute("href", url);
    }
    function replaceCanonical(doc, section) {
      var head;
      var link;
      var url = section.canonical;
      if (!doc) {
        return;
      }
      head = (0, _core.qs)(doc, "head");
      link = (0, _core.qs)(head, "link[rel='canonical']");
      if (link) {
        link.setAttribute("href", url);
      } else {
        link = doc.createElement("link");
        link.setAttribute("rel", "canonical");
        link.setAttribute("href", url);
        head.appendChild(link);
      }
    }
    function replaceMeta(doc, section) {
      var head;
      var meta;
      var id = section.idref;
      if (!doc) {
        return;
      }
      head = (0, _core.qs)(doc, "head");
      meta = (0, _core.qs)(head, "link[property='dc.identifier']");
      if (meta) {
        meta.setAttribute("content", id);
      } else {
        meta = doc.createElement("meta");
        meta.setAttribute("name", "dc.identifier");
        meta.setAttribute("content", id);
        head.appendChild(meta);
      }
    }
    function replaceLinks(contents, fn2) {
      var links = contents.querySelectorAll("a[href]");
      if (!links.length) {
        return;
      }
      var base = (0, _core.qs)(contents.ownerDocument, "base");
      var location = base ? base.getAttribute("href") : void 0;
      var replaceLink = function(link) {
        var href = link.getAttribute("href");
        if (href.indexOf("mailto:") === 0) {
          return;
        }
        var absolute = href.indexOf("://") > -1;
        if (absolute) {
          link.setAttribute("target", "_blank");
        } else {
          var linkUrl;
          try {
            linkUrl = new _url.default(href, location);
          } catch (error) {
          }
          link.onclick = function() {
            if (linkUrl && linkUrl.hash) {
              fn2(linkUrl.Path.path + linkUrl.hash);
            } else if (linkUrl) {
              fn2(linkUrl.Path.path);
            } else {
              fn2(href);
            }
            return false;
          };
        }
      }.bind(this);
      for (var i3 = 0; i3 < links.length; i3++) {
        replaceLink(links[i3]);
      }
    }
    function substitute(content, urls, replacements) {
      urls.forEach(function(url, i3) {
        if (url && replacements[i3]) {
          url = url.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
          content = content.replace(new RegExp(url, "g"), replacements[i3]);
        }
      });
      return content;
    }
  }
});

// node_modules/epubjs/lib/utils/request.js
var require_request = __commonJS({
  "node_modules/epubjs/lib/utils/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _path = _interopRequireDefault(require_path2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function request(url, type, withCredentials, headers) {
      var supportsURL = typeof window != "undefined" ? window.URL : false;
      var BLOB_RESPONSE = supportsURL ? "blob" : "arraybuffer";
      var deferred = new _core.defer();
      var xhr = new XMLHttpRequest();
      var xhrPrototype = XMLHttpRequest.prototype;
      var header;
      if (!("overrideMimeType" in xhrPrototype)) {
        Object.defineProperty(xhrPrototype, "overrideMimeType", {
          value: function xmlHttpRequestOverrideMimeType() {
          }
        });
      }
      if (withCredentials) {
        xhr.withCredentials = true;
      }
      xhr.onreadystatechange = handler;
      xhr.onerror = err;
      xhr.open("GET", url, true);
      for (header in headers) {
        xhr.setRequestHeader(header, headers[header]);
      }
      if (type == "json") {
        xhr.setRequestHeader("Accept", "application/json");
      }
      if (!type) {
        type = new _path.default(url).extension;
      }
      if (type == "blob") {
        xhr.responseType = BLOB_RESPONSE;
      }
      if ((0, _core.isXml)(type)) {
        xhr.overrideMimeType("text/xml");
      }
      if (type == "xhtml") {
      }
      if (type == "html" || type == "htm") {
      }
      if (type == "binary") {
        xhr.responseType = "arraybuffer";
      }
      xhr.send();
      function err(e3) {
        deferred.reject(e3);
      }
      function handler() {
        if (this.readyState === XMLHttpRequest.DONE) {
          var responseXML = false;
          if (this.responseType === "" || this.responseType === "document") {
            responseXML = this.responseXML;
          }
          if (this.status === 200 || this.status === 0 || responseXML) {
            var r3;
            if (!this.response && !responseXML) {
              deferred.reject({
                status: this.status,
                message: "Empty Response",
                stack: new Error().stack
              });
              return deferred.promise;
            }
            if (this.status === 403) {
              deferred.reject({
                status: this.status,
                response: this.response,
                message: "Forbidden",
                stack: new Error().stack
              });
              return deferred.promise;
            }
            if (responseXML) {
              r3 = this.responseXML;
            } else if ((0, _core.isXml)(type)) {
              r3 = (0, _core.parse)(this.response, "text/xml");
            } else if (type == "xhtml") {
              r3 = (0, _core.parse)(this.response, "application/xhtml+xml");
            } else if (type == "html" || type == "htm") {
              r3 = (0, _core.parse)(this.response, "text/html");
            } else if (type == "json") {
              r3 = JSON.parse(this.response);
            } else if (type == "blob") {
              if (supportsURL) {
                r3 = this.response;
              } else {
                r3 = new Blob([this.response]);
              }
            } else {
              r3 = this.response;
            }
            deferred.resolve(r3);
          } else {
            deferred.reject({
              status: this.status,
              message: this.response,
              stack: new Error().stack
            });
          }
        }
      }
      return deferred.promise;
    }
    var _default = request;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/section.js
var require_section = __commonJS({
  "node_modules/epubjs/lib/section.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _hook = _interopRequireDefault(require_hook());
    var _replacements = require_replacements();
    var _request2 = _interopRequireDefault(require_request());
    var _xmldom = require_lib();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Section = class {
      constructor(item, hooks) {
        this.idref = item.idref;
        this.linear = item.linear === "yes";
        this.properties = item.properties;
        this.index = item.index;
        this.href = item.href;
        this.url = item.url;
        this.canonical = item.canonical;
        this.next = item.next;
        this.prev = item.prev;
        this.cfiBase = item.cfiBase;
        if (hooks) {
          this.hooks = hooks;
        } else {
          this.hooks = {};
          this.hooks.serialize = new _hook.default(this);
          this.hooks.content = new _hook.default(this);
        }
        this.document = void 0;
        this.contents = void 0;
        this.output = void 0;
      }
      load(_request) {
        var request = _request || this.request || _request2.default;
        var loading = new _core.defer();
        var loaded = loading.promise;
        if (this.contents) {
          loading.resolve(this.contents);
        } else {
          request(this.url).then(function(xml) {
            this.document = xml;
            this.contents = xml.documentElement;
            return this.hooks.content.trigger(this.document, this);
          }.bind(this)).then(function() {
            loading.resolve(this.contents);
          }.bind(this)).catch(function(error) {
            loading.reject(error);
          });
        }
        return loaded;
      }
      base() {
        return (0, _replacements.replaceBase)(this.document, this);
      }
      render(_request) {
        var rendering = new _core.defer();
        var rendered = rendering.promise;
        this.output;
        this.load(_request).then(function(contents) {
          var userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
          var isIE = userAgent.indexOf("Trident") >= 0;
          var Serializer;
          if (typeof XMLSerializer === "undefined" || isIE) {
            Serializer = _xmldom.DOMParser;
          } else {
            Serializer = XMLSerializer;
          }
          var serializer = new Serializer();
          this.output = serializer.serializeToString(contents);
          return this.output;
        }.bind(this)).then(function() {
          return this.hooks.serialize.trigger(this.output, this);
        }.bind(this)).then(function() {
          rendering.resolve(this.output);
        }.bind(this)).catch(function(error) {
          rendering.reject(error);
        });
        return rendered;
      }
      find(_query) {
        var section = this;
        var matches = [];
        var query = _query.toLowerCase();
        var find = function(node) {
          var text = node.textContent.toLowerCase();
          var range = section.document.createRange();
          var cfi;
          var pos;
          var last = -1;
          var excerpt;
          var limit = 150;
          while (pos != -1) {
            pos = text.indexOf(query, last + 1);
            if (pos != -1) {
              range = section.document.createRange();
              range.setStart(node, pos);
              range.setEnd(node, pos + query.length);
              cfi = section.cfiFromRange(range);
              if (node.textContent.length < limit) {
                excerpt = node.textContent;
              } else {
                excerpt = node.textContent.substring(pos - limit / 2, pos + limit / 2);
                excerpt = "..." + excerpt + "...";
              }
              matches.push({
                cfi,
                excerpt
              });
            }
            last = pos;
          }
        };
        (0, _core.sprint)(section.document, function(node) {
          find(node);
        });
        return matches;
      }
      search(_query, maxSeqEle = 5) {
        if (typeof document.createTreeWalker == "undefined") {
          return this.find(_query);
        }
        let matches = [];
        const excerptLimit = 150;
        const section = this;
        const query = _query.toLowerCase();
        const search = function(nodeList2) {
          const textWithCase = nodeList2.reduce((acc, current) => {
            return acc + current.textContent;
          }, "");
          const text = textWithCase.toLowerCase();
          const pos = text.indexOf(query);
          if (pos != -1) {
            const startNodeIndex = 0, endPos = pos + query.length;
            let endNodeIndex = 0, l3 = 0;
            if (pos < nodeList2[startNodeIndex].length) {
              let cfi;
              while (endNodeIndex < nodeList2.length - 1) {
                l3 += nodeList2[endNodeIndex].length;
                if (endPos <= l3) {
                  break;
                }
                endNodeIndex += 1;
              }
              let startNode = nodeList2[startNodeIndex], endNode = nodeList2[endNodeIndex];
              let range = section.document.createRange();
              range.setStart(startNode, pos);
              let beforeEndLengthCount = nodeList2.slice(0, endNodeIndex).reduce((acc, current) => {
                return acc + current.textContent.length;
              }, 0);
              range.setEnd(endNode, beforeEndLengthCount > endPos ? endPos : endPos - beforeEndLengthCount);
              cfi = section.cfiFromRange(range);
              let excerpt = nodeList2.slice(0, endNodeIndex + 1).reduce((acc, current) => {
                return acc + current.textContent;
              }, "");
              if (excerpt.length > excerptLimit) {
                excerpt = excerpt.substring(pos - excerptLimit / 2, pos + excerptLimit / 2);
                excerpt = "..." + excerpt + "...";
              }
              matches.push({
                cfi,
                excerpt
              });
            }
          }
        };
        const treeWalker = document.createTreeWalker(section.document, NodeFilter.SHOW_TEXT, null, false);
        let node, nodeList = [];
        while (node = treeWalker.nextNode()) {
          nodeList.push(node);
          if (nodeList.length == maxSeqEle) {
            search(nodeList.slice(0, maxSeqEle));
            nodeList = nodeList.slice(1, maxSeqEle);
          }
        }
        if (nodeList.length > 0) {
          search(nodeList);
        }
        return matches;
      }
      reconcileLayoutSettings(globalLayout) {
        var settings = {
          layout: globalLayout.layout,
          spread: globalLayout.spread,
          orientation: globalLayout.orientation
        };
        this.properties.forEach(function(prop) {
          var rendition = prop.replace("rendition:", "");
          var split = rendition.indexOf("-");
          var property, value;
          if (split != -1) {
            property = rendition.slice(0, split);
            value = rendition.slice(split + 1);
            settings[property] = value;
          }
        });
        return settings;
      }
      cfiFromRange(_range) {
        return new _epubcfi.default(_range, this.cfiBase).toString();
      }
      cfiFromElement(el) {
        return new _epubcfi.default(el, this.cfiBase).toString();
      }
      unload() {
        this.document = void 0;
        this.contents = void 0;
        this.output = void 0;
      }
      destroy() {
        this.unload();
        this.hooks.serialize.clear();
        this.hooks.content.clear();
        this.hooks = void 0;
        this.idref = void 0;
        this.linear = void 0;
        this.properties = void 0;
        this.index = void 0;
        this.href = void 0;
        this.url = void 0;
        this.next = void 0;
        this.prev = void 0;
        this.cfiBase = void 0;
      }
    };
    var _default = Section;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/spine.js
var require_spine = __commonJS({
  "node_modules/epubjs/lib/spine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _hook = _interopRequireDefault(require_hook());
    var _section = _interopRequireDefault(require_section());
    var _replacements = require_replacements();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Spine = class {
      constructor() {
        this.spineItems = [];
        this.spineByHref = {};
        this.spineById = {};
        this.hooks = {};
        this.hooks.serialize = new _hook.default();
        this.hooks.content = new _hook.default();
        this.hooks.content.register(_replacements.replaceBase);
        this.hooks.content.register(_replacements.replaceCanonical);
        this.hooks.content.register(_replacements.replaceMeta);
        this.epubcfi = new _epubcfi.default();
        this.loaded = false;
        this.items = void 0;
        this.manifest = void 0;
        this.spineNodeIndex = void 0;
        this.baseUrl = void 0;
        this.length = void 0;
      }
      unpack(_package, resolver, canonical) {
        this.items = _package.spine;
        this.manifest = _package.manifest;
        this.spineNodeIndex = _package.spineNodeIndex;
        this.baseUrl = _package.baseUrl || _package.basePath || "";
        this.length = this.items.length;
        this.items.forEach((item, index) => {
          var manifestItem = this.manifest[item.idref];
          var spineItem;
          item.index = index;
          item.cfiBase = this.epubcfi.generateChapterComponent(this.spineNodeIndex, item.index, item.id);
          if (item.href) {
            item.url = resolver(item.href, true);
            item.canonical = canonical(item.href);
          }
          if (manifestItem) {
            item.href = manifestItem.href;
            item.url = resolver(item.href, true);
            item.canonical = canonical(item.href);
            if (manifestItem.properties.length) {
              item.properties.push.apply(item.properties, manifestItem.properties);
            }
          }
          if (item.linear === "yes") {
            item.prev = function() {
              let prevIndex = item.index;
              while (prevIndex > 0) {
                let prev = this.get(prevIndex - 1);
                if (prev && prev.linear) {
                  return prev;
                }
                prevIndex -= 1;
              }
              return;
            }.bind(this);
            item.next = function() {
              let nextIndex = item.index;
              while (nextIndex < this.spineItems.length - 1) {
                let next = this.get(nextIndex + 1);
                if (next && next.linear) {
                  return next;
                }
                nextIndex += 1;
              }
              return;
            }.bind(this);
          } else {
            item.prev = function() {
              return;
            };
            item.next = function() {
              return;
            };
          }
          spineItem = new _section.default(item, this.hooks);
          this.append(spineItem);
        });
        this.loaded = true;
      }
      get(target) {
        var index = 0;
        if (typeof target === "undefined") {
          while (index < this.spineItems.length) {
            let next = this.spineItems[index];
            if (next && next.linear) {
              break;
            }
            index += 1;
          }
        } else if (this.epubcfi.isCfiString(target)) {
          let cfi = new _epubcfi.default(target);
          index = cfi.spinePos;
        } else if (typeof target === "number" || isNaN(target) === false) {
          index = target;
        } else if (typeof target === "string" && target.indexOf("#") === 0) {
          index = this.spineById[target.substring(1)];
        } else if (typeof target === "string") {
          target = target.split("#")[0];
          index = this.spineByHref[target] || this.spineByHref[encodeURI(target)];
        }
        return this.spineItems[index] || null;
      }
      append(section) {
        var index = this.spineItems.length;
        section.index = index;
        this.spineItems.push(section);
        this.spineByHref[decodeURI(section.href)] = index;
        this.spineByHref[encodeURI(section.href)] = index;
        this.spineByHref[section.href] = index;
        this.spineById[section.idref] = index;
        return index;
      }
      prepend(section) {
        this.spineByHref[section.href] = 0;
        this.spineById[section.idref] = 0;
        this.spineItems.forEach(function(item, index) {
          item.index = index;
        });
        return 0;
      }
      remove(section) {
        var index = this.spineItems.indexOf(section);
        if (index > -1) {
          delete this.spineByHref[section.href];
          delete this.spineById[section.idref];
          return this.spineItems.splice(index, 1);
        }
      }
      each() {
        return this.spineItems.forEach.apply(this.spineItems, arguments);
      }
      first() {
        let index = 0;
        do {
          let next = this.get(index);
          if (next && next.linear) {
            return next;
          }
          index += 1;
        } while (index < this.spineItems.length);
      }
      last() {
        let index = this.spineItems.length - 1;
        do {
          let prev = this.get(index);
          if (prev && prev.linear) {
            return prev;
          }
          index -= 1;
        } while (index >= 0);
      }
      destroy() {
        this.each((section) => section.destroy());
        this.spineItems = void 0;
        this.spineByHref = void 0;
        this.spineById = void 0;
        this.hooks.serialize.clear();
        this.hooks.content.clear();
        this.hooks = void 0;
        this.epubcfi = void 0;
        this.loaded = false;
        this.items = void 0;
        this.manifest = void 0;
        this.spineNodeIndex = void 0;
        this.baseUrl = void 0;
        this.length = void 0;
      }
    };
    var _default = Spine;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/queue.js
var require_queue = __commonJS({
  "node_modules/epubjs/lib/utils/queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.Task = void 0;
    var _core = require_core();
    var Queue = class {
      constructor(context) {
        this._q = [];
        this.context = context;
        this.tick = _core.requestAnimationFrame;
        this.running = false;
        this.paused = false;
      }
      enqueue() {
        var deferred, promise;
        var queued;
        var task = [].shift.call(arguments);
        var args = arguments;
        if (!task) {
          throw new Error("No Task Provided");
        }
        if (typeof task === "function") {
          deferred = new _core.defer();
          promise = deferred.promise;
          queued = {
            "task": task,
            "args": args,
            "deferred": deferred,
            "promise": promise
          };
        } else {
          queued = {
            "promise": task
          };
        }
        this._q.push(queued);
        if (this.paused == false && !this.running) {
          this.run();
        }
        return queued.promise;
      }
      dequeue() {
        var inwait, task, result;
        if (this._q.length && !this.paused) {
          inwait = this._q.shift();
          task = inwait.task;
          if (task) {
            result = task.apply(this.context, inwait.args);
            if (result && typeof result["then"] === "function") {
              return result.then(function() {
                inwait.deferred.resolve.apply(this.context, arguments);
              }.bind(this), function() {
                inwait.deferred.reject.apply(this.context, arguments);
              }.bind(this));
            } else {
              inwait.deferred.resolve.apply(this.context, result);
              return inwait.promise;
            }
          } else if (inwait.promise) {
            return inwait.promise;
          }
        } else {
          inwait = new _core.defer();
          inwait.deferred.resolve();
          return inwait.promise;
        }
      }
      dump() {
        while (this._q.length) {
          this.dequeue();
        }
      }
      run() {
        if (!this.running) {
          this.running = true;
          this.defered = new _core.defer();
        }
        this.tick.call(window, () => {
          if (this._q.length) {
            this.dequeue().then(function() {
              this.run();
            }.bind(this));
          } else {
            this.defered.resolve();
            this.running = void 0;
          }
        });
        if (this.paused == true) {
          this.paused = false;
        }
        return this.defered.promise;
      }
      flush() {
        if (this.running) {
          return this.running;
        }
        if (this._q.length) {
          this.running = this.dequeue().then(function() {
            this.running = void 0;
            return this.flush();
          }.bind(this));
          return this.running;
        }
      }
      clear() {
        this._q = [];
      }
      length() {
        return this._q.length;
      }
      pause() {
        this.paused = true;
      }
      stop() {
        this._q = [];
        this.running = false;
        this.paused = true;
      }
    };
    var Task = class {
      constructor(task, args, context) {
        return function() {
          var toApply = arguments || [];
          return new Promise((resolve, reject) => {
            var callback = function(value, err) {
              if (!value && err) {
                reject(err);
              } else {
                resolve(value);
              }
            };
            toApply.push(callback);
            task.apply(context || this, toApply);
          });
        };
      }
    };
    exports.Task = Task;
    var _default = Queue;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/constants.js
var require_constants = __commonJS({
  "node_modules/epubjs/lib/utils/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EVENTS = exports.EPUBJS_VERSION = exports.DOM_EVENTS = void 0;
    var EPUBJS_VERSION = "0.3";
    exports.EPUBJS_VERSION = EPUBJS_VERSION;
    var DOM_EVENTS = ["keydown", "keyup", "keypressed", "mouseup", "mousedown", "mousemove", "click", "touchend", "touchstart", "touchmove"];
    exports.DOM_EVENTS = DOM_EVENTS;
    var EVENTS = {
      BOOK: {
        OPEN_FAILED: "openFailed"
      },
      CONTENTS: {
        EXPAND: "expand",
        RESIZE: "resize",
        SELECTED: "selected",
        SELECTED_RANGE: "selectedRange",
        LINK_CLICKED: "linkClicked"
      },
      LOCATIONS: {
        CHANGED: "changed"
      },
      MANAGERS: {
        RESIZE: "resize",
        RESIZED: "resized",
        ORIENTATION_CHANGE: "orientationchange",
        ADDED: "added",
        SCROLL: "scroll",
        SCROLLED: "scrolled",
        REMOVED: "removed"
      },
      VIEWS: {
        AXIS: "axis",
        WRITING_MODE: "writingMode",
        LOAD_ERROR: "loaderror",
        RENDERED: "rendered",
        RESIZED: "resized",
        DISPLAYED: "displayed",
        SHOWN: "shown",
        HIDDEN: "hidden",
        MARK_CLICKED: "markClicked"
      },
      RENDITION: {
        STARTED: "started",
        ATTACHED: "attached",
        DISPLAYED: "displayed",
        DISPLAY_ERROR: "displayerror",
        RENDERED: "rendered",
        REMOVED: "removed",
        RESIZED: "resized",
        ORIENTATION_CHANGE: "orientationchange",
        LOCATION_CHANGED: "locationChanged",
        RELOCATED: "relocated",
        MARK_CLICKED: "markClicked",
        SELECTED: "selected",
        LAYOUT: "layout"
      },
      LAYOUT: {
        UPDATED: "updated"
      },
      ANNOTATION: {
        ATTACH: "attach",
        DETACH: "detach"
      }
    };
    exports.EVENTS = EVENTS;
  }
});

// node_modules/epubjs/lib/locations.js
var require_locations = __commonJS({
  "node_modules/epubjs/lib/locations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _queue = _interopRequireDefault(require_queue());
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _constants = require_constants();
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Locations = class {
      constructor(spine, request, pause) {
        this.spine = spine;
        this.request = request;
        this.pause = pause || 100;
        this.q = new _queue.default(this);
        this.epubcfi = new _epubcfi.default();
        this._locations = [];
        this._locationsWords = [];
        this.total = 0;
        this.break = 150;
        this._current = 0;
        this._wordCounter = 0;
        this.currentLocation = "";
        this._currentCfi = "";
        this.processingTimeout = void 0;
      }
      generate(chars) {
        if (chars) {
          this.break = chars;
        }
        this.q.pause();
        this.spine.each(function(section) {
          if (section.linear) {
            this.q.enqueue(this.process.bind(this), section);
          }
        }.bind(this));
        return this.q.run().then(function() {
          this.total = this._locations.length - 1;
          if (this._currentCfi) {
            this.currentLocation = this._currentCfi;
          }
          return this._locations;
        }.bind(this));
      }
      createRange() {
        return {
          startContainer: void 0,
          startOffset: void 0,
          endContainer: void 0,
          endOffset: void 0
        };
      }
      process(section) {
        return section.load(this.request).then(function(contents) {
          var completed = new _core.defer();
          var locations = this.parse(contents, section.cfiBase);
          this._locations = this._locations.concat(locations);
          section.unload();
          this.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);
          return completed.promise;
        }.bind(this));
      }
      parse(contents, cfiBase, chars) {
        var locations = [];
        var range;
        var doc = contents.ownerDocument;
        var body = (0, _core.qs)(doc, "body");
        var counter = 0;
        var prev;
        var _break = chars || this.break;
        var parser = function(node) {
          var len = node.length;
          var dist;
          var pos = 0;
          if (node.textContent.trim().length === 0) {
            return false;
          }
          if (counter == 0) {
            range = this.createRange();
            range.startContainer = node;
            range.startOffset = 0;
          }
          dist = _break - counter;
          if (dist > len) {
            counter += len;
            pos = len;
          }
          while (pos < len) {
            dist = _break - counter;
            if (counter === 0) {
              pos += 1;
              range = this.createRange();
              range.startContainer = node;
              range.startOffset = pos;
            }
            if (pos + dist >= len) {
              counter += len - pos;
              pos = len;
            } else {
              pos += dist;
              range.endContainer = node;
              range.endOffset = pos;
              let cfi = new _epubcfi.default(range, cfiBase).toString();
              locations.push(cfi);
              counter = 0;
            }
          }
          prev = node;
        };
        (0, _core.sprint)(body, parser.bind(this));
        if (range && range.startContainer && prev) {
          range.endContainer = prev;
          range.endOffset = prev.length;
          let cfi = new _epubcfi.default(range, cfiBase).toString();
          locations.push(cfi);
          counter = 0;
        }
        return locations;
      }
      generateFromWords(startCfi, wordCount, count) {
        var start = startCfi ? new _epubcfi.default(startCfi) : void 0;
        this.q.pause();
        this._locationsWords = [];
        this._wordCounter = 0;
        this.spine.each(function(section) {
          if (section.linear) {
            if (start) {
              if (section.index >= start.spinePos) {
                this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);
              }
            } else {
              this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);
            }
          }
        }.bind(this));
        return this.q.run().then(function() {
          if (this._currentCfi) {
            this.currentLocation = this._currentCfi;
          }
          return this._locationsWords;
        }.bind(this));
      }
      processWords(section, wordCount, startCfi, count) {
        if (count && this._locationsWords.length >= count) {
          return Promise.resolve();
        }
        return section.load(this.request).then(function(contents) {
          var completed = new _core.defer();
          var locations = this.parseWords(contents, section, wordCount, startCfi);
          var remainingCount = count - this._locationsWords.length;
          this._locationsWords = this._locationsWords.concat(locations.length >= count ? locations.slice(0, remainingCount) : locations);
          section.unload();
          this.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);
          return completed.promise;
        }.bind(this));
      }
      countWords(s3) {
        s3 = s3.replace(/(^\s*)|(\s*$)/gi, "");
        s3 = s3.replace(/[ ]{2,}/gi, " ");
        s3 = s3.replace(/\n /, "\n");
        return s3.split(" ").length;
      }
      parseWords(contents, section, wordCount, startCfi) {
        var cfiBase = section.cfiBase;
        var locations = [];
        var doc = contents.ownerDocument;
        var body = (0, _core.qs)(doc, "body");
        var prev;
        var _break = wordCount;
        var foundStartNode = startCfi ? startCfi.spinePos !== section.index : true;
        var startNode;
        if (startCfi && section.index === startCfi.spinePos) {
          startNode = startCfi.findNode(startCfi.range ? startCfi.path.steps.concat(startCfi.start.steps) : startCfi.path.steps, contents.ownerDocument);
        }
        var parser = function(node) {
          if (!foundStartNode) {
            if (node === startNode) {
              foundStartNode = true;
            } else {
              return false;
            }
          }
          if (node.textContent.length < 10) {
            if (node.textContent.trim().length === 0) {
              return false;
            }
          }
          var len = this.countWords(node.textContent);
          var dist;
          var pos = 0;
          if (len === 0) {
            return false;
          }
          dist = _break - this._wordCounter;
          if (dist > len) {
            this._wordCounter += len;
            pos = len;
          }
          while (pos < len) {
            dist = _break - this._wordCounter;
            if (pos + dist >= len) {
              this._wordCounter += len - pos;
              pos = len;
            } else {
              pos += dist;
              let cfi = new _epubcfi.default(node, cfiBase);
              locations.push({
                cfi: cfi.toString(),
                wordCount: this._wordCounter
              });
              this._wordCounter = 0;
            }
          }
          prev = node;
        };
        (0, _core.sprint)(body, parser.bind(this));
        return locations;
      }
      locationFromCfi(cfi) {
        let loc;
        if (_epubcfi.default.prototype.isCfiString(cfi)) {
          cfi = new _epubcfi.default(cfi);
        }
        if (this._locations.length === 0) {
          return -1;
        }
        loc = (0, _core.locationOf)(cfi, this._locations, this.epubcfi.compare);
        if (loc > this.total) {
          return this.total;
        }
        return loc;
      }
      percentageFromCfi(cfi) {
        if (this._locations.length === 0) {
          return null;
        }
        var loc = this.locationFromCfi(cfi);
        return this.percentageFromLocation(loc);
      }
      percentageFromLocation(loc) {
        if (!loc || !this.total) {
          return 0;
        }
        return loc / this.total;
      }
      cfiFromLocation(loc) {
        var cfi = -1;
        if (typeof loc != "number") {
          loc = parseInt(loc);
        }
        if (loc >= 0 && loc < this._locations.length) {
          cfi = this._locations[loc];
        }
        return cfi;
      }
      cfiFromPercentage(percentage) {
        let loc;
        if (percentage > 1) {
          console.warn("Normalize cfiFromPercentage value to between 0 - 1");
        }
        if (percentage >= 1) {
          let cfi = new _epubcfi.default(this._locations[this.total]);
          cfi.collapse();
          return cfi.toString();
        }
        loc = Math.ceil(this.total * percentage);
        return this.cfiFromLocation(loc);
      }
      load(locations) {
        if (typeof locations === "string") {
          this._locations = JSON.parse(locations);
        } else {
          this._locations = locations;
        }
        this.total = this._locations.length - 1;
        return this._locations;
      }
      save() {
        return JSON.stringify(this._locations);
      }
      getCurrent() {
        return this._current;
      }
      setCurrent(curr) {
        var loc;
        if (typeof curr == "string") {
          this._currentCfi = curr;
        } else if (typeof curr == "number") {
          this._current = curr;
        } else {
          return;
        }
        if (this._locations.length === 0) {
          return;
        }
        if (typeof curr == "string") {
          loc = this.locationFromCfi(curr);
          this._current = loc;
        } else {
          loc = curr;
        }
        this.emit(_constants.EVENTS.LOCATIONS.CHANGED, {
          percentage: this.percentageFromLocation(loc)
        });
      }
      get currentLocation() {
        return this._current;
      }
      set currentLocation(curr) {
        this.setCurrent(curr);
      }
      length() {
        return this._locations.length;
      }
      destroy() {
        this.spine = void 0;
        this.request = void 0;
        this.pause = void 0;
        this.q.stop();
        this.q = void 0;
        this.epubcfi = void 0;
        this._locations = void 0;
        this.total = void 0;
        this.break = void 0;
        this._current = void 0;
        this.currentLocation = void 0;
        this._currentCfi = void 0;
        clearTimeout(this.processingTimeout);
      }
    };
    (0, _eventEmitter.default)(Locations.prototype);
    var _default = Locations;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/container.js
var require_container = __commonJS({
  "node_modules/epubjs/lib/container.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _pathWebpack = _interopRequireDefault(require_path());
    var _core = require_core();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Container = class {
      constructor(containerDocument) {
        this.packagePath = "";
        this.directory = "";
        this.encoding = "";
        if (containerDocument) {
          this.parse(containerDocument);
        }
      }
      parse(containerDocument) {
        var rootfile;
        if (!containerDocument) {
          throw new Error("Container File Not Found");
        }
        rootfile = (0, _core.qs)(containerDocument, "rootfile");
        if (!rootfile) {
          throw new Error("No RootFile Found");
        }
        this.packagePath = rootfile.getAttribute("full-path");
        this.directory = _pathWebpack.default.dirname(this.packagePath);
        this.encoding = containerDocument.xmlEncoding;
      }
      destroy() {
        this.packagePath = void 0;
        this.directory = void 0;
        this.encoding = void 0;
      }
    };
    var _default = Container;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/packaging.js
var require_packaging = __commonJS({
  "node_modules/epubjs/lib/packaging.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var Packaging = class {
      constructor(packageDocument) {
        this.manifest = {};
        this.navPath = "";
        this.ncxPath = "";
        this.coverPath = "";
        this.spineNodeIndex = 0;
        this.spine = [];
        this.metadata = {};
        if (packageDocument) {
          this.parse(packageDocument);
        }
      }
      parse(packageDocument) {
        var metadataNode, manifestNode, spineNode;
        if (!packageDocument) {
          throw new Error("Package File Not Found");
        }
        metadataNode = (0, _core.qs)(packageDocument, "metadata");
        if (!metadataNode) {
          throw new Error("No Metadata Found");
        }
        manifestNode = (0, _core.qs)(packageDocument, "manifest");
        if (!manifestNode) {
          throw new Error("No Manifest Found");
        }
        spineNode = (0, _core.qs)(packageDocument, "spine");
        if (!spineNode) {
          throw new Error("No Spine Found");
        }
        this.manifest = this.parseManifest(manifestNode);
        this.navPath = this.findNavPath(manifestNode);
        this.ncxPath = this.findNcxPath(manifestNode, spineNode);
        this.coverPath = this.findCoverPath(packageDocument);
        this.spineNodeIndex = (0, _core.indexOfElementNode)(spineNode);
        this.spine = this.parseSpine(spineNode, this.manifest);
        this.uniqueIdentifier = this.findUniqueIdentifier(packageDocument);
        this.metadata = this.parseMetadata(metadataNode);
        this.metadata.direction = spineNode.getAttribute("page-progression-direction");
        return {
          "metadata": this.metadata,
          "spine": this.spine,
          "manifest": this.manifest,
          "navPath": this.navPath,
          "ncxPath": this.ncxPath,
          "coverPath": this.coverPath,
          "spineNodeIndex": this.spineNodeIndex
        };
      }
      parseMetadata(xml) {
        var metadata = {};
        metadata.title = this.getElementText(xml, "title");
        metadata.creator = this.getElementText(xml, "creator");
        metadata.description = this.getElementText(xml, "description");
        metadata.pubdate = this.getElementText(xml, "date");
        metadata.publisher = this.getElementText(xml, "publisher");
        metadata.identifier = this.getElementText(xml, "identifier");
        metadata.language = this.getElementText(xml, "language");
        metadata.rights = this.getElementText(xml, "rights");
        metadata.modified_date = this.getPropertyText(xml, "dcterms:modified");
        metadata.layout = this.getPropertyText(xml, "rendition:layout");
        metadata.orientation = this.getPropertyText(xml, "rendition:orientation");
        metadata.flow = this.getPropertyText(xml, "rendition:flow");
        metadata.viewport = this.getPropertyText(xml, "rendition:viewport");
        metadata.media_active_class = this.getPropertyText(xml, "media:active-class");
        metadata.spread = this.getPropertyText(xml, "rendition:spread");
        return metadata;
      }
      parseManifest(manifestXml) {
        var manifest = {};
        var selected = (0, _core.qsa)(manifestXml, "item");
        var items = Array.prototype.slice.call(selected);
        items.forEach(function(item) {
          var id = item.getAttribute("id"), href = item.getAttribute("href") || "", type = item.getAttribute("media-type") || "", overlay = item.getAttribute("media-overlay") || "", properties = item.getAttribute("properties") || "";
          manifest[id] = {
            "href": href,
            "type": type,
            "overlay": overlay,
            "properties": properties.length ? properties.split(" ") : []
          };
        });
        return manifest;
      }
      parseSpine(spineXml, manifest) {
        var spine = [];
        var selected = (0, _core.qsa)(spineXml, "itemref");
        var items = Array.prototype.slice.call(selected);
        items.forEach(function(item, index) {
          var idref = item.getAttribute("idref");
          var props = item.getAttribute("properties") || "";
          var propArray = props.length ? props.split(" ") : [];
          var itemref = {
            "id": item.getAttribute("id"),
            "idref": idref,
            "linear": item.getAttribute("linear") || "yes",
            "properties": propArray,
            "index": index
          };
          spine.push(itemref);
        });
        return spine;
      }
      findUniqueIdentifier(packageXml) {
        var uniqueIdentifierId = packageXml.documentElement.getAttribute("unique-identifier");
        if (!uniqueIdentifierId) {
          return "";
        }
        var identifier = packageXml.getElementById(uniqueIdentifierId);
        if (!identifier) {
          return "";
        }
        if (identifier.localName === "identifier" && identifier.namespaceURI === "http://purl.org/dc/elements/1.1/") {
          return identifier.childNodes.length > 0 ? identifier.childNodes[0].nodeValue.trim() : "";
        }
        return "";
      }
      findNavPath(manifestNode) {
        var node = (0, _core.qsp)(manifestNode, "item", {
          "properties": "nav"
        });
        return node ? node.getAttribute("href") : false;
      }
      findNcxPath(manifestNode, spineNode) {
        var node = (0, _core.qsp)(manifestNode, "item", {
          "media-type": "application/x-dtbncx+xml"
        });
        var tocId;
        if (!node) {
          tocId = spineNode.getAttribute("toc");
          if (tocId) {
            node = manifestNode.querySelector(`#${tocId}`);
          }
        }
        return node ? node.getAttribute("href") : false;
      }
      findCoverPath(packageXml) {
        var pkg = (0, _core.qs)(packageXml, "package");
        var epubVersion = pkg.getAttribute("version");
        var node = (0, _core.qsp)(packageXml, "item", {
          "properties": "cover-image"
        });
        if (node)
          return node.getAttribute("href");
        var metaCover = (0, _core.qsp)(packageXml, "meta", {
          "name": "cover"
        });
        if (metaCover) {
          var coverId = metaCover.getAttribute("content");
          var cover = packageXml.getElementById(coverId);
          return cover ? cover.getAttribute("href") : "";
        } else {
          return false;
        }
      }
      getElementText(xml, tag) {
        var found = xml.getElementsByTagNameNS("http://purl.org/dc/elements/1.1/", tag);
        var el;
        if (!found || found.length === 0)
          return "";
        el = found[0];
        if (el.childNodes.length) {
          return el.childNodes[0].nodeValue;
        }
        return "";
      }
      getPropertyText(xml, property) {
        var el = (0, _core.qsp)(xml, "meta", {
          "property": property
        });
        if (el && el.childNodes.length) {
          return el.childNodes[0].nodeValue;
        }
        return "";
      }
      load(json) {
        this.metadata = json.metadata;
        let spine = json.readingOrder || json.spine;
        this.spine = spine.map((item, index) => {
          item.index = index;
          item.linear = item.linear || "yes";
          return item;
        });
        json.resources.forEach((item, index) => {
          this.manifest[index] = item;
          if (item.rel && item.rel[0] === "cover") {
            this.coverPath = item.href;
          }
        });
        this.spineNodeIndex = 0;
        this.toc = json.toc.map((item, index) => {
          item.label = item.title;
          return item;
        });
        return {
          "metadata": this.metadata,
          "spine": this.spine,
          "manifest": this.manifest,
          "navPath": this.navPath,
          "ncxPath": this.ncxPath,
          "coverPath": this.coverPath,
          "spineNodeIndex": this.spineNodeIndex,
          "toc": this.toc
        };
      }
      destroy() {
        this.manifest = void 0;
        this.navPath = void 0;
        this.ncxPath = void 0;
        this.coverPath = void 0;
        this.spineNodeIndex = void 0;
        this.spine = void 0;
        this.metadata = void 0;
      }
    };
    var _default = Packaging;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/navigation.js
var require_navigation = __commonJS({
  "node_modules/epubjs/lib/navigation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var Navigation = class {
      constructor(xml) {
        this.toc = [];
        this.tocByHref = {};
        this.tocById = {};
        this.landmarks = [];
        this.landmarksByType = {};
        this.length = 0;
        if (xml) {
          this.parse(xml);
        }
      }
      parse(xml) {
        let isXml = xml.nodeType;
        let html;
        let ncx;
        if (isXml) {
          html = (0, _core.qs)(xml, "html");
          ncx = (0, _core.qs)(xml, "ncx");
        }
        if (!isXml) {
          this.toc = this.load(xml);
        } else if (html) {
          this.toc = this.parseNav(xml);
          this.landmarks = this.parseLandmarks(xml);
        } else if (ncx) {
          this.toc = this.parseNcx(xml);
        }
        this.length = 0;
        this.unpack(this.toc);
      }
      unpack(toc) {
        var item;
        for (var i3 = 0; i3 < toc.length; i3++) {
          item = toc[i3];
          if (item.href) {
            this.tocByHref[item.href] = i3;
          }
          if (item.id) {
            this.tocById[item.id] = i3;
          }
          this.length++;
          if (item.subitems.length) {
            this.unpack(item.subitems);
          }
        }
      }
      get(target) {
        var index;
        if (!target) {
          return this.toc;
        }
        if (target.indexOf("#") === 0) {
          index = this.tocById[target.substring(1)];
        } else if (target in this.tocByHref) {
          index = this.tocByHref[target];
        }
        return this.getByIndex(target, index, this.toc);
      }
      getByIndex(target, index, navItems) {
        if (navItems.length === 0) {
          return;
        }
        const item = navItems[index];
        if (item && (target === item.id || target === item.href)) {
          return item;
        } else {
          let result;
          for (let i3 = 0; i3 < navItems.length; ++i3) {
            result = this.getByIndex(target, index, navItems[i3].subitems);
            if (result) {
              break;
            }
          }
          return result;
        }
      }
      landmark(type) {
        var index;
        if (!type) {
          return this.landmarks;
        }
        index = this.landmarksByType[type];
        return this.landmarks[index];
      }
      parseNav(navHtml) {
        var navElement = (0, _core.querySelectorByType)(navHtml, "nav", "toc");
        var list = [];
        if (!navElement)
          return list;
        let navList = (0, _core.filterChildren)(navElement, "ol", true);
        if (!navList)
          return list;
        list = this.parseNavList(navList);
        return list;
      }
      parseNavList(navListHtml, parent2) {
        const result = [];
        if (!navListHtml)
          return result;
        if (!navListHtml.children)
          return result;
        for (let i3 = 0; i3 < navListHtml.children.length; i3++) {
          const item = this.navItem(navListHtml.children[i3], parent2);
          if (item) {
            result.push(item);
          }
        }
        return result;
      }
      navItem(item, parent2) {
        let id = item.getAttribute("id") || void 0;
        let content = (0, _core.filterChildren)(item, "a", true) || (0, _core.filterChildren)(item, "span", true);
        if (!content) {
          return;
        }
        let src = content.getAttribute("href") || "";
        if (!id) {
          id = src;
        }
        let text = content.textContent || "";
        let subitems = [];
        let nested = (0, _core.filterChildren)(item, "ol", true);
        if (nested) {
          subitems = this.parseNavList(nested, id);
        }
        return {
          "id": id,
          "href": src,
          "label": text,
          "subitems": subitems,
          "parent": parent2
        };
      }
      parseLandmarks(navHtml) {
        var navElement = (0, _core.querySelectorByType)(navHtml, "nav", "landmarks");
        var navItems = navElement ? (0, _core.qsa)(navElement, "li") : [];
        var length = navItems.length;
        var i3;
        var list = [];
        var item;
        if (!navItems || length === 0)
          return list;
        for (i3 = 0; i3 < length; ++i3) {
          item = this.landmarkItem(navItems[i3]);
          if (item) {
            list.push(item);
            this.landmarksByType[item.type] = i3;
          }
        }
        return list;
      }
      landmarkItem(item) {
        let content = (0, _core.filterChildren)(item, "a", true);
        if (!content) {
          return;
        }
        let type = content.getAttributeNS("http://www.idpf.org/2007/ops", "type") || void 0;
        let href = content.getAttribute("href") || "";
        let text = content.textContent || "";
        return {
          "href": href,
          "label": text,
          "type": type
        };
      }
      parseNcx(tocXml) {
        var navPoints = (0, _core.qsa)(tocXml, "navPoint");
        var length = navPoints.length;
        var i3;
        var toc = {};
        var list = [];
        var item, parent2;
        if (!navPoints || length === 0)
          return list;
        for (i3 = 0; i3 < length; ++i3) {
          item = this.ncxItem(navPoints[i3]);
          toc[item.id] = item;
          if (!item.parent) {
            list.push(item);
          } else {
            parent2 = toc[item.parent];
            parent2.subitems.push(item);
          }
        }
        return list;
      }
      ncxItem(item) {
        var id = item.getAttribute("id") || false, content = (0, _core.qs)(item, "content"), src = content.getAttribute("src"), navLabel = (0, _core.qs)(item, "navLabel"), text = navLabel.textContent ? navLabel.textContent : "", subitems = [], parentNode = item.parentNode, parent2;
        if (parentNode && (parentNode.nodeName === "navPoint" || parentNode.nodeName.split(":").slice(-1)[0] === "navPoint")) {
          parent2 = parentNode.getAttribute("id");
        }
        return {
          "id": id,
          "href": src,
          "label": text,
          "subitems": subitems,
          "parent": parent2
        };
      }
      load(json) {
        return json.map((item) => {
          item.label = item.title;
          item.subitems = item.children ? this.load(item.children) : [];
          return item;
        });
      }
      forEach(fn2) {
        return this.toc.forEach(fn2);
      }
    };
    var _default = Navigation;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/mime.js
var require_mime = __commonJS({
  "node_modules/epubjs/lib/utils/mime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var table = {
      "application": {
        "ecmascript": ["es", "ecma"],
        "javascript": "js",
        "ogg": "ogx",
        "pdf": "pdf",
        "postscript": ["ps", "ai", "eps", "epsi", "epsf", "eps2", "eps3"],
        "rdf+xml": "rdf",
        "smil": ["smi", "smil"],
        "xhtml+xml": ["xhtml", "xht"],
        "xml": ["xml", "xsl", "xsd", "opf", "ncx"],
        "zip": "zip",
        "x-httpd-eruby": "rhtml",
        "x-latex": "latex",
        "x-maker": ["frm", "maker", "frame", "fm", "fb", "book", "fbdoc"],
        "x-object": "o",
        "x-shockwave-flash": ["swf", "swfl"],
        "x-silverlight": "scr",
        "epub+zip": "epub",
        "font-tdpfr": "pfr",
        "inkml+xml": ["ink", "inkml"],
        "json": "json",
        "jsonml+json": "jsonml",
        "mathml+xml": "mathml",
        "metalink+xml": "metalink",
        "mp4": "mp4s",
        "omdoc+xml": "omdoc",
        "oxps": "oxps",
        "vnd.amazon.ebook": "azw",
        "widget": "wgt",
        "x-dtbook+xml": "dtb",
        "x-dtbresource+xml": "res",
        "x-font-bdf": "bdf",
        "x-font-ghostscript": "gsf",
        "x-font-linux-psf": "psf",
        "x-font-otf": "otf",
        "x-font-pcf": "pcf",
        "x-font-snf": "snf",
        "x-font-ttf": ["ttf", "ttc"],
        "x-font-type1": ["pfa", "pfb", "pfm", "afm"],
        "x-font-woff": "woff",
        "x-mobipocket-ebook": ["prc", "mobi"],
        "x-mspublisher": "pub",
        "x-nzb": "nzb",
        "x-tgif": "obj",
        "xaml+xml": "xaml",
        "xml-dtd": "dtd",
        "xproc+xml": "xpl",
        "xslt+xml": "xslt",
        "internet-property-stream": "acx",
        "x-compress": "z",
        "x-compressed": "tgz",
        "x-gzip": "gz"
      },
      "audio": {
        "flac": "flac",
        "midi": ["mid", "midi", "kar", "rmi"],
        "mpeg": ["mpga", "mpega", "mp2", "mp3", "m4a", "mp2a", "m2a", "m3a"],
        "mpegurl": "m3u",
        "ogg": ["oga", "ogg", "spx"],
        "x-aiff": ["aif", "aiff", "aifc"],
        "x-ms-wma": "wma",
        "x-wav": "wav",
        "adpcm": "adp",
        "mp4": "mp4a",
        "webm": "weba",
        "x-aac": "aac",
        "x-caf": "caf",
        "x-matroska": "mka",
        "x-pn-realaudio-plugin": "rmp",
        "xm": "xm",
        "mid": ["mid", "rmi"]
      },
      "image": {
        "gif": "gif",
        "ief": "ief",
        "jpeg": ["jpeg", "jpg", "jpe"],
        "pcx": "pcx",
        "png": "png",
        "svg+xml": ["svg", "svgz"],
        "tiff": ["tiff", "tif"],
        "x-icon": "ico",
        "bmp": "bmp",
        "webp": "webp",
        "x-pict": ["pic", "pct"],
        "x-tga": "tga",
        "cis-cod": "cod"
      },
      "text": {
        "cache-manifest": ["manifest", "appcache"],
        "css": "css",
        "csv": "csv",
        "html": ["html", "htm", "shtml", "stm"],
        "mathml": "mml",
        "plain": ["txt", "text", "brf", "conf", "def", "list", "log", "in", "bas"],
        "richtext": "rtx",
        "tab-separated-values": "tsv",
        "x-bibtex": "bib"
      },
      "video": {
        "mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v", "mp2", "mpa", "mpv2"],
        "mp4": ["mp4", "mp4v", "mpg4"],
        "quicktime": ["qt", "mov"],
        "ogg": "ogv",
        "vnd.mpegurl": ["mxu", "m4u"],
        "x-flv": "flv",
        "x-la-asf": ["lsf", "lsx"],
        "x-mng": "mng",
        "x-ms-asf": ["asf", "asx", "asr"],
        "x-ms-wm": "wm",
        "x-ms-wmv": "wmv",
        "x-ms-wmx": "wmx",
        "x-ms-wvx": "wvx",
        "x-msvideo": "avi",
        "x-sgi-movie": "movie",
        "x-matroska": ["mpv", "mkv", "mk3d", "mks"],
        "3gpp2": "3g2",
        "h261": "h261",
        "h263": "h263",
        "h264": "h264",
        "jpeg": "jpgv",
        "jpm": ["jpm", "jpgm"],
        "mj2": ["mj2", "mjp2"],
        "vnd.ms-playready.media.pyv": "pyv",
        "vnd.uvvu.mp4": ["uvu", "uvvu"],
        "vnd.vivo": "viv",
        "webm": "webm",
        "x-f4v": "f4v",
        "x-m4v": "m4v",
        "x-ms-vob": "vob",
        "x-smv": "smv"
      }
    };
    var mimeTypes = function() {
      var type, subtype, val, index, mimeTypes2 = {};
      for (type in table) {
        if (table.hasOwnProperty(type)) {
          for (subtype in table[type]) {
            if (table[type].hasOwnProperty(subtype)) {
              val = table[type][subtype];
              if (typeof val == "string") {
                mimeTypes2[val] = type + "/" + subtype;
              } else {
                for (index = 0; index < val.length; index++) {
                  mimeTypes2[val[index]] = type + "/" + subtype;
                }
              }
            }
          }
        }
      }
      return mimeTypes2;
    }();
    var defaultValue = "text/plain";
    function lookup(filename) {
      return filename && mimeTypes[filename.split(".").pop().toLowerCase()] || defaultValue;
    }
    var _default = {
      lookup
    };
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/resources.js
var require_resources = __commonJS({
  "node_modules/epubjs/lib/resources.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _replacements = require_replacements();
    var _core = require_core();
    var _url = _interopRequireDefault(require_url());
    var _mime = _interopRequireDefault(require_mime());
    var _path = _interopRequireDefault(require_path2());
    var _pathWebpack = _interopRequireDefault(require_path());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Resources = class {
      constructor(manifest, options) {
        this.settings = {
          replacements: options && options.replacements || "base64",
          archive: options && options.archive,
          resolver: options && options.resolver,
          request: options && options.request
        };
        this.process(manifest);
      }
      process(manifest) {
        this.manifest = manifest;
        this.resources = Object.keys(manifest).map(function(key) {
          return manifest[key];
        });
        this.replacementUrls = [];
        this.html = [];
        this.assets = [];
        this.css = [];
        this.urls = [];
        this.cssUrls = [];
        this.split();
        this.splitUrls();
      }
      split() {
        this.html = this.resources.filter(function(item) {
          if (item.type === "application/xhtml+xml" || item.type === "text/html") {
            return true;
          }
        });
        this.assets = this.resources.filter(function(item) {
          if (item.type !== "application/xhtml+xml" && item.type !== "text/html") {
            return true;
          }
        });
        this.css = this.resources.filter(function(item) {
          if (item.type === "text/css") {
            return true;
          }
        });
      }
      splitUrls() {
        this.urls = this.assets.map(function(item) {
          return item.href;
        }.bind(this));
        this.cssUrls = this.css.map(function(item) {
          return item.href;
        });
      }
      createUrl(url) {
        var parsedUrl = new _url.default(url);
        var mimeType = _mime.default.lookup(parsedUrl.filename);
        if (this.settings.archive) {
          return this.settings.archive.createUrl(url, {
            "base64": this.settings.replacements === "base64"
          });
        } else {
          if (this.settings.replacements === "base64") {
            return this.settings.request(url, "blob").then((blob) => {
              return (0, _core.blob2base64)(blob);
            }).then((blob) => {
              return (0, _core.createBase64Url)(blob, mimeType);
            });
          } else {
            return this.settings.request(url, "blob").then((blob) => {
              return (0, _core.createBlobUrl)(blob, mimeType);
            });
          }
        }
      }
      replacements() {
        if (this.settings.replacements === "none") {
          return new Promise(function(resolve) {
            resolve(this.urls);
          }.bind(this));
        }
        var replacements = this.urls.map((url) => {
          var absolute = this.settings.resolver(url);
          return this.createUrl(absolute).catch((err) => {
            console.error(err);
            return null;
          });
        });
        return Promise.all(replacements).then((replacementUrls) => {
          this.replacementUrls = replacementUrls.filter((url) => {
            return typeof url === "string";
          });
          return replacementUrls;
        });
      }
      replaceCss(archive, resolver) {
        var replaced = [];
        archive = archive || this.settings.archive;
        resolver = resolver || this.settings.resolver;
        this.cssUrls.forEach(function(href) {
          var replacement = this.createCssFile(href, archive, resolver).then(function(replacementUrl) {
            var indexInUrls = this.urls.indexOf(href);
            if (indexInUrls > -1) {
              this.replacementUrls[indexInUrls] = replacementUrl;
            }
          }.bind(this));
          replaced.push(replacement);
        }.bind(this));
        return Promise.all(replaced);
      }
      createCssFile(href) {
        var newUrl;
        if (_pathWebpack.default.isAbsolute(href)) {
          return new Promise(function(resolve) {
            resolve();
          });
        }
        var absolute = this.settings.resolver(href);
        var textResponse;
        if (this.settings.archive) {
          textResponse = this.settings.archive.getText(absolute);
        } else {
          textResponse = this.settings.request(absolute, "text");
        }
        var relUrls = this.urls.map((assetHref) => {
          var resolved = this.settings.resolver(assetHref);
          var relative = new _path.default(absolute).relative(resolved);
          return relative;
        });
        if (!textResponse) {
          return new Promise(function(resolve) {
            resolve();
          });
        }
        return textResponse.then((text) => {
          text = (0, _replacements.substitute)(text, relUrls, this.replacementUrls);
          if (this.settings.replacements === "base64") {
            newUrl = (0, _core.createBase64Url)(text, "text/css");
          } else {
            newUrl = (0, _core.createBlobUrl)(text, "text/css");
          }
          return newUrl;
        }, (err) => {
          return new Promise(function(resolve) {
            resolve();
          });
        });
      }
      relativeTo(absolute, resolver) {
        resolver = resolver || this.settings.resolver;
        return this.urls.map(function(href) {
          var resolved = resolver(href);
          var relative = new _path.default(absolute).relative(resolved);
          return relative;
        }.bind(this));
      }
      get(path) {
        var indexInUrls = this.urls.indexOf(path);
        if (indexInUrls === -1) {
          return;
        }
        if (this.replacementUrls.length) {
          return new Promise(function(resolve, reject) {
            resolve(this.replacementUrls[indexInUrls]);
          }.bind(this));
        } else {
          return this.createUrl(path);
        }
      }
      substitute(content, url) {
        var relUrls;
        if (url) {
          relUrls = this.relativeTo(url);
        } else {
          relUrls = this.urls;
        }
        return (0, _replacements.substitute)(content, relUrls, this.replacementUrls);
      }
      destroy() {
        this.settings = void 0;
        this.manifest = void 0;
        this.resources = void 0;
        this.replacementUrls = void 0;
        this.html = void 0;
        this.assets = void 0;
        this.css = void 0;
        this.urls = void 0;
        this.cssUrls = void 0;
      }
    };
    var _default = Resources;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/pagelist.js
var require_pagelist = __commonJS({
  "node_modules/epubjs/lib/pagelist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _core = require_core();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var PageList = class {
      constructor(xml) {
        this.pages = [];
        this.locations = [];
        this.epubcfi = new _epubcfi.default();
        this.firstPage = 0;
        this.lastPage = 0;
        this.totalPages = 0;
        this.toc = void 0;
        this.ncx = void 0;
        if (xml) {
          this.pageList = this.parse(xml);
        }
        if (this.pageList && this.pageList.length) {
          this.process(this.pageList);
        }
      }
      parse(xml) {
        var html = (0, _core.qs)(xml, "html");
        var ncx = (0, _core.qs)(xml, "ncx");
        if (html) {
          return this.parseNav(xml);
        } else if (ncx) {
          return this.parseNcx(xml);
        }
      }
      parseNav(navHtml) {
        var navElement = (0, _core.querySelectorByType)(navHtml, "nav", "page-list");
        var navItems = navElement ? (0, _core.qsa)(navElement, "li") : [];
        var length = navItems.length;
        var i3;
        var list = [];
        var item;
        if (!navItems || length === 0)
          return list;
        for (i3 = 0; i3 < length; ++i3) {
          item = this.item(navItems[i3]);
          list.push(item);
        }
        return list;
      }
      parseNcx(navXml) {
        var list = [];
        var i3 = 0;
        var item;
        var pageList;
        var pageTargets;
        var length = 0;
        pageList = (0, _core.qs)(navXml, "pageList");
        if (!pageList)
          return list;
        pageTargets = (0, _core.qsa)(pageList, "pageTarget");
        length = pageTargets.length;
        if (!pageTargets || pageTargets.length === 0) {
          return list;
        }
        for (i3 = 0; i3 < length; ++i3) {
          item = this.ncxItem(pageTargets[i3]);
          list.push(item);
        }
        return list;
      }
      ncxItem(item) {
        var navLabel = (0, _core.qs)(item, "navLabel");
        var navLabelText = (0, _core.qs)(navLabel, "text");
        var pageText = navLabelText.textContent;
        var content = (0, _core.qs)(item, "content");
        var href = content.getAttribute("src");
        var page = parseInt(pageText, 10);
        return {
          "href": href,
          "page": page
        };
      }
      item(item) {
        var content = (0, _core.qs)(item, "a"), href = content.getAttribute("href") || "", text = content.textContent || "", page = parseInt(text), isCfi = href.indexOf("epubcfi"), split, packageUrl, cfi;
        if (isCfi != -1) {
          split = href.split("#");
          packageUrl = split[0];
          cfi = split.length > 1 ? split[1] : false;
          return {
            "cfi": cfi,
            "href": href,
            "packageUrl": packageUrl,
            "page": page
          };
        } else {
          return {
            "href": href,
            "page": page
          };
        }
      }
      process(pageList) {
        pageList.forEach(function(item) {
          this.pages.push(item.page);
          if (item.cfi) {
            this.locations.push(item.cfi);
          }
        }, this);
        this.firstPage = parseInt(this.pages[0]);
        this.lastPage = parseInt(this.pages[this.pages.length - 1]);
        this.totalPages = this.lastPage - this.firstPage;
      }
      pageFromCfi(cfi) {
        var pg = -1;
        if (this.locations.length === 0) {
          return -1;
        }
        var index = (0, _core.indexOfSorted)(cfi, this.locations, this.epubcfi.compare);
        if (index != -1) {
          pg = this.pages[index];
        } else {
          index = (0, _core.locationOf)(cfi, this.locations, this.epubcfi.compare);
          pg = index - 1 >= 0 ? this.pages[index - 1] : this.pages[0];
          if (pg !== void 0) {
          } else {
            pg = -1;
          }
        }
        return pg;
      }
      cfiFromPage(pg) {
        var cfi = -1;
        if (typeof pg != "number") {
          pg = parseInt(pg);
        }
        var index = this.pages.indexOf(pg);
        if (index != -1) {
          cfi = this.locations[index];
        }
        return cfi;
      }
      pageFromPercentage(percent) {
        var pg = Math.round(this.totalPages * percent);
        return pg;
      }
      percentageFromPage(pg) {
        var percentage = (pg - this.firstPage) / this.totalPages;
        return Math.round(percentage * 1e3) / 1e3;
      }
      percentageFromCfi(cfi) {
        var pg = this.pageFromCfi(cfi);
        var percentage = this.percentageFromPage(pg);
        return percentage;
      }
      destroy() {
        this.pages = void 0;
        this.locations = void 0;
        this.epubcfi = void 0;
        this.pageList = void 0;
        this.toc = void 0;
        this.ncx = void 0;
      }
    };
    var _default = PageList;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/layout.js
var require_layout = __commonJS({
  "node_modules/epubjs/lib/layout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _constants = require_constants();
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Layout = class {
      constructor(settings) {
        this.settings = settings;
        this.name = settings.layout || "reflowable";
        this._spread = settings.spread === "none" ? false : true;
        this._minSpreadWidth = settings.minSpreadWidth || 800;
        this._evenSpreads = settings.evenSpreads || false;
        if (settings.flow === "scrolled" || settings.flow === "scrolled-continuous" || settings.flow === "scrolled-doc") {
          this._flow = "scrolled";
        } else {
          this._flow = "paginated";
        }
        this.width = 0;
        this.height = 0;
        this.spreadWidth = 0;
        this.delta = 0;
        this.columnWidth = 0;
        this.gap = 0;
        this.divisor = 1;
        this.props = {
          name: this.name,
          spread: this._spread,
          flow: this._flow,
          width: 0,
          height: 0,
          spreadWidth: 0,
          delta: 0,
          columnWidth: 0,
          gap: 0,
          divisor: 1
        };
      }
      flow(flow) {
        if (typeof flow != "undefined") {
          if (flow === "scrolled" || flow === "scrolled-continuous" || flow === "scrolled-doc") {
            this._flow = "scrolled";
          } else {
            this._flow = "paginated";
          }
          this.update({
            flow: this._flow
          });
        }
        return this._flow;
      }
      spread(spread, min) {
        if (spread) {
          this._spread = spread === "none" ? false : true;
          this.update({
            spread: this._spread
          });
        }
        if (min >= 0) {
          this._minSpreadWidth = min;
        }
        return this._spread;
      }
      calculate(_width, _height, _gap) {
        var divisor = 1;
        var gap = _gap || 0;
        var width = _width;
        var height = _height;
        var section = Math.floor(width / 12);
        var columnWidth;
        var spreadWidth;
        var pageWidth;
        var delta;
        if (this._spread && width >= this._minSpreadWidth) {
          divisor = 2;
        } else {
          divisor = 1;
        }
        if (this.name === "reflowable" && this._flow === "paginated" && !(_gap >= 0)) {
          gap = section % 2 === 0 ? section : section - 1;
        }
        if (this.name === "pre-paginated") {
          gap = 0;
        }
        if (divisor > 1) {
          columnWidth = width / divisor - gap;
          pageWidth = columnWidth + gap;
        } else {
          columnWidth = width;
          pageWidth = width;
        }
        if (this.name === "pre-paginated" && divisor > 1) {
          width = columnWidth;
        }
        spreadWidth = columnWidth * divisor + gap;
        delta = width;
        this.width = width;
        this.height = height;
        this.spreadWidth = spreadWidth;
        this.pageWidth = pageWidth;
        this.delta = delta;
        this.columnWidth = columnWidth;
        this.gap = gap;
        this.divisor = divisor;
        this.update({
          width,
          height,
          spreadWidth,
          pageWidth,
          delta,
          columnWidth,
          gap,
          divisor
        });
      }
      format(contents, section, axis) {
        var formating;
        if (this.name === "pre-paginated") {
          formating = contents.fit(this.columnWidth, this.height, section);
        } else if (this._flow === "paginated") {
          formating = contents.columns(this.width, this.height, this.columnWidth, this.gap, this.settings.direction);
        } else if (axis && axis === "horizontal") {
          formating = contents.size(null, this.height);
        } else {
          formating = contents.size(this.width, null);
        }
        return formating;
      }
      count(totalLength, pageLength) {
        let spreads, pages;
        if (this.name === "pre-paginated") {
          spreads = 1;
          pages = 1;
        } else if (this._flow === "paginated") {
          pageLength = pageLength || this.delta;
          spreads = Math.ceil(totalLength / pageLength);
          pages = spreads * this.divisor;
        } else {
          pageLength = pageLength || this.height;
          spreads = Math.ceil(totalLength / pageLength);
          pages = spreads;
        }
        return {
          spreads,
          pages
        };
      }
      update(props) {
        Object.keys(props).forEach((propName) => {
          if (this.props[propName] === props[propName]) {
            delete props[propName];
          }
        });
        if (Object.keys(props).length > 0) {
          let newProps = (0, _core.extend)(this.props, props);
          this.emit(_constants.EVENTS.LAYOUT.UPDATED, newProps, props);
        }
      }
    };
    (0, _eventEmitter.default)(Layout.prototype);
    var _default = Layout;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/themes.js
var require_themes = __commonJS({
  "node_modules/epubjs/lib/themes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _url = _interopRequireDefault(require_url());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Themes = class {
      constructor(rendition) {
        this.rendition = rendition;
        this._themes = {
          "default": {
            "rules": {},
            "url": "",
            "serialized": ""
          }
        };
        this._overrides = {};
        this._current = "default";
        this._injected = [];
        this.rendition.hooks.content.register(this.inject.bind(this));
        this.rendition.hooks.content.register(this.overrides.bind(this));
      }
      register() {
        if (arguments.length === 0) {
          return;
        }
        if (arguments.length === 1 && typeof arguments[0] === "object") {
          return this.registerThemes(arguments[0]);
        }
        if (arguments.length === 1 && typeof arguments[0] === "string") {
          return this.default(arguments[0]);
        }
        if (arguments.length === 2 && typeof arguments[1] === "string") {
          return this.registerUrl(arguments[0], arguments[1]);
        }
        if (arguments.length === 2 && typeof arguments[1] === "object") {
          return this.registerRules(arguments[0], arguments[1]);
        }
      }
      default(theme) {
        if (!theme) {
          return;
        }
        if (typeof theme === "string") {
          return this.registerUrl("default", theme);
        }
        if (typeof theme === "object") {
          return this.registerRules("default", theme);
        }
      }
      registerThemes(themes) {
        for (var theme in themes) {
          if (themes.hasOwnProperty(theme)) {
            if (typeof themes[theme] === "string") {
              this.registerUrl(theme, themes[theme]);
            } else {
              this.registerRules(theme, themes[theme]);
            }
          }
        }
      }
      registerCss(name, css) {
        this._themes[name] = {
          "serialized": css
        };
        if (this._injected[name] || name == "default") {
          this.update(name);
        }
      }
      registerUrl(name, input) {
        var url = new _url.default(input);
        this._themes[name] = {
          "url": url.toString()
        };
        if (this._injected[name] || name == "default") {
          this.update(name);
        }
      }
      registerRules(name, rules) {
        this._themes[name] = {
          "rules": rules
        };
        if (this._injected[name] || name == "default") {
          this.update(name);
        }
      }
      select(name) {
        var prev = this._current;
        var contents;
        this._current = name;
        this.update(name);
        contents = this.rendition.getContents();
        contents.forEach((content) => {
          content.removeClass(prev);
          content.addClass(name);
        });
      }
      update(name) {
        var contents = this.rendition.getContents();
        contents.forEach((content) => {
          this.add(name, content);
        });
      }
      inject(contents) {
        var links = [];
        var themes = this._themes;
        var theme;
        for (var name in themes) {
          if (themes.hasOwnProperty(name) && (name === this._current || name === "default")) {
            theme = themes[name];
            if (theme.rules && Object.keys(theme.rules).length > 0 || theme.url && links.indexOf(theme.url) === -1) {
              this.add(name, contents);
            }
            this._injected.push(name);
          }
        }
        if (this._current != "default") {
          contents.addClass(this._current);
        }
      }
      add(name, contents) {
        var theme = this._themes[name];
        if (!theme || !contents) {
          return;
        }
        if (theme.url) {
          contents.addStylesheet(theme.url);
        } else if (theme.serialized) {
          contents.addStylesheetCss(theme.serialized, name);
          theme.injected = true;
        } else if (theme.rules) {
          contents.addStylesheetRules(theme.rules, name);
          theme.injected = true;
        }
      }
      override(name, value, priority) {
        var contents = this.rendition.getContents();
        this._overrides[name] = {
          value,
          priority: priority === true
        };
        contents.forEach((content) => {
          content.css(name, this._overrides[name].value, this._overrides[name].priority);
        });
      }
      removeOverride(name) {
        var contents = this.rendition.getContents();
        delete this._overrides[name];
        contents.forEach((content) => {
          content.css(name);
        });
      }
      overrides(contents) {
        var overrides = this._overrides;
        for (var rule in overrides) {
          if (overrides.hasOwnProperty(rule)) {
            contents.css(rule, overrides[rule].value, overrides[rule].priority);
          }
        }
      }
      fontSize(size) {
        this.override("font-size", size);
      }
      font(f3) {
        this.override("font-family", f3, true);
      }
      destroy() {
        this.rendition = void 0;
        this._themes = void 0;
        this._overrides = void 0;
        this._current = void 0;
        this._injected = void 0;
      }
    };
    var _default = Themes;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/mapping.js
var require_mapping = __commonJS({
  "node_modules/epubjs/lib/mapping.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _core = require_core();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Mapping = class {
      constructor(layout, direction, axis, dev = false) {
        this.layout = layout;
        this.horizontal = axis === "horizontal" ? true : false;
        this.direction = direction || "ltr";
        this._dev = dev;
      }
      section(view) {
        var ranges = this.findRanges(view);
        var map = this.rangeListToCfiList(view.section.cfiBase, ranges);
        return map;
      }
      page(contents, cfiBase, start, end) {
        var root = contents && contents.document ? contents.document.body : false;
        var result;
        if (!root) {
          return;
        }
        result = this.rangePairToCfiPair(cfiBase, {
          start: this.findStart(root, start, end),
          end: this.findEnd(root, start, end)
        });
        if (this._dev === true) {
          let doc = contents.document;
          let startRange = new _epubcfi.default(result.start).toRange(doc);
          let endRange = new _epubcfi.default(result.end).toRange(doc);
          let selection = doc.defaultView.getSelection();
          let r3 = doc.createRange();
          selection.removeAllRanges();
          r3.setStart(startRange.startContainer, startRange.startOffset);
          r3.setEnd(endRange.endContainer, endRange.endOffset);
          selection.addRange(r3);
        }
        return result;
      }
      walk(root, func) {
        if (root && root.nodeType === Node.TEXT_NODE) {
          return;
        }
        var filter = {
          acceptNode: function(node2) {
            if (node2.data.trim().length > 0) {
              return NodeFilter.FILTER_ACCEPT;
            } else {
              return NodeFilter.FILTER_REJECT;
            }
          }
        };
        var safeFilter = filter.acceptNode;
        safeFilter.acceptNode = filter.acceptNode;
        var treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, safeFilter, false);
        var node;
        var result;
        while (node = treeWalker.nextNode()) {
          result = func(node);
          if (result)
            break;
        }
        return result;
      }
      findRanges(view) {
        var columns = [];
        var scrollWidth = view.contents.scrollWidth();
        var spreads = Math.ceil(scrollWidth / this.layout.spreadWidth);
        var count = spreads * this.layout.divisor;
        var columnWidth = this.layout.columnWidth;
        var gap = this.layout.gap;
        var start, end;
        for (var i3 = 0; i3 < count.pages; i3++) {
          start = (columnWidth + gap) * i3;
          end = columnWidth * (i3 + 1) + gap * i3;
          columns.push({
            start: this.findStart(view.document.body, start, end),
            end: this.findEnd(view.document.body, start, end)
          });
        }
        return columns;
      }
      findStart(root, start, end) {
        var stack = [root];
        var $el;
        var found;
        var $prev = root;
        while (stack.length) {
          $el = stack.shift();
          found = this.walk($el, (node) => {
            var left, right, top, bottom;
            var elPos;
            var elRange;
            elPos = (0, _core.nodeBounds)(node);
            if (this.horizontal && this.direction === "ltr") {
              left = this.horizontal ? elPos.left : elPos.top;
              right = this.horizontal ? elPos.right : elPos.bottom;
              if (left >= start && left <= end) {
                return node;
              } else if (right > start) {
                return node;
              } else {
                $prev = node;
                stack.push(node);
              }
            } else if (this.horizontal && this.direction === "rtl") {
              left = elPos.left;
              right = elPos.right;
              if (right <= end && right >= start) {
                return node;
              } else if (left < end) {
                return node;
              } else {
                $prev = node;
                stack.push(node);
              }
            } else {
              top = elPos.top;
              bottom = elPos.bottom;
              if (top >= start && top <= end) {
                return node;
              } else if (bottom > start) {
                return node;
              } else {
                $prev = node;
                stack.push(node);
              }
            }
          });
          if (found) {
            return this.findTextStartRange(found, start, end);
          }
        }
        return this.findTextStartRange($prev, start, end);
      }
      findEnd(root, start, end) {
        var stack = [root];
        var $el;
        var $prev = root;
        var found;
        while (stack.length) {
          $el = stack.shift();
          found = this.walk($el, (node) => {
            var left, right, top, bottom;
            var elPos;
            var elRange;
            elPos = (0, _core.nodeBounds)(node);
            if (this.horizontal && this.direction === "ltr") {
              left = Math.round(elPos.left);
              right = Math.round(elPos.right);
              if (left > end && $prev) {
                return $prev;
              } else if (right > end) {
                return node;
              } else {
                $prev = node;
                stack.push(node);
              }
            } else if (this.horizontal && this.direction === "rtl") {
              left = Math.round(this.horizontal ? elPos.left : elPos.top);
              right = Math.round(this.horizontal ? elPos.right : elPos.bottom);
              if (right < start && $prev) {
                return $prev;
              } else if (left < start) {
                return node;
              } else {
                $prev = node;
                stack.push(node);
              }
            } else {
              top = Math.round(elPos.top);
              bottom = Math.round(elPos.bottom);
              if (top > end && $prev) {
                return $prev;
              } else if (bottom > end) {
                return node;
              } else {
                $prev = node;
                stack.push(node);
              }
            }
          });
          if (found) {
            return this.findTextEndRange(found, start, end);
          }
        }
        return this.findTextEndRange($prev, start, end);
      }
      findTextStartRange(node, start, end) {
        var ranges = this.splitTextNodeIntoRanges(node);
        var range;
        var pos;
        var left, top, right;
        for (var i3 = 0; i3 < ranges.length; i3++) {
          range = ranges[i3];
          pos = range.getBoundingClientRect();
          if (this.horizontal && this.direction === "ltr") {
            left = pos.left;
            if (left >= start) {
              return range;
            }
          } else if (this.horizontal && this.direction === "rtl") {
            right = pos.right;
            if (right <= end) {
              return range;
            }
          } else {
            top = pos.top;
            if (top >= start) {
              return range;
            }
          }
        }
        return ranges[0];
      }
      findTextEndRange(node, start, end) {
        var ranges = this.splitTextNodeIntoRanges(node);
        var prev;
        var range;
        var pos;
        var left, right, top, bottom;
        for (var i3 = 0; i3 < ranges.length; i3++) {
          range = ranges[i3];
          pos = range.getBoundingClientRect();
          if (this.horizontal && this.direction === "ltr") {
            left = pos.left;
            right = pos.right;
            if (left > end && prev) {
              return prev;
            } else if (right > end) {
              return range;
            }
          } else if (this.horizontal && this.direction === "rtl") {
            left = pos.left;
            right = pos.right;
            if (right < start && prev) {
              return prev;
            } else if (left < start) {
              return range;
            }
          } else {
            top = pos.top;
            bottom = pos.bottom;
            if (top > end && prev) {
              return prev;
            } else if (bottom > end) {
              return range;
            }
          }
          prev = range;
        }
        return ranges[ranges.length - 1];
      }
      splitTextNodeIntoRanges(node, _splitter) {
        var ranges = [];
        var textContent = node.textContent || "";
        var text = textContent.trim();
        var range;
        var doc = node.ownerDocument;
        var splitter = _splitter || " ";
        var pos = text.indexOf(splitter);
        if (pos === -1 || node.nodeType != Node.TEXT_NODE) {
          range = doc.createRange();
          range.selectNodeContents(node);
          return [range];
        }
        range = doc.createRange();
        range.setStart(node, 0);
        range.setEnd(node, pos);
        ranges.push(range);
        range = false;
        while (pos != -1) {
          pos = text.indexOf(splitter, pos + 1);
          if (pos > 0) {
            if (range) {
              range.setEnd(node, pos);
              ranges.push(range);
            }
            range = doc.createRange();
            range.setStart(node, pos + 1);
          }
        }
        if (range) {
          range.setEnd(node, text.length);
          ranges.push(range);
        }
        return ranges;
      }
      rangePairToCfiPair(cfiBase, rangePair) {
        var startRange = rangePair.start;
        var endRange = rangePair.end;
        startRange.collapse(true);
        endRange.collapse(false);
        let startCfi = new _epubcfi.default(startRange, cfiBase).toString();
        let endCfi = new _epubcfi.default(endRange, cfiBase).toString();
        return {
          start: startCfi,
          end: endCfi
        };
      }
      rangeListToCfiList(cfiBase, columns) {
        var map = [];
        var cifPair;
        for (var i3 = 0; i3 < columns.length; i3++) {
          cifPair = this.rangePairToCfiPair(cfiBase, columns[i3]);
          map.push(cifPair);
        }
        return map;
      }
      axis(axis) {
        if (axis) {
          this.horizontal = axis === "horizontal" ? true : false;
        }
        return this.horizontal;
      }
    };
    var _default = Mapping;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/contents.js
var require_contents = __commonJS({
  "node_modules/epubjs/lib/contents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _core = require_core();
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _mapping = _interopRequireDefault(require_mapping());
    var _replacements = require_replacements();
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hasNavigator = typeof navigator !== "undefined";
    var isChrome = hasNavigator && /Chrome/.test(navigator.userAgent);
    var isWebkit = hasNavigator && !isChrome && /AppleWebKit/.test(navigator.userAgent);
    var ELEMENT_NODE = 1;
    var Contents = class {
      constructor(doc, content, cfiBase, sectionIndex) {
        this.epubcfi = new _epubcfi.default();
        this.document = doc;
        this.documentElement = this.document.documentElement;
        this.content = content || this.document.body;
        this.window = this.document.defaultView;
        this._size = {
          width: 0,
          height: 0
        };
        this.sectionIndex = sectionIndex || 0;
        this.cfiBase = cfiBase || "";
        this.epubReadingSystem("epub.js", _constants.EPUBJS_VERSION);
        this.called = 0;
        this.active = true;
        this.listeners();
      }
      static get listenedEvents() {
        return _constants.DOM_EVENTS;
      }
      width(w4) {
        var frame = this.content;
        if (w4 && (0, _core.isNumber)(w4)) {
          w4 = w4 + "px";
        }
        if (w4) {
          frame.style.width = w4;
        }
        return parseInt(this.window.getComputedStyle(frame)["width"]);
      }
      height(h3) {
        var frame = this.content;
        if (h3 && (0, _core.isNumber)(h3)) {
          h3 = h3 + "px";
        }
        if (h3) {
          frame.style.height = h3;
        }
        return parseInt(this.window.getComputedStyle(frame)["height"]);
      }
      contentWidth(w4) {
        var content = this.content || this.document.body;
        if (w4 && (0, _core.isNumber)(w4)) {
          w4 = w4 + "px";
        }
        if (w4) {
          content.style.width = w4;
        }
        return parseInt(this.window.getComputedStyle(content)["width"]);
      }
      contentHeight(h3) {
        var content = this.content || this.document.body;
        if (h3 && (0, _core.isNumber)(h3)) {
          h3 = h3 + "px";
        }
        if (h3) {
          content.style.height = h3;
        }
        return parseInt(this.window.getComputedStyle(content)["height"]);
      }
      textWidth() {
        let rect;
        let width;
        let range = this.document.createRange();
        let content = this.content || this.document.body;
        let border = (0, _core.borders)(content);
        range.selectNodeContents(content);
        rect = range.getBoundingClientRect();
        width = rect.width;
        if (border && border.width) {
          width += border.width;
        }
        return Math.round(width);
      }
      textHeight() {
        let rect;
        let height;
        let range = this.document.createRange();
        let content = this.content || this.document.body;
        range.selectNodeContents(content);
        rect = range.getBoundingClientRect();
        height = rect.bottom;
        return Math.round(height);
      }
      scrollWidth() {
        var width = this.documentElement.scrollWidth;
        return width;
      }
      scrollHeight() {
        var height = this.documentElement.scrollHeight;
        return height;
      }
      overflow(overflow) {
        if (overflow) {
          this.documentElement.style.overflow = overflow;
        }
        return this.window.getComputedStyle(this.documentElement)["overflow"];
      }
      overflowX(overflow) {
        if (overflow) {
          this.documentElement.style.overflowX = overflow;
        }
        return this.window.getComputedStyle(this.documentElement)["overflowX"];
      }
      overflowY(overflow) {
        if (overflow) {
          this.documentElement.style.overflowY = overflow;
        }
        return this.window.getComputedStyle(this.documentElement)["overflowY"];
      }
      css(property, value, priority) {
        var content = this.content || this.document.body;
        if (value) {
          content.style.setProperty(property, value, priority ? "important" : "");
        } else {
          content.style.removeProperty(property);
        }
        return this.window.getComputedStyle(content)[property];
      }
      viewport(options) {
        var _width, _height, _scale, _minimum, _maximum, _scalable;
        var $viewport = this.document.querySelector("meta[name='viewport']");
        var parsed = {
          "width": void 0,
          "height": void 0,
          "scale": void 0,
          "minimum": void 0,
          "maximum": void 0,
          "scalable": void 0
        };
        var newContent = [];
        var settings = {};
        if ($viewport && $viewport.hasAttribute("content")) {
          let content = $viewport.getAttribute("content");
          let _width2 = content.match(/width\s*=\s*([^,]*)/);
          let _height2 = content.match(/height\s*=\s*([^,]*)/);
          let _scale2 = content.match(/initial-scale\s*=\s*([^,]*)/);
          let _minimum2 = content.match(/minimum-scale\s*=\s*([^,]*)/);
          let _maximum2 = content.match(/maximum-scale\s*=\s*([^,]*)/);
          let _scalable2 = content.match(/user-scalable\s*=\s*([^,]*)/);
          if (_width2 && _width2.length && typeof _width2[1] !== "undefined") {
            parsed.width = _width2[1];
          }
          if (_height2 && _height2.length && typeof _height2[1] !== "undefined") {
            parsed.height = _height2[1];
          }
          if (_scale2 && _scale2.length && typeof _scale2[1] !== "undefined") {
            parsed.scale = _scale2[1];
          }
          if (_minimum2 && _minimum2.length && typeof _minimum2[1] !== "undefined") {
            parsed.minimum = _minimum2[1];
          }
          if (_maximum2 && _maximum2.length && typeof _maximum2[1] !== "undefined") {
            parsed.maximum = _maximum2[1];
          }
          if (_scalable2 && _scalable2.length && typeof _scalable2[1] !== "undefined") {
            parsed.scalable = _scalable2[1];
          }
        }
        settings = (0, _core.defaults)(options || {}, parsed);
        if (options) {
          if (settings.width) {
            newContent.push("width=" + settings.width);
          }
          if (settings.height) {
            newContent.push("height=" + settings.height);
          }
          if (settings.scale) {
            newContent.push("initial-scale=" + settings.scale);
          }
          if (settings.scalable === "no") {
            newContent.push("minimum-scale=" + settings.scale);
            newContent.push("maximum-scale=" + settings.scale);
            newContent.push("user-scalable=" + settings.scalable);
          } else {
            if (settings.scalable) {
              newContent.push("user-scalable=" + settings.scalable);
            }
            if (settings.minimum) {
              newContent.push("minimum-scale=" + settings.minimum);
            }
            if (settings.maximum) {
              newContent.push("minimum-scale=" + settings.maximum);
            }
          }
          if (!$viewport) {
            $viewport = this.document.createElement("meta");
            $viewport.setAttribute("name", "viewport");
            this.document.querySelector("head").appendChild($viewport);
          }
          $viewport.setAttribute("content", newContent.join(", "));
          this.window.scrollTo(0, 0);
        }
        return settings;
      }
      expand() {
        this.emit(_constants.EVENTS.CONTENTS.EXPAND);
      }
      listeners() {
        this.imageLoadListeners();
        this.mediaQueryListeners();
        this.addEventListeners();
        this.addSelectionListeners();
        if (typeof ResizeObserver === "undefined") {
          this.resizeListeners();
          this.visibilityListeners();
        } else {
          this.resizeObservers();
        }
        this.linksHandler();
      }
      removeListeners() {
        this.removeEventListeners();
        this.removeSelectionListeners();
        if (this.observer) {
          this.observer.disconnect();
        }
        clearTimeout(this.expanding);
      }
      resizeCheck() {
        let width = this.textWidth();
        let height = this.textHeight();
        if (width != this._size.width || height != this._size.height) {
          this._size = {
            width,
            height
          };
          this.onResize && this.onResize(this._size);
          this.emit(_constants.EVENTS.CONTENTS.RESIZE, this._size);
        }
      }
      resizeListeners() {
        var width, height;
        clearTimeout(this.expanding);
        requestAnimationFrame(this.resizeCheck.bind(this));
        this.expanding = setTimeout(this.resizeListeners.bind(this), 350);
      }
      visibilityListeners() {
        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "visible" && this.active === false) {
            this.active = true;
            this.resizeListeners();
          } else {
            this.active = false;
            clearTimeout(this.expanding);
          }
        });
      }
      transitionListeners() {
        let body = this.content;
        body.style["transitionProperty"] = "font, font-size, font-size-adjust, font-stretch, font-variation-settings, font-weight, width, height";
        body.style["transitionDuration"] = "0.001ms";
        body.style["transitionTimingFunction"] = "linear";
        body.style["transitionDelay"] = "0";
        this._resizeCheck = this.resizeCheck.bind(this);
        this.document.addEventListener("transitionend", this._resizeCheck);
      }
      mediaQueryListeners() {
        var sheets = this.document.styleSheets;
        var mediaChangeHandler = function(m3) {
          if (m3.matches && !this._expanding) {
            setTimeout(this.expand.bind(this), 1);
          }
        }.bind(this);
        for (var i3 = 0; i3 < sheets.length; i3 += 1) {
          var rules;
          try {
            rules = sheets[i3].cssRules;
          } catch (e3) {
            return;
          }
          if (!rules)
            return;
          for (var j4 = 0; j4 < rules.length; j4 += 1) {
            if (rules[j4].media) {
              var mql = this.window.matchMedia(rules[j4].media.mediaText);
              mql.addListener(mediaChangeHandler);
            }
          }
        }
      }
      resizeObservers() {
        this.observer = new ResizeObserver((e3) => {
          requestAnimationFrame(this.resizeCheck.bind(this));
        });
        this.observer.observe(this.document.documentElement);
      }
      mutationObservers() {
        this.observer = new MutationObserver((mutations) => {
          this.resizeCheck();
        });
        let config = {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        };
        this.observer.observe(this.document, config);
      }
      imageLoadListeners() {
        var images = this.document.querySelectorAll("img");
        var img;
        for (var i3 = 0; i3 < images.length; i3++) {
          img = images[i3];
          if (typeof img.naturalWidth !== "undefined" && img.naturalWidth === 0) {
            img.onload = this.expand.bind(this);
          }
        }
      }
      fontLoadListeners() {
        if (!this.document || !this.document.fonts) {
          return;
        }
        this.document.fonts.ready.then(function() {
          this.resizeCheck();
        }.bind(this));
      }
      root() {
        if (!this.document)
          return null;
        return this.document.documentElement;
      }
      locationOf(target, ignoreClass) {
        var position;
        var targetPos = {
          "left": 0,
          "top": 0
        };
        if (!this.document)
          return targetPos;
        if (this.epubcfi.isCfiString(target)) {
          let range = new _epubcfi.default(target).toRange(this.document, ignoreClass);
          if (range) {
            try {
              if (!range.endContainer || range.startContainer == range.endContainer && range.startOffset == range.endOffset) {
                let pos = range.startContainer.textContent.indexOf(" ", range.startOffset);
                if (pos == -1) {
                  pos = range.startContainer.textContent.length;
                }
                range.setEnd(range.startContainer, pos);
              }
            } catch (e3) {
              console.error("setting end offset to start container length failed", e3);
            }
            if (range.startContainer.nodeType === Node.ELEMENT_NODE) {
              position = range.startContainer.getBoundingClientRect();
              targetPos.left = position.left;
              targetPos.top = position.top;
            } else {
              if (isWebkit) {
                let container = range.startContainer;
                let newRange = new Range();
                try {
                  if (container.nodeType === ELEMENT_NODE) {
                    position = container.getBoundingClientRect();
                  } else if (range.startOffset + 2 < container.length) {
                    newRange.setStart(container, range.startOffset);
                    newRange.setEnd(container, range.startOffset + 2);
                    position = newRange.getBoundingClientRect();
                  } else if (range.startOffset - 2 > 0) {
                    newRange.setStart(container, range.startOffset - 2);
                    newRange.setEnd(container, range.startOffset);
                    position = newRange.getBoundingClientRect();
                  } else {
                    position = container.parentNode.getBoundingClientRect();
                  }
                } catch (e3) {
                  console.error(e3, e3.stack);
                }
              } else {
                position = range.getBoundingClientRect();
              }
            }
          }
        } else if (typeof target === "string" && target.indexOf("#") > -1) {
          let id = target.substring(target.indexOf("#") + 1);
          let el = this.document.getElementById(id);
          if (el) {
            if (isWebkit) {
              let newRange = new Range();
              newRange.selectNode(el);
              position = newRange.getBoundingClientRect();
            } else {
              position = el.getBoundingClientRect();
            }
          }
        }
        if (position) {
          targetPos.left = position.left;
          targetPos.top = position.top;
        }
        return targetPos;
      }
      addStylesheet(src) {
        return new Promise(function(resolve, reject) {
          var $stylesheet;
          var ready = false;
          if (!this.document) {
            resolve(false);
            return;
          }
          $stylesheet = this.document.querySelector("link[href='" + src + "']");
          if ($stylesheet) {
            resolve(true);
            return;
          }
          $stylesheet = this.document.createElement("link");
          $stylesheet.type = "text/css";
          $stylesheet.rel = "stylesheet";
          $stylesheet.href = src;
          $stylesheet.onload = $stylesheet.onreadystatechange = function() {
            if (!ready && (!this.readyState || this.readyState == "complete")) {
              ready = true;
              setTimeout(() => {
                resolve(true);
              }, 1);
            }
          };
          this.document.head.appendChild($stylesheet);
        }.bind(this));
      }
      _getStylesheetNode(key) {
        var styleEl;
        key = "epubjs-inserted-css-" + (key || "");
        if (!this.document)
          return false;
        styleEl = this.document.getElementById(key);
        if (!styleEl) {
          styleEl = this.document.createElement("style");
          styleEl.id = key;
          this.document.head.appendChild(styleEl);
        }
        return styleEl;
      }
      addStylesheetCss(serializedCss, key) {
        if (!this.document || !serializedCss)
          return false;
        var styleEl;
        styleEl = this._getStylesheetNode(key);
        styleEl.innerHTML = serializedCss;
        return true;
      }
      addStylesheetRules(rules, key) {
        var styleSheet;
        if (!this.document || !rules || rules.length === 0)
          return;
        styleSheet = this._getStylesheetNode(key).sheet;
        if (Object.prototype.toString.call(rules) === "[object Array]") {
          for (var i3 = 0, rl = rules.length; i3 < rl; i3++) {
            var j4 = 1, rule = rules[i3], selector = rules[i3][0], propStr = "";
            if (Object.prototype.toString.call(rule[1][0]) === "[object Array]") {
              rule = rule[1];
              j4 = 0;
            }
            for (var pl = rule.length; j4 < pl; j4++) {
              var prop = rule[j4];
              propStr += prop[0] + ":" + prop[1] + (prop[2] ? " !important" : "") + ";\n";
            }
            styleSheet.insertRule(selector + "{" + propStr + "}", styleSheet.cssRules.length);
          }
        } else {
          const selectors = Object.keys(rules);
          selectors.forEach((selector2) => {
            const definition = rules[selector2];
            if (Array.isArray(definition)) {
              definition.forEach((item) => {
                const _rules = Object.keys(item);
                const result = _rules.map((rule2) => {
                  return `${rule2}:${item[rule2]}`;
                }).join(";");
                styleSheet.insertRule(`${selector2}{${result}}`, styleSheet.cssRules.length);
              });
            } else {
              const _rules = Object.keys(definition);
              const result = _rules.map((rule2) => {
                return `${rule2}:${definition[rule2]}`;
              }).join(";");
              styleSheet.insertRule(`${selector2}{${result}}`, styleSheet.cssRules.length);
            }
          });
        }
      }
      addScript(src) {
        return new Promise(function(resolve, reject) {
          var $script;
          var ready = false;
          if (!this.document) {
            resolve(false);
            return;
          }
          $script = this.document.createElement("script");
          $script.type = "text/javascript";
          $script.async = true;
          $script.src = src;
          $script.onload = $script.onreadystatechange = function() {
            if (!ready && (!this.readyState || this.readyState == "complete")) {
              ready = true;
              setTimeout(function() {
                resolve(true);
              }, 1);
            }
          };
          this.document.head.appendChild($script);
        }.bind(this));
      }
      addClass(className) {
        var content;
        if (!this.document)
          return;
        content = this.content || this.document.body;
        if (content) {
          content.classList.add(className);
        }
      }
      removeClass(className) {
        var content;
        if (!this.document)
          return;
        content = this.content || this.document.body;
        if (content) {
          content.classList.remove(className);
        }
      }
      addEventListeners() {
        if (!this.document) {
          return;
        }
        this._triggerEvent = this.triggerEvent.bind(this);
        _constants.DOM_EVENTS.forEach(function(eventName) {
          this.document.addEventListener(eventName, this._triggerEvent, {
            passive: true
          });
        }, this);
      }
      removeEventListeners() {
        if (!this.document) {
          return;
        }
        _constants.DOM_EVENTS.forEach(function(eventName) {
          this.document.removeEventListener(eventName, this._triggerEvent, {
            passive: true
          });
        }, this);
        this._triggerEvent = void 0;
      }
      triggerEvent(e3) {
        this.emit(e3.type, e3);
      }
      addSelectionListeners() {
        if (!this.document) {
          return;
        }
        this._onSelectionChange = this.onSelectionChange.bind(this);
        this.document.addEventListener("selectionchange", this._onSelectionChange, {
          passive: true
        });
      }
      removeSelectionListeners() {
        if (!this.document) {
          return;
        }
        this.document.removeEventListener("selectionchange", this._onSelectionChange, {
          passive: true
        });
        this._onSelectionChange = void 0;
      }
      onSelectionChange(e3) {
        if (this.selectionEndTimeout) {
          clearTimeout(this.selectionEndTimeout);
        }
        this.selectionEndTimeout = setTimeout(function() {
          var selection = this.window.getSelection();
          this.triggerSelectedEvent(selection);
        }.bind(this), 250);
      }
      triggerSelectedEvent(selection) {
        var range, cfirange;
        if (selection && selection.rangeCount > 0) {
          range = selection.getRangeAt(0);
          if (!range.collapsed) {
            cfirange = new _epubcfi.default(range, this.cfiBase).toString();
            this.emit(_constants.EVENTS.CONTENTS.SELECTED, cfirange);
            this.emit(_constants.EVENTS.CONTENTS.SELECTED_RANGE, range);
          }
        }
      }
      range(_cfi, ignoreClass) {
        var cfi = new _epubcfi.default(_cfi);
        return cfi.toRange(this.document, ignoreClass);
      }
      cfiFromRange(range, ignoreClass) {
        return new _epubcfi.default(range, this.cfiBase, ignoreClass).toString();
      }
      cfiFromNode(node, ignoreClass) {
        return new _epubcfi.default(node, this.cfiBase, ignoreClass).toString();
      }
      map(layout) {
        var map = new _mapping.default(layout);
        return map.section();
      }
      size(width, height) {
        var viewport = {
          scale: 1,
          scalable: "no"
        };
        this.layoutStyle("scrolling");
        if (width >= 0) {
          this.width(width);
          viewport.width = width;
          this.css("padding", "0 " + width / 12 + "px");
        }
        if (height >= 0) {
          this.height(height);
          viewport.height = height;
        }
        this.css("margin", "0");
        this.css("box-sizing", "border-box");
        this.viewport(viewport);
      }
      columns(width, height, columnWidth, gap, dir) {
        let COLUMN_AXIS = (0, _core.prefixed)("column-axis");
        let COLUMN_GAP = (0, _core.prefixed)("column-gap");
        let COLUMN_WIDTH = (0, _core.prefixed)("column-width");
        let COLUMN_FILL = (0, _core.prefixed)("column-fill");
        let writingMode = this.writingMode();
        let axis = writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal";
        this.layoutStyle("paginated");
        if (dir === "rtl" && axis === "horizontal") {
          this.direction(dir);
        }
        this.width(width);
        this.height(height);
        this.viewport({
          width,
          height,
          scale: 1,
          scalable: "no"
        });
        this.css("overflow-y", "hidden");
        this.css("margin", "0", true);
        if (axis === "vertical") {
          this.css("padding-top", gap / 2 + "px", true);
          this.css("padding-bottom", gap / 2 + "px", true);
          this.css("padding-left", "20px");
          this.css("padding-right", "20px");
          this.css(COLUMN_AXIS, "vertical");
        } else {
          this.css("padding-top", "20px");
          this.css("padding-bottom", "20px");
          this.css("padding-left", gap / 2 + "px", true);
          this.css("padding-right", gap / 2 + "px", true);
          this.css(COLUMN_AXIS, "horizontal");
        }
        this.css("box-sizing", "border-box");
        this.css("max-width", "inherit");
        this.css(COLUMN_FILL, "auto");
        this.css(COLUMN_GAP, gap + "px");
        this.css(COLUMN_WIDTH, columnWidth + "px");
        this.css("-webkit-line-box-contain", "block glyphs replaced");
      }
      scaler(scale, offsetX, offsetY) {
        var scaleStr = "scale(" + scale + ")";
        var translateStr = "";
        this.css("transform-origin", "top left");
        if (offsetX >= 0 || offsetY >= 0) {
          translateStr = " translate(" + (offsetX || 0) + "px, " + (offsetY || 0) + "px )";
        }
        this.css("transform", scaleStr + translateStr);
      }
      fit(width, height, section) {
        var viewport = this.viewport();
        var viewportWidth = parseInt(viewport.width);
        var viewportHeight = parseInt(viewport.height);
        var widthScale = width / viewportWidth;
        var heightScale = height / viewportHeight;
        var scale = widthScale < heightScale ? widthScale : heightScale;
        this.layoutStyle("paginated");
        this.width(viewportWidth);
        this.height(viewportHeight);
        this.overflow("hidden");
        this.scaler(scale, 0, 0);
        this.css("background-size", viewportWidth * scale + "px " + viewportHeight * scale + "px");
        this.css("background-color", "transparent");
        if (section && section.properties.includes("page-spread-left")) {
          var marginLeft = width - viewportWidth * scale;
          this.css("margin-left", marginLeft + "px");
        }
      }
      direction(dir) {
        if (this.documentElement) {
          this.documentElement.style["direction"] = dir;
        }
      }
      mapPage(cfiBase, layout, start, end, dev) {
        var mapping = new _mapping.default(layout, dev);
        return mapping.page(this, cfiBase, start, end);
      }
      linksHandler() {
        (0, _replacements.replaceLinks)(this.content, (href) => {
          this.emit(_constants.EVENTS.CONTENTS.LINK_CLICKED, href);
        });
      }
      writingMode(mode) {
        let WRITING_MODE = (0, _core.prefixed)("writing-mode");
        if (mode && this.documentElement) {
          this.documentElement.style[WRITING_MODE] = mode;
        }
        return this.window.getComputedStyle(this.documentElement)[WRITING_MODE] || "";
      }
      layoutStyle(style) {
        if (style) {
          this._layoutStyle = style;
          navigator.epubReadingSystem.layoutStyle = this._layoutStyle;
        }
        return this._layoutStyle || "paginated";
      }
      epubReadingSystem(name, version) {
        navigator.epubReadingSystem = {
          name,
          version,
          layoutStyle: this.layoutStyle(),
          hasFeature: function(feature) {
            switch (feature) {
              case "dom-manipulation":
                return true;
              case "layout-changes":
                return true;
              case "touch-events":
                return true;
              case "mouse-events":
                return true;
              case "keyboard-events":
                return true;
              case "spine-scripting":
                return false;
              default:
                return false;
            }
          }
        };
        return navigator.epubReadingSystem;
      }
      destroy() {
        this.removeListeners();
      }
    };
    (0, _eventEmitter.default)(Contents.prototype);
    var _default = Contents;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/annotations.js
var require_annotations = __commonJS({
  "node_modules/epubjs/lib/annotations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Annotations = class {
      constructor(rendition) {
        this.rendition = rendition;
        this.highlights = [];
        this.underlines = [];
        this.marks = [];
        this._annotations = {};
        this._annotationsBySectionIndex = {};
        this.rendition.hooks.render.register(this.inject.bind(this));
        this.rendition.hooks.unloaded.register(this.clear.bind(this));
      }
      add(type, cfiRange, data, cb, className, styles) {
        let hash = encodeURI(cfiRange + type);
        let cfi = new _epubcfi.default(cfiRange);
        let sectionIndex = cfi.spinePos;
        let annotation = new Annotation({
          type,
          cfiRange,
          data,
          sectionIndex,
          cb,
          className,
          styles
        });
        this._annotations[hash] = annotation;
        if (sectionIndex in this._annotationsBySectionIndex) {
          this._annotationsBySectionIndex[sectionIndex].push(hash);
        } else {
          this._annotationsBySectionIndex[sectionIndex] = [hash];
        }
        let views = this.rendition.views();
        views.forEach((view) => {
          if (annotation.sectionIndex === view.index) {
            annotation.attach(view);
          }
        });
        return annotation;
      }
      remove(cfiRange, type) {
        let hash = encodeURI(cfiRange + type);
        if (hash in this._annotations) {
          let annotation = this._annotations[hash];
          if (type && annotation.type !== type) {
            return;
          }
          let views = this.rendition.views();
          views.forEach((view) => {
            this._removeFromAnnotationBySectionIndex(annotation.sectionIndex, hash);
            if (annotation.sectionIndex === view.index) {
              annotation.detach(view);
            }
          });
          delete this._annotations[hash];
        }
      }
      _removeFromAnnotationBySectionIndex(sectionIndex, hash) {
        this._annotationsBySectionIndex[sectionIndex] = this._annotationsAt(sectionIndex).filter((h3) => h3 !== hash);
      }
      _annotationsAt(index) {
        return this._annotationsBySectionIndex[index];
      }
      highlight(cfiRange, data, cb, className, styles) {
        return this.add("highlight", cfiRange, data, cb, className, styles);
      }
      underline(cfiRange, data, cb, className, styles) {
        return this.add("underline", cfiRange, data, cb, className, styles);
      }
      mark(cfiRange, data, cb) {
        return this.add("mark", cfiRange, data, cb);
      }
      each() {
        return this._annotations.forEach.apply(this._annotations, arguments);
      }
      inject(view) {
        let sectionIndex = view.index;
        if (sectionIndex in this._annotationsBySectionIndex) {
          let annotations = this._annotationsBySectionIndex[sectionIndex];
          annotations.forEach((hash) => {
            let annotation = this._annotations[hash];
            annotation.attach(view);
          });
        }
      }
      clear(view) {
        let sectionIndex = view.index;
        if (sectionIndex in this._annotationsBySectionIndex) {
          let annotations = this._annotationsBySectionIndex[sectionIndex];
          annotations.forEach((hash) => {
            let annotation = this._annotations[hash];
            annotation.detach(view);
          });
        }
      }
      show() {
      }
      hide() {
      }
    };
    var Annotation = class {
      constructor({
        type,
        cfiRange,
        data,
        sectionIndex,
        cb,
        className,
        styles
      }) {
        this.type = type;
        this.cfiRange = cfiRange;
        this.data = data;
        this.sectionIndex = sectionIndex;
        this.mark = void 0;
        this.cb = cb;
        this.className = className;
        this.styles = styles;
      }
      update(data) {
        this.data = data;
      }
      attach(view) {
        let {
          cfiRange,
          data,
          type,
          mark,
          cb,
          className,
          styles
        } = this;
        let result;
        if (type === "highlight") {
          result = view.highlight(cfiRange, data, cb, className, styles);
        } else if (type === "underline") {
          result = view.underline(cfiRange, data, cb, className, styles);
        } else if (type === "mark") {
          result = view.mark(cfiRange, data, cb);
        }
        this.mark = result;
        this.emit(_constants.EVENTS.ANNOTATION.ATTACH, result);
        return result;
      }
      detach(view) {
        let {
          cfiRange,
          type
        } = this;
        let result;
        if (view) {
          if (type === "highlight") {
            result = view.unhighlight(cfiRange);
          } else if (type === "underline") {
            result = view.ununderline(cfiRange);
          } else if (type === "mark") {
            result = view.unmark(cfiRange);
          }
        }
        this.mark = void 0;
        this.emit(_constants.EVENTS.ANNOTATION.DETACH, result);
        return result;
      }
      text() {
      }
    };
    (0, _eventEmitter.default)(Annotation.prototype);
    var _default = Annotations;
    exports.default = _default;
  }
});

// node_modules/marks-pane/lib/svg.js
var require_svg = __commonJS({
  "node_modules/marks-pane/lib/svg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createElement = createElement;
    function createElement(name) {
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }
    exports.default = {
      createElement
    };
  }
});

// node_modules/marks-pane/lib/events.js
var require_events = __commonJS({
  "node_modules/marks-pane/lib/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.proxyMouse = proxyMouse;
    exports.clone = clone;
    exports.default = {
      proxyMouse
    };
    function proxyMouse(target, tracked) {
      function dispatch(e3) {
        for (var i3 = tracked.length - 1; i3 >= 0; i3--) {
          var t3 = tracked[i3];
          var x4 = e3.clientX;
          var y3 = e3.clientY;
          if (e3.touches && e3.touches.length) {
            x4 = e3.touches[0].clientX;
            y3 = e3.touches[0].clientY;
          }
          if (!contains(t3, target, x4, y3)) {
            continue;
          }
          t3.dispatchEvent(clone(e3));
          break;
        }
      }
      if (target.nodeName === "iframe" || target.nodeName === "IFRAME") {
        try {
          this.target = target.contentDocument;
        } catch (err) {
          this.target = target;
        }
      } else {
        this.target = target;
      }
      var _arr = ["mouseup", "mousedown", "click", "touchstart"];
      for (var _i = 0; _i < _arr.length; _i++) {
        var ev = _arr[_i];
        this.target.addEventListener(ev, function(e3) {
          return dispatch(e3);
        }, false);
      }
    }
    function clone(e3) {
      var opts = Object.assign({}, e3, { bubbles: false });
      try {
        return new MouseEvent(e3.type, opts);
      } catch (err) {
        var copy = document.createEvent("MouseEvents");
        copy.initMouseEvent(e3.type, false, opts.cancelable, opts.view, opts.detail, opts.screenX, opts.screenY, opts.clientX, opts.clientY, opts.ctrlKey, opts.altKey, opts.shiftKey, opts.metaKey, opts.button, opts.relatedTarget);
        return copy;
      }
    }
    function contains(item, target, x4, y3) {
      var offset = target.getBoundingClientRect();
      function rectContains(r3, x5, y4) {
        var top = r3.top - offset.top;
        var left = r3.left - offset.left;
        var bottom = top + r3.height;
        var right = left + r3.width;
        return top <= y4 && left <= x5 && bottom > y4 && right > x5;
      }
      var rect = item.getBoundingClientRect();
      if (!rectContains(rect, x4, y3)) {
        return false;
      }
      var rects = item.getClientRects();
      for (var i3 = 0, len = rects.length; i3 < len; i3++) {
        if (rectContains(rects[i3], x4, y3)) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/marks-pane/lib/marks.js
var require_marks = __commonJS({
  "node_modules/marks-pane/lib/marks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Underline = exports.Highlight = exports.Mark = exports.Pane = void 0;
    var _get = function get(object, property, receiver) {
      if (object === null)
        object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === void 0) {
        var parent2 = Object.getPrototypeOf(object);
        if (parent2 === null) {
          return void 0;
        } else {
          return get(parent2, property, receiver);
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === void 0) {
          return void 0;
        }
        return getter.call(receiver);
      }
    };
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i3 = 0; i3 < props.length; i3++) {
          var descriptor = props[i3];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _svg = require_svg();
    var _svg2 = _interopRequireDefault(_svg);
    var _events = require_events();
    var _events2 = _interopRequireDefault(_events);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Pane = exports.Pane = function() {
      function Pane2(target) {
        var container = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : document.body;
        _classCallCheck(this, Pane2);
        this.target = target;
        this.element = _svg2.default.createElement("svg");
        this.marks = [];
        this.element.style.position = "absolute";
        this.element.setAttribute("pointer-events", "none");
        _events2.default.proxyMouse(this.target, this.marks);
        this.container = container;
        this.container.appendChild(this.element);
        this.render();
      }
      _createClass(Pane2, [{
        key: "addMark",
        value: function addMark(mark) {
          var g4 = _svg2.default.createElement("g");
          this.element.appendChild(g4);
          mark.bind(g4, this.container);
          this.marks.push(mark);
          mark.render();
          return mark;
        }
      }, {
        key: "removeMark",
        value: function removeMark(mark) {
          var idx = this.marks.indexOf(mark);
          if (idx === -1) {
            return;
          }
          var el = mark.unbind();
          this.element.removeChild(el);
          this.marks.splice(idx, 1);
        }
      }, {
        key: "render",
        value: function render() {
          setCoords(this.element, coords(this.target, this.container));
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = this.marks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var m3 = _step.value;
              m3.render();
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }]);
      return Pane2;
    }();
    var Mark = exports.Mark = function() {
      function Mark2() {
        _classCallCheck(this, Mark2);
        this.element = null;
      }
      _createClass(Mark2, [{
        key: "bind",
        value: function bind(element, container) {
          this.element = element;
          this.container = container;
        }
      }, {
        key: "unbind",
        value: function unbind() {
          var el = this.element;
          this.element = null;
          return el;
        }
      }, {
        key: "render",
        value: function render() {
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(e3) {
          if (!this.element)
            return;
          this.element.dispatchEvent(e3);
        }
      }, {
        key: "getBoundingClientRect",
        value: function getBoundingClientRect() {
          return this.element.getBoundingClientRect();
        }
      }, {
        key: "getClientRects",
        value: function getClientRects() {
          var rects = [];
          var el = this.element.firstChild;
          while (el) {
            rects.push(el.getBoundingClientRect());
            el = el.nextSibling;
          }
          return rects;
        }
      }, {
        key: "filteredRanges",
        value: function filteredRanges() {
          var rects = Array.from(this.range.getClientRects());
          return rects.filter(function(box) {
            for (var i3 = 0; i3 < rects.length; i3++) {
              if (rects[i3] === box) {
                return true;
              }
              var contained = contains(rects[i3], box);
              if (contained) {
                return false;
              }
            }
            return true;
          });
        }
      }]);
      return Mark2;
    }();
    var Highlight = exports.Highlight = function(_Mark) {
      _inherits(Highlight2, _Mark);
      function Highlight2(range, className, data, attributes) {
        _classCallCheck(this, Highlight2);
        var _this = _possibleConstructorReturn(this, (Highlight2.__proto__ || Object.getPrototypeOf(Highlight2)).call(this));
        _this.range = range;
        _this.className = className;
        _this.data = data || {};
        _this.attributes = attributes || {};
        return _this;
      }
      _createClass(Highlight2, [{
        key: "bind",
        value: function bind(element, container) {
          _get(Highlight2.prototype.__proto__ || Object.getPrototypeOf(Highlight2.prototype), "bind", this).call(this, element, container);
          for (var attr in this.data) {
            if (this.data.hasOwnProperty(attr)) {
              this.element.dataset[attr] = this.data[attr];
            }
          }
          for (var attr in this.attributes) {
            if (this.attributes.hasOwnProperty(attr)) {
              this.element.setAttribute(attr, this.attributes[attr]);
            }
          }
          if (this.className) {
            this.element.classList.add(this.className);
          }
        }
      }, {
        key: "render",
        value: function render() {
          while (this.element.firstChild) {
            this.element.removeChild(this.element.firstChild);
          }
          var docFrag = this.element.ownerDocument.createDocumentFragment();
          var filtered = this.filteredRanges();
          var offset = this.element.getBoundingClientRect();
          var container = this.container.getBoundingClientRect();
          for (var i3 = 0, len = filtered.length; i3 < len; i3++) {
            var r3 = filtered[i3];
            var el = _svg2.default.createElement("rect");
            el.setAttribute("x", r3.left - offset.left + container.left);
            el.setAttribute("y", r3.top - offset.top + container.top);
            el.setAttribute("height", r3.height);
            el.setAttribute("width", r3.width);
            docFrag.appendChild(el);
          }
          this.element.appendChild(docFrag);
        }
      }]);
      return Highlight2;
    }(Mark);
    var Underline = exports.Underline = function(_Highlight) {
      _inherits(Underline2, _Highlight);
      function Underline2(range, className, data, attributes) {
        _classCallCheck(this, Underline2);
        return _possibleConstructorReturn(this, (Underline2.__proto__ || Object.getPrototypeOf(Underline2)).call(this, range, className, data, attributes));
      }
      _createClass(Underline2, [{
        key: "render",
        value: function render() {
          while (this.element.firstChild) {
            this.element.removeChild(this.element.firstChild);
          }
          var docFrag = this.element.ownerDocument.createDocumentFragment();
          var filtered = this.filteredRanges();
          var offset = this.element.getBoundingClientRect();
          var container = this.container.getBoundingClientRect();
          for (var i3 = 0, len = filtered.length; i3 < len; i3++) {
            var r3 = filtered[i3];
            var rect = _svg2.default.createElement("rect");
            rect.setAttribute("x", r3.left - offset.left + container.left);
            rect.setAttribute("y", r3.top - offset.top + container.top);
            rect.setAttribute("height", r3.height);
            rect.setAttribute("width", r3.width);
            rect.setAttribute("fill", "none");
            var line = _svg2.default.createElement("line");
            line.setAttribute("x1", r3.left - offset.left + container.left);
            line.setAttribute("x2", r3.left - offset.left + container.left + r3.width);
            line.setAttribute("y1", r3.top - offset.top + container.top + r3.height - 1);
            line.setAttribute("y2", r3.top - offset.top + container.top + r3.height - 1);
            line.setAttribute("stroke-width", 1);
            line.setAttribute("stroke", "black");
            line.setAttribute("stroke-linecap", "square");
            docFrag.appendChild(rect);
            docFrag.appendChild(line);
          }
          this.element.appendChild(docFrag);
        }
      }]);
      return Underline2;
    }(Highlight);
    function coords(el, container) {
      var offset = container.getBoundingClientRect();
      var rect = el.getBoundingClientRect();
      return {
        top: rect.top - offset.top,
        left: rect.left - offset.left,
        height: el.scrollHeight,
        width: el.scrollWidth
      };
    }
    function setCoords(el, coords2) {
      el.style.setProperty("top", coords2.top + "px", "important");
      el.style.setProperty("left", coords2.left + "px", "important");
      el.style.setProperty("height", coords2.height + "px", "important");
      el.style.setProperty("width", coords2.width + "px", "important");
    }
    function contains(rect1, rect2) {
      return rect2.right <= rect1.right && rect2.left >= rect1.left && rect2.top >= rect1.top && rect2.bottom <= rect1.bottom;
    }
  }
});

// node_modules/epubjs/lib/managers/views/iframe.js
var require_iframe = __commonJS({
  "node_modules/epubjs/lib/managers/views/iframe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _core = require_core();
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _contents = _interopRequireDefault(require_contents());
    var _constants = require_constants();
    var _marksPane = require_marks();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IframeView = class {
      constructor(section, options) {
        this.settings = (0, _core.extend)({
          ignoreClass: "",
          axis: void 0,
          direction: void 0,
          width: 0,
          height: 0,
          layout: void 0,
          globalLayoutProperties: {},
          method: void 0,
          forceRight: false,
          allowScriptedContent: false,
          allowPopups: false
        }, options || {});
        this.id = "epubjs-view-" + (0, _core.uuid)();
        this.section = section;
        this.index = section.index;
        this.element = this.container(this.settings.axis);
        this.added = false;
        this.displayed = false;
        this.rendered = false;
        this.fixedWidth = 0;
        this.fixedHeight = 0;
        this.epubcfi = new _epubcfi.default();
        this.layout = this.settings.layout;
        this.pane = void 0;
        this.highlights = {};
        this.underlines = {};
        this.marks = {};
      }
      container(axis) {
        var element = document.createElement("div");
        element.classList.add("epub-view");
        element.style.height = "0px";
        element.style.width = "0px";
        element.style.overflow = "hidden";
        element.style.position = "relative";
        element.style.display = "block";
        if (axis && axis == "horizontal") {
          element.style.flex = "none";
        } else {
          element.style.flex = "initial";
        }
        return element;
      }
      create() {
        if (this.iframe) {
          return this.iframe;
        }
        if (!this.element) {
          this.element = this.createContainer();
        }
        this.iframe = document.createElement("iframe");
        this.iframe.id = this.id;
        this.iframe.scrolling = "no";
        this.iframe.style.overflow = "hidden";
        this.iframe.seamless = "seamless";
        this.iframe.style.border = "none";
        this.iframe.sandbox = "allow-same-origin";
        if (this.settings.allowScriptedContent) {
          this.iframe.sandbox += " allow-scripts";
        }
        if (this.settings.allowPopups) {
          this.iframe.sandbox += " allow-popups";
        }
        this.iframe.setAttribute("enable-annotation", "true");
        this.resizing = true;
        this.element.style.visibility = "hidden";
        this.iframe.style.visibility = "hidden";
        this.iframe.style.width = "0";
        this.iframe.style.height = "0";
        this._width = 0;
        this._height = 0;
        this.element.setAttribute("ref", this.index);
        this.added = true;
        this.elementBounds = (0, _core.bounds)(this.element);
        if ("srcdoc" in this.iframe) {
          this.supportsSrcdoc = true;
        } else {
          this.supportsSrcdoc = false;
        }
        if (!this.settings.method) {
          this.settings.method = this.supportsSrcdoc ? "srcdoc" : "write";
        }
        return this.iframe;
      }
      render(request, show) {
        this.create();
        this.size();
        if (!this.sectionRender) {
          this.sectionRender = this.section.render(request);
        }
        return this.sectionRender.then(function(contents) {
          return this.load(contents);
        }.bind(this)).then(function() {
          let writingMode = this.contents.writingMode();
          let axis;
          if (this.settings.flow === "scrolled") {
            axis = writingMode.indexOf("vertical") === 0 ? "horizontal" : "vertical";
          } else {
            axis = writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal";
          }
          if (writingMode.indexOf("vertical") === 0 && this.settings.flow === "paginated") {
            this.layout.delta = this.layout.height;
          }
          this.setAxis(axis);
          this.emit(_constants.EVENTS.VIEWS.AXIS, axis);
          this.setWritingMode(writingMode);
          this.emit(_constants.EVENTS.VIEWS.WRITING_MODE, writingMode);
          this.layout.format(this.contents, this.section, this.axis);
          this.addListeners();
          return new Promise((resolve, reject) => {
            this.expand();
            if (this.settings.forceRight) {
              this.element.style.marginLeft = this.width() + "px";
            }
            resolve();
          });
        }.bind(this), function(e3) {
          this.emit(_constants.EVENTS.VIEWS.LOAD_ERROR, e3);
          return new Promise((resolve, reject) => {
            reject(e3);
          });
        }.bind(this)).then(function() {
          this.emit(_constants.EVENTS.VIEWS.RENDERED, this.section);
        }.bind(this));
      }
      reset() {
        if (this.iframe) {
          this.iframe.style.width = "0";
          this.iframe.style.height = "0";
          this._width = 0;
          this._height = 0;
          this._textWidth = void 0;
          this._contentWidth = void 0;
          this._textHeight = void 0;
          this._contentHeight = void 0;
        }
        this._needsReframe = true;
      }
      size(_width, _height) {
        var width = _width || this.settings.width;
        var height = _height || this.settings.height;
        if (this.layout.name === "pre-paginated") {
          this.lock("both", width, height);
        } else if (this.settings.axis === "horizontal") {
          this.lock("height", width, height);
        } else {
          this.lock("width", width, height);
        }
        this.settings.width = width;
        this.settings.height = height;
      }
      lock(what, width, height) {
        var elBorders = (0, _core.borders)(this.element);
        var iframeBorders;
        if (this.iframe) {
          iframeBorders = (0, _core.borders)(this.iframe);
        } else {
          iframeBorders = {
            width: 0,
            height: 0
          };
        }
        if (what == "width" && (0, _core.isNumber)(width)) {
          this.lockedWidth = width - elBorders.width - iframeBorders.width;
        }
        if (what == "height" && (0, _core.isNumber)(height)) {
          this.lockedHeight = height - elBorders.height - iframeBorders.height;
        }
        if (what === "both" && (0, _core.isNumber)(width) && (0, _core.isNumber)(height)) {
          this.lockedWidth = width - elBorders.width - iframeBorders.width;
          this.lockedHeight = height - elBorders.height - iframeBorders.height;
        }
        if (this.displayed && this.iframe) {
          this.expand();
        }
      }
      expand(force) {
        var width = this.lockedWidth;
        var height = this.lockedHeight;
        var columns;
        var textWidth, textHeight;
        if (!this.iframe || this._expanding)
          return;
        this._expanding = true;
        if (this.layout.name === "pre-paginated") {
          width = this.layout.columnWidth;
          height = this.layout.height;
        } else if (this.settings.axis === "horizontal") {
          width = this.contents.textWidth();
          if (width % this.layout.pageWidth > 0) {
            width = Math.ceil(width / this.layout.pageWidth) * this.layout.pageWidth;
          }
          if (this.settings.forceEvenPages) {
            columns = width / this.layout.pageWidth;
            if (this.layout.divisor > 1 && this.layout.name === "reflowable" && columns % 2 > 0) {
              width += this.layout.pageWidth;
            }
          }
        } else if (this.settings.axis === "vertical") {
          height = this.contents.textHeight();
          if (this.settings.flow === "paginated" && height % this.layout.height > 0) {
            height = Math.ceil(height / this.layout.height) * this.layout.height;
          }
        }
        if (this._needsReframe || width != this._width || height != this._height) {
          this.reframe(width, height);
        }
        this._expanding = false;
      }
      reframe(width, height) {
        var size;
        if ((0, _core.isNumber)(width)) {
          this.element.style.width = width + "px";
          this.iframe.style.width = width + "px";
          this._width = width;
        }
        if ((0, _core.isNumber)(height)) {
          this.element.style.height = height + "px";
          this.iframe.style.height = height + "px";
          this._height = height;
        }
        let widthDelta = this.prevBounds ? width - this.prevBounds.width : width;
        let heightDelta = this.prevBounds ? height - this.prevBounds.height : height;
        size = {
          width,
          height,
          widthDelta,
          heightDelta
        };
        this.pane && this.pane.render();
        requestAnimationFrame(() => {
          let mark;
          for (let m3 in this.marks) {
            if (this.marks.hasOwnProperty(m3)) {
              mark = this.marks[m3];
              this.placeMark(mark.element, mark.range);
            }
          }
        });
        this.onResize(this, size);
        this.emit(_constants.EVENTS.VIEWS.RESIZED, size);
        this.prevBounds = size;
        this.elementBounds = (0, _core.bounds)(this.element);
      }
      load(contents) {
        var loading = new _core.defer();
        var loaded = loading.promise;
        if (!this.iframe) {
          loading.reject(new Error("No Iframe Available"));
          return loaded;
        }
        this.iframe.onload = function(event) {
          this.onLoad(event, loading);
        }.bind(this);
        if (this.settings.method === "blobUrl") {
          this.blobUrl = (0, _core.createBlobUrl)(contents, "application/xhtml+xml");
          this.iframe.src = this.blobUrl;
          this.element.appendChild(this.iframe);
        } else if (this.settings.method === "srcdoc") {
          this.iframe.srcdoc = contents;
          this.element.appendChild(this.iframe);
        } else {
          this.element.appendChild(this.iframe);
          this.document = this.iframe.contentDocument;
          if (!this.document) {
            loading.reject(new Error("No Document Available"));
            return loaded;
          }
          this.iframe.contentDocument.open();
          if (window.MSApp && MSApp.execUnsafeLocalFunction) {
            var outerThis = this;
            MSApp.execUnsafeLocalFunction(function() {
              outerThis.iframe.contentDocument.write(contents);
            });
          } else {
            this.iframe.contentDocument.write(contents);
          }
          this.iframe.contentDocument.close();
        }
        return loaded;
      }
      onLoad(event, promise) {
        this.window = this.iframe.contentWindow;
        this.document = this.iframe.contentDocument;
        this.contents = new _contents.default(this.document, this.document.body, this.section.cfiBase, this.section.index);
        this.rendering = false;
        var link = this.document.querySelector("link[rel='canonical']");
        if (link) {
          link.setAttribute("href", this.section.canonical);
        } else {
          link = this.document.createElement("link");
          link.setAttribute("rel", "canonical");
          link.setAttribute("href", this.section.canonical);
          this.document.querySelector("head").appendChild(link);
        }
        this.contents.on(_constants.EVENTS.CONTENTS.EXPAND, () => {
          if (this.displayed && this.iframe) {
            this.expand();
            if (this.contents) {
              this.layout.format(this.contents);
            }
          }
        });
        this.contents.on(_constants.EVENTS.CONTENTS.RESIZE, (e3) => {
          if (this.displayed && this.iframe) {
            this.expand();
            if (this.contents) {
              this.layout.format(this.contents);
            }
          }
        });
        promise.resolve(this.contents);
      }
      setLayout(layout) {
        this.layout = layout;
        if (this.contents) {
          this.layout.format(this.contents);
          this.expand();
        }
      }
      setAxis(axis) {
        this.settings.axis = axis;
        if (axis == "horizontal") {
          this.element.style.flex = "none";
        } else {
          this.element.style.flex = "initial";
        }
        this.size();
      }
      setWritingMode(mode) {
        this.writingMode = mode;
      }
      addListeners() {
      }
      removeListeners(layoutFunc) {
      }
      display(request) {
        var displayed = new _core.defer();
        if (!this.displayed) {
          this.render(request).then(function() {
            this.emit(_constants.EVENTS.VIEWS.DISPLAYED, this);
            this.onDisplayed(this);
            this.displayed = true;
            displayed.resolve(this);
          }.bind(this), function(err) {
            displayed.reject(err, this);
          });
        } else {
          displayed.resolve(this);
        }
        return displayed.promise;
      }
      show() {
        this.element.style.visibility = "visible";
        if (this.iframe) {
          this.iframe.style.visibility = "visible";
          this.iframe.style.transform = "translateZ(0)";
          this.iframe.offsetWidth;
          this.iframe.style.transform = null;
        }
        this.emit(_constants.EVENTS.VIEWS.SHOWN, this);
      }
      hide() {
        this.element.style.visibility = "hidden";
        this.iframe.style.visibility = "hidden";
        this.stopExpanding = true;
        this.emit(_constants.EVENTS.VIEWS.HIDDEN, this);
      }
      offset() {
        return {
          top: this.element.offsetTop,
          left: this.element.offsetLeft
        };
      }
      width() {
        return this._width;
      }
      height() {
        return this._height;
      }
      position() {
        return this.element.getBoundingClientRect();
      }
      locationOf(target) {
        var parentPos = this.iframe.getBoundingClientRect();
        var targetPos = this.contents.locationOf(target, this.settings.ignoreClass);
        return {
          "left": targetPos.left,
          "top": targetPos.top
        };
      }
      onDisplayed(view) {
      }
      onResize(view, e3) {
      }
      bounds(force) {
        if (force || !this.elementBounds) {
          this.elementBounds = (0, _core.bounds)(this.element);
        }
        return this.elementBounds;
      }
      highlight(cfiRange, data = {}, cb, className = "epubjs-hl", styles = {}) {
        if (!this.contents) {
          return;
        }
        const attributes = Object.assign({
          "fill": "yellow",
          "fill-opacity": "0.3",
          "mix-blend-mode": "multiply"
        }, styles);
        let range = this.contents.range(cfiRange);
        let emitter = () => {
          this.emit(_constants.EVENTS.VIEWS.MARK_CLICKED, cfiRange, data);
        };
        data["epubcfi"] = cfiRange;
        if (!this.pane) {
          this.pane = new _marksPane.Pane(this.iframe, this.element);
        }
        let m3 = new _marksPane.Highlight(range, className, data, attributes);
        let h3 = this.pane.addMark(m3);
        this.highlights[cfiRange] = {
          "mark": h3,
          "element": h3.element,
          "listeners": [emitter, cb]
        };
        h3.element.setAttribute("ref", className);
        h3.element.addEventListener("click", emitter);
        h3.element.addEventListener("touchstart", emitter);
        if (cb) {
          h3.element.addEventListener("click", cb);
          h3.element.addEventListener("touchstart", cb);
        }
        return h3;
      }
      underline(cfiRange, data = {}, cb, className = "epubjs-ul", styles = {}) {
        if (!this.contents) {
          return;
        }
        const attributes = Object.assign({
          "stroke": "black",
          "stroke-opacity": "0.3",
          "mix-blend-mode": "multiply"
        }, styles);
        let range = this.contents.range(cfiRange);
        let emitter = () => {
          this.emit(_constants.EVENTS.VIEWS.MARK_CLICKED, cfiRange, data);
        };
        data["epubcfi"] = cfiRange;
        if (!this.pane) {
          this.pane = new _marksPane.Pane(this.iframe, this.element);
        }
        let m3 = new _marksPane.Underline(range, className, data, attributes);
        let h3 = this.pane.addMark(m3);
        this.underlines[cfiRange] = {
          "mark": h3,
          "element": h3.element,
          "listeners": [emitter, cb]
        };
        h3.element.setAttribute("ref", className);
        h3.element.addEventListener("click", emitter);
        h3.element.addEventListener("touchstart", emitter);
        if (cb) {
          h3.element.addEventListener("click", cb);
          h3.element.addEventListener("touchstart", cb);
        }
        return h3;
      }
      mark(cfiRange, data = {}, cb) {
        if (!this.contents) {
          return;
        }
        if (cfiRange in this.marks) {
          let item = this.marks[cfiRange];
          return item;
        }
        let range = this.contents.range(cfiRange);
        if (!range) {
          return;
        }
        let container = range.commonAncestorContainer;
        let parent2 = container.nodeType === 1 ? container : container.parentNode;
        let emitter = (e3) => {
          this.emit(_constants.EVENTS.VIEWS.MARK_CLICKED, cfiRange, data);
        };
        if (range.collapsed && container.nodeType === 1) {
          range = new Range();
          range.selectNodeContents(container);
        } else if (range.collapsed) {
          range = new Range();
          range.selectNodeContents(parent2);
        }
        let mark = this.document.createElement("a");
        mark.setAttribute("ref", "epubjs-mk");
        mark.style.position = "absolute";
        mark.dataset["epubcfi"] = cfiRange;
        if (data) {
          Object.keys(data).forEach((key) => {
            mark.dataset[key] = data[key];
          });
        }
        if (cb) {
          mark.addEventListener("click", cb);
          mark.addEventListener("touchstart", cb);
        }
        mark.addEventListener("click", emitter);
        mark.addEventListener("touchstart", emitter);
        this.placeMark(mark, range);
        this.element.appendChild(mark);
        this.marks[cfiRange] = {
          "element": mark,
          "range": range,
          "listeners": [emitter, cb]
        };
        return parent2;
      }
      placeMark(element, range) {
        let top, right, left;
        if (this.layout.name === "pre-paginated" || this.settings.axis !== "horizontal") {
          let pos = range.getBoundingClientRect();
          top = pos.top;
          right = pos.right;
        } else {
          let rects = range.getClientRects();
          let rect;
          for (var i3 = 0; i3 != rects.length; i3++) {
            rect = rects[i3];
            if (!left || rect.left < left) {
              left = rect.left;
              right = Math.ceil(left / this.layout.props.pageWidth) * this.layout.props.pageWidth - this.layout.gap / 2;
              top = rect.top;
            }
          }
        }
        element.style.top = `${top}px`;
        element.style.left = `${right}px`;
      }
      unhighlight(cfiRange) {
        let item;
        if (cfiRange in this.highlights) {
          item = this.highlights[cfiRange];
          this.pane.removeMark(item.mark);
          item.listeners.forEach((l3) => {
            if (l3) {
              item.element.removeEventListener("click", l3);
              item.element.removeEventListener("touchstart", l3);
            }
            ;
          });
          delete this.highlights[cfiRange];
        }
      }
      ununderline(cfiRange) {
        let item;
        if (cfiRange in this.underlines) {
          item = this.underlines[cfiRange];
          this.pane.removeMark(item.mark);
          item.listeners.forEach((l3) => {
            if (l3) {
              item.element.removeEventListener("click", l3);
              item.element.removeEventListener("touchstart", l3);
            }
            ;
          });
          delete this.underlines[cfiRange];
        }
      }
      unmark(cfiRange) {
        let item;
        if (cfiRange in this.marks) {
          item = this.marks[cfiRange];
          this.element.removeChild(item.element);
          item.listeners.forEach((l3) => {
            if (l3) {
              item.element.removeEventListener("click", l3);
              item.element.removeEventListener("touchstart", l3);
            }
            ;
          });
          delete this.marks[cfiRange];
        }
      }
      destroy() {
        for (let cfiRange in this.highlights) {
          this.unhighlight(cfiRange);
        }
        for (let cfiRange in this.underlines) {
          this.ununderline(cfiRange);
        }
        for (let cfiRange in this.marks) {
          this.unmark(cfiRange);
        }
        if (this.blobUrl) {
          (0, _core.revokeBlobUrl)(this.blobUrl);
        }
        if (this.displayed) {
          this.displayed = false;
          this.removeListeners();
          this.contents.destroy();
          this.stopExpanding = true;
          this.element.removeChild(this.iframe);
          if (this.pane) {
            this.pane.element.remove();
            this.pane = void 0;
          }
          this.iframe = void 0;
          this.contents = void 0;
          this._textWidth = null;
          this._textHeight = null;
          this._width = null;
          this._height = null;
        }
      }
    };
    (0, _eventEmitter.default)(IframeView.prototype);
    var _default = IframeView;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/scrolltype.js
var require_scrolltype = __commonJS({
  "node_modules/epubjs/lib/utils/scrolltype.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createDefiner = createDefiner;
    exports.default = scrollType;
    function scrollType() {
      var type = "reverse";
      var definer = createDefiner();
      document.body.appendChild(definer);
      if (definer.scrollLeft > 0) {
        type = "default";
      } else {
        if (typeof Element !== "undefined" && Element.prototype.scrollIntoView) {
          definer.children[0].children[1].scrollIntoView();
          if (definer.scrollLeft < 0) {
            type = "negative";
          }
        } else {
          definer.scrollLeft = 1;
          if (definer.scrollLeft === 0) {
            type = "negative";
          }
        }
      }
      document.body.removeChild(definer);
      return type;
    }
    function createDefiner() {
      var definer = document.createElement("div");
      definer.dir = "rtl";
      definer.style.position = "fixed";
      definer.style.width = "1px";
      definer.style.height = "1px";
      definer.style.top = "0px";
      definer.style.left = "0px";
      definer.style.overflow = "hidden";
      var innerDiv = document.createElement("div");
      innerDiv.style.width = "2px";
      var spanA = document.createElement("span");
      spanA.style.width = "1px";
      spanA.style.display = "inline-block";
      var spanB = document.createElement("span");
      spanB.style.width = "1px";
      spanB.style.display = "inline-block";
      innerDiv.appendChild(spanA);
      innerDiv.appendChild(spanB);
      definer.appendChild(innerDiv);
      return definer;
    }
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module2) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// node_modules/lodash/now.js
var require_now = __commonJS({
  "node_modules/lodash/now.js"(exports, module2) {
    var root = require_root();
    var now = function() {
      return root.Date.now();
    };
    module2.exports = now;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports, module2) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module2.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports, module2) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module2.exports = baseTrim;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e3) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports, module2) {
    var baseTrim = require_baseTrim();
    var isObject = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = toNumber;
  }
});

// node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "node_modules/lodash/debounce.js"(exports, module2) {
    var isObject = require_isObject();
    var now = require_now();
    var toNumber = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    module2.exports = debounce;
  }
});

// node_modules/lodash/throttle.js
var require_throttle = __commonJS({
  "node_modules/lodash/throttle.js"(exports, module2) {
    var debounce = require_debounce();
    var isObject = require_isObject();
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    module2.exports = throttle;
  }
});

// node_modules/epubjs/lib/managers/helpers/stage.js
var require_stage = __commonJS({
  "node_modules/epubjs/lib/managers/helpers/stage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _throttle = _interopRequireDefault(require_throttle());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Stage = class {
      constructor(_options) {
        this.settings = _options || {};
        this.id = "epubjs-container-" + (0, _core.uuid)();
        this.container = this.create(this.settings);
        if (this.settings.hidden) {
          this.wrapper = this.wrap(this.container);
        }
      }
      create(options) {
        let height = options.height;
        let width = options.width;
        let overflow = options.overflow || false;
        let axis = options.axis || "vertical";
        let direction = options.direction;
        (0, _core.extend)(this.settings, options);
        if (options.height && (0, _core.isNumber)(options.height)) {
          height = options.height + "px";
        }
        if (options.width && (0, _core.isNumber)(options.width)) {
          width = options.width + "px";
        }
        let container = document.createElement("div");
        container.id = this.id;
        container.classList.add("epub-container");
        container.style.wordSpacing = "0";
        container.style.lineHeight = "0";
        container.style.verticalAlign = "top";
        container.style.position = "relative";
        if (axis === "horizontal") {
          container.style.display = "flex";
          container.style.flexDirection = "row";
          container.style.flexWrap = "nowrap";
        }
        if (width) {
          container.style.width = width;
        }
        if (height) {
          container.style.height = height;
        }
        if (overflow) {
          if (overflow === "scroll" && axis === "vertical") {
            container.style["overflow-y"] = overflow;
            container.style["overflow-x"] = "hidden";
          } else if (overflow === "scroll" && axis === "horizontal") {
            container.style["overflow-y"] = "hidden";
            container.style["overflow-x"] = overflow;
          } else {
            container.style["overflow"] = overflow;
          }
        }
        if (direction) {
          container.dir = direction;
          container.style["direction"] = direction;
        }
        if (direction && this.settings.fullsize) {
          document.body.style["direction"] = direction;
        }
        return container;
      }
      wrap(container) {
        var wrapper = document.createElement("div");
        wrapper.style.visibility = "hidden";
        wrapper.style.overflow = "hidden";
        wrapper.style.width = "0";
        wrapper.style.height = "0";
        wrapper.appendChild(container);
        return wrapper;
      }
      getElement(_element) {
        var element;
        if ((0, _core.isElement)(_element)) {
          element = _element;
        } else if (typeof _element === "string") {
          element = document.getElementById(_element);
        }
        if (!element) {
          throw new Error("Not an Element");
        }
        return element;
      }
      attachTo(what) {
        var element = this.getElement(what);
        var base;
        if (!element) {
          return;
        }
        if (this.settings.hidden) {
          base = this.wrapper;
        } else {
          base = this.container;
        }
        element.appendChild(base);
        this.element = element;
        return element;
      }
      getContainer() {
        return this.container;
      }
      onResize(func) {
        if (!(0, _core.isNumber)(this.settings.width) || !(0, _core.isNumber)(this.settings.height)) {
          this.resizeFunc = (0, _throttle.default)(func, 50);
          window.addEventListener("resize", this.resizeFunc, false);
        }
      }
      onOrientationChange(func) {
        this.orientationChangeFunc = func;
        window.addEventListener("orientationchange", this.orientationChangeFunc, false);
      }
      size(width, height) {
        var bounds;
        let _width = width || this.settings.width;
        let _height = height || this.settings.height;
        if (width === null) {
          bounds = this.element.getBoundingClientRect();
          if (bounds.width) {
            width = Math.floor(bounds.width);
            this.container.style.width = width + "px";
          }
        } else {
          if ((0, _core.isNumber)(width)) {
            this.container.style.width = width + "px";
          } else {
            this.container.style.width = width;
          }
        }
        if (height === null) {
          bounds = bounds || this.element.getBoundingClientRect();
          if (bounds.height) {
            height = bounds.height;
            this.container.style.height = height + "px";
          }
        } else {
          if ((0, _core.isNumber)(height)) {
            this.container.style.height = height + "px";
          } else {
            this.container.style.height = height;
          }
        }
        if (!(0, _core.isNumber)(width)) {
          width = this.container.clientWidth;
        }
        if (!(0, _core.isNumber)(height)) {
          height = this.container.clientHeight;
        }
        this.containerStyles = window.getComputedStyle(this.container);
        this.containerPadding = {
          left: parseFloat(this.containerStyles["padding-left"]) || 0,
          right: parseFloat(this.containerStyles["padding-right"]) || 0,
          top: parseFloat(this.containerStyles["padding-top"]) || 0,
          bottom: parseFloat(this.containerStyles["padding-bottom"]) || 0
        };
        let _windowBounds = (0, _core.windowBounds)();
        let bodyStyles = window.getComputedStyle(document.body);
        let bodyPadding = {
          left: parseFloat(bodyStyles["padding-left"]) || 0,
          right: parseFloat(bodyStyles["padding-right"]) || 0,
          top: parseFloat(bodyStyles["padding-top"]) || 0,
          bottom: parseFloat(bodyStyles["padding-bottom"]) || 0
        };
        if (!_width) {
          width = _windowBounds.width - bodyPadding.left - bodyPadding.right;
        }
        if (this.settings.fullsize && !_height || !_height) {
          height = _windowBounds.height - bodyPadding.top - bodyPadding.bottom;
        }
        return {
          width: width - this.containerPadding.left - this.containerPadding.right,
          height: height - this.containerPadding.top - this.containerPadding.bottom
        };
      }
      bounds() {
        let box;
        if (this.container.style.overflow !== "visible") {
          box = this.container && this.container.getBoundingClientRect();
        }
        if (!box || !box.width || !box.height) {
          return (0, _core.windowBounds)();
        } else {
          return box;
        }
      }
      getSheet() {
        var style = document.createElement("style");
        style.appendChild(document.createTextNode(""));
        document.head.appendChild(style);
        return style.sheet;
      }
      addStyleRules(selector, rulesArray) {
        var scope = "#" + this.id + " ";
        var rules = "";
        if (!this.sheet) {
          this.sheet = this.getSheet();
        }
        rulesArray.forEach(function(set) {
          for (var prop in set) {
            if (set.hasOwnProperty(prop)) {
              rules += prop + ":" + set[prop] + ";";
            }
          }
        });
        this.sheet.insertRule(scope + selector + " {" + rules + "}", 0);
      }
      axis(axis) {
        if (axis === "horizontal") {
          this.container.style.display = "flex";
          this.container.style.flexDirection = "row";
          this.container.style.flexWrap = "nowrap";
        } else {
          this.container.style.display = "block";
        }
        this.settings.axis = axis;
      }
      direction(dir) {
        if (this.container) {
          this.container.dir = dir;
          this.container.style["direction"] = dir;
        }
        if (this.settings.fullsize) {
          document.body.style["direction"] = dir;
        }
        this.settings.dir = dir;
      }
      overflow(overflow) {
        if (this.container) {
          if (overflow === "scroll" && this.settings.axis === "vertical") {
            this.container.style["overflow-y"] = overflow;
            this.container.style["overflow-x"] = "hidden";
          } else if (overflow === "scroll" && this.settings.axis === "horizontal") {
            this.container.style["overflow-y"] = "hidden";
            this.container.style["overflow-x"] = overflow;
          } else {
            this.container.style["overflow"] = overflow;
          }
        }
        this.settings.overflow = overflow;
      }
      destroy() {
        var base;
        if (this.element) {
          if (this.settings.hidden) {
            base = this.wrapper;
          } else {
            base = this.container;
          }
          if (this.element.contains(this.container)) {
            this.element.removeChild(this.container);
          }
          window.removeEventListener("resize", this.resizeFunc);
          window.removeEventListener("orientationChange", this.orientationChangeFunc);
        }
      }
    };
    var _default = Stage;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/managers/helpers/views.js
var require_views = __commonJS({
  "node_modules/epubjs/lib/managers/helpers/views.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Views = class {
      constructor(container) {
        this.container = container;
        this._views = [];
        this.length = 0;
        this.hidden = false;
      }
      all() {
        return this._views;
      }
      first() {
        return this._views[0];
      }
      last() {
        return this._views[this._views.length - 1];
      }
      indexOf(view) {
        return this._views.indexOf(view);
      }
      slice() {
        return this._views.slice.apply(this._views, arguments);
      }
      get(i3) {
        return this._views[i3];
      }
      append(view) {
        this._views.push(view);
        if (this.container) {
          this.container.appendChild(view.element);
        }
        this.length++;
        return view;
      }
      prepend(view) {
        this._views.unshift(view);
        if (this.container) {
          this.container.insertBefore(view.element, this.container.firstChild);
        }
        this.length++;
        return view;
      }
      insert(view, index) {
        this._views.splice(index, 0, view);
        if (this.container) {
          if (index < this.container.children.length) {
            this.container.insertBefore(view.element, this.container.children[index]);
          } else {
            this.container.appendChild(view.element);
          }
        }
        this.length++;
        return view;
      }
      remove(view) {
        var index = this._views.indexOf(view);
        if (index > -1) {
          this._views.splice(index, 1);
        }
        this.destroy(view);
        this.length--;
      }
      destroy(view) {
        if (view.displayed) {
          view.destroy();
        }
        if (this.container) {
          this.container.removeChild(view.element);
        }
        view = null;
      }
      forEach() {
        return this._views.forEach.apply(this._views, arguments);
      }
      clear() {
        var view;
        var len = this.length;
        if (!this.length)
          return;
        for (var i3 = 0; i3 < len; i3++) {
          view = this._views[i3];
          this.destroy(view);
        }
        this._views = [];
        this.length = 0;
      }
      find(section) {
        var view;
        var len = this.length;
        for (var i3 = 0; i3 < len; i3++) {
          view = this._views[i3];
          if (view.displayed && view.section.index == section.index) {
            return view;
          }
        }
      }
      displayed() {
        var displayed = [];
        var view;
        var len = this.length;
        for (var i3 = 0; i3 < len; i3++) {
          view = this._views[i3];
          if (view.displayed) {
            displayed.push(view);
          }
        }
        return displayed;
      }
      show() {
        var view;
        var len = this.length;
        for (var i3 = 0; i3 < len; i3++) {
          view = this._views[i3];
          if (view.displayed) {
            view.show();
          }
        }
        this.hidden = false;
      }
      hide() {
        var view;
        var len = this.length;
        for (var i3 = 0; i3 < len; i3++) {
          view = this._views[i3];
          if (view.displayed) {
            view.hide();
          }
        }
        this.hidden = true;
      }
    };
    var _default = Views;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/managers/default/index.js
var require_default = __commonJS({
  "node_modules/epubjs/lib/managers/default/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _core = require_core();
    var _scrolltype = _interopRequireDefault(require_scrolltype());
    var _mapping = _interopRequireDefault(require_mapping());
    var _queue = _interopRequireDefault(require_queue());
    var _stage = _interopRequireDefault(require_stage());
    var _views = _interopRequireDefault(require_views());
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DefaultViewManager = class {
      constructor(options) {
        this.name = "default";
        this.optsSettings = options.settings;
        this.View = options.view;
        this.request = options.request;
        this.renditionQueue = options.queue;
        this.q = new _queue.default(this);
        this.settings = (0, _core.extend)(this.settings || {}, {
          infinite: true,
          hidden: false,
          width: void 0,
          height: void 0,
          axis: void 0,
          writingMode: void 0,
          flow: "scrolled",
          ignoreClass: "",
          fullsize: void 0,
          allowScriptedContent: false,
          allowPopups: false
        });
        (0, _core.extend)(this.settings, options.settings || {});
        this.viewSettings = {
          ignoreClass: this.settings.ignoreClass,
          axis: this.settings.axis,
          flow: this.settings.flow,
          layout: this.layout,
          method: this.settings.method,
          width: 0,
          height: 0,
          forceEvenPages: true,
          allowScriptedContent: this.settings.allowScriptedContent,
          allowPopups: this.settings.allowPopups
        };
        this.rendered = false;
      }
      render(element, size) {
        let tag = element.tagName;
        if (typeof this.settings.fullsize === "undefined" && tag && (tag.toLowerCase() == "body" || tag.toLowerCase() == "html")) {
          this.settings.fullsize = true;
        }
        if (this.settings.fullsize) {
          this.settings.overflow = "visible";
          this.overflow = this.settings.overflow;
        }
        this.settings.size = size;
        this.settings.rtlScrollType = (0, _scrolltype.default)();
        this.stage = new _stage.default({
          width: size.width,
          height: size.height,
          overflow: this.overflow,
          hidden: this.settings.hidden,
          axis: this.settings.axis,
          fullsize: this.settings.fullsize,
          direction: this.settings.direction
        });
        this.stage.attachTo(element);
        this.container = this.stage.getContainer();
        this.views = new _views.default(this.container);
        this._bounds = this.bounds();
        this._stageSize = this.stage.size();
        this.viewSettings.width = this._stageSize.width;
        this.viewSettings.height = this._stageSize.height;
        this.stage.onResize(this.onResized.bind(this));
        this.stage.onOrientationChange(this.onOrientationChange.bind(this));
        this.addEventListeners();
        if (this.layout) {
          this.updateLayout();
        }
        this.rendered = true;
      }
      addEventListeners() {
        var scroller;
        window.addEventListener("unload", function(e3) {
          this.destroy();
        }.bind(this));
        if (!this.settings.fullsize) {
          scroller = this.container;
        } else {
          scroller = window;
        }
        this._onScroll = this.onScroll.bind(this);
        scroller.addEventListener("scroll", this._onScroll);
      }
      removeEventListeners() {
        var scroller;
        if (!this.settings.fullsize) {
          scroller = this.container;
        } else {
          scroller = window;
        }
        scroller.removeEventListener("scroll", this._onScroll);
        this._onScroll = void 0;
      }
      destroy() {
        clearTimeout(this.orientationTimeout);
        clearTimeout(this.resizeTimeout);
        clearTimeout(this.afterScrolled);
        this.clear();
        this.removeEventListeners();
        this.stage.destroy();
        this.rendered = false;
      }
      onOrientationChange(e3) {
        let {
          orientation
        } = window;
        if (this.optsSettings.resizeOnOrientationChange) {
          this.resize();
        }
        clearTimeout(this.orientationTimeout);
        this.orientationTimeout = setTimeout(function() {
          this.orientationTimeout = void 0;
          if (this.optsSettings.resizeOnOrientationChange) {
            this.resize();
          }
          this.emit(_constants.EVENTS.MANAGERS.ORIENTATION_CHANGE, orientation);
        }.bind(this), 500);
      }
      onResized(e3) {
        this.resize();
      }
      resize(width, height, epubcfi) {
        let stageSize = this.stage.size(width, height);
        this.winBounds = (0, _core.windowBounds)();
        if (this.orientationTimeout && this.winBounds.width === this.winBounds.height) {
          this._stageSize = void 0;
          return;
        }
        if (this._stageSize && this._stageSize.width === stageSize.width && this._stageSize.height === stageSize.height) {
          return;
        }
        this._stageSize = stageSize;
        this._bounds = this.bounds();
        this.clear();
        this.viewSettings.width = this._stageSize.width;
        this.viewSettings.height = this._stageSize.height;
        this.updateLayout();
        this.emit(_constants.EVENTS.MANAGERS.RESIZED, {
          width: this._stageSize.width,
          height: this._stageSize.height
        }, epubcfi);
      }
      createView(section, forceRight) {
        return new this.View(section, (0, _core.extend)(this.viewSettings, {
          forceRight
        }));
      }
      handleNextPrePaginated(forceRight, section, action) {
        let next;
        if (this.layout.name === "pre-paginated" && this.layout.divisor > 1) {
          if (forceRight || section.index === 0) {
            return;
          }
          next = section.next();
          if (next && !next.properties.includes("page-spread-left")) {
            return action.call(this, next);
          }
        }
      }
      display(section, target) {
        var displaying = new _core.defer();
        var displayed = displaying.promise;
        if (target === section.href || (0, _core.isNumber)(target)) {
          target = void 0;
        }
        var visible = this.views.find(section);
        if (visible && section && this.layout.name !== "pre-paginated") {
          let offset = visible.offset();
          if (this.settings.direction === "ltr") {
            this.scrollTo(offset.left, offset.top, true);
          } else {
            let width = visible.width();
            this.scrollTo(offset.left + width, offset.top, true);
          }
          if (target) {
            let offset2 = visible.locationOf(target);
            let width = visible.width();
            this.moveTo(offset2, width);
          }
          displaying.resolve();
          return displayed;
        }
        this.clear();
        let forceRight = false;
        if (this.layout.name === "pre-paginated" && this.layout.divisor === 2 && section.properties.includes("page-spread-right")) {
          forceRight = true;
        }
        this.add(section, forceRight).then(function(view) {
          if (target) {
            let offset = view.locationOf(target);
            let width = view.width();
            this.moveTo(offset, width);
          }
        }.bind(this), (err) => {
          displaying.reject(err);
        }).then(function() {
          return this.handleNextPrePaginated(forceRight, section, this.add);
        }.bind(this)).then(function() {
          this.views.show();
          displaying.resolve();
        }.bind(this));
        return displayed;
      }
      afterDisplayed(view) {
        this.emit(_constants.EVENTS.MANAGERS.ADDED, view);
      }
      afterResized(view) {
        this.emit(_constants.EVENTS.MANAGERS.RESIZE, view.section);
      }
      moveTo(offset, width) {
        var distX = 0, distY = 0;
        if (!this.isPaginated) {
          distY = offset.top;
        } else {
          distX = Math.floor(offset.left / this.layout.delta) * this.layout.delta;
          if (distX + this.layout.delta > this.container.scrollWidth) {
            distX = this.container.scrollWidth - this.layout.delta;
          }
          distY = Math.floor(offset.top / this.layout.delta) * this.layout.delta;
          if (distY + this.layout.delta > this.container.scrollHeight) {
            distY = this.container.scrollHeight - this.layout.delta;
          }
        }
        if (this.settings.direction === "rtl") {
          distX = distX + this.layout.delta;
          distX = distX - width;
        }
        this.scrollTo(distX, distY, true);
      }
      add(section, forceRight) {
        var view = this.createView(section, forceRight);
        this.views.append(view);
        view.onDisplayed = this.afterDisplayed.bind(this);
        view.onResize = this.afterResized.bind(this);
        view.on(_constants.EVENTS.VIEWS.AXIS, (axis) => {
          this.updateAxis(axis);
        });
        view.on(_constants.EVENTS.VIEWS.WRITING_MODE, (mode) => {
          this.updateWritingMode(mode);
        });
        return view.display(this.request);
      }
      append(section, forceRight) {
        var view = this.createView(section, forceRight);
        this.views.append(view);
        view.onDisplayed = this.afterDisplayed.bind(this);
        view.onResize = this.afterResized.bind(this);
        view.on(_constants.EVENTS.VIEWS.AXIS, (axis) => {
          this.updateAxis(axis);
        });
        view.on(_constants.EVENTS.VIEWS.WRITING_MODE, (mode) => {
          this.updateWritingMode(mode);
        });
        return view.display(this.request);
      }
      prepend(section, forceRight) {
        var view = this.createView(section, forceRight);
        view.on(_constants.EVENTS.VIEWS.RESIZED, (bounds) => {
          this.counter(bounds);
        });
        this.views.prepend(view);
        view.onDisplayed = this.afterDisplayed.bind(this);
        view.onResize = this.afterResized.bind(this);
        view.on(_constants.EVENTS.VIEWS.AXIS, (axis) => {
          this.updateAxis(axis);
        });
        view.on(_constants.EVENTS.VIEWS.WRITING_MODE, (mode) => {
          this.updateWritingMode(mode);
        });
        return view.display(this.request);
      }
      counter(bounds) {
        if (this.settings.axis === "vertical") {
          this.scrollBy(0, bounds.heightDelta, true);
        } else {
          this.scrollBy(bounds.widthDelta, 0, true);
        }
      }
      next() {
        var next;
        var left;
        let dir = this.settings.direction;
        if (!this.views.length)
          return;
        if (this.isPaginated && this.settings.axis === "horizontal" && (!dir || dir === "ltr")) {
          this.scrollLeft = this.container.scrollLeft;
          left = this.container.scrollLeft + this.container.offsetWidth + this.layout.delta;
          if (left <= this.container.scrollWidth) {
            this.scrollBy(this.layout.delta, 0, true);
          } else {
            next = this.views.last().section.next();
          }
        } else if (this.isPaginated && this.settings.axis === "horizontal" && dir === "rtl") {
          this.scrollLeft = this.container.scrollLeft;
          if (this.settings.rtlScrollType === "default") {
            left = this.container.scrollLeft;
            if (left > 0) {
              this.scrollBy(this.layout.delta, 0, true);
            } else {
              next = this.views.last().section.next();
            }
          } else {
            left = this.container.scrollLeft + this.layout.delta * -1;
            if (left > this.container.scrollWidth * -1) {
              this.scrollBy(this.layout.delta, 0, true);
            } else {
              next = this.views.last().section.next();
            }
          }
        } else if (this.isPaginated && this.settings.axis === "vertical") {
          this.scrollTop = this.container.scrollTop;
          let top = this.container.scrollTop + this.container.offsetHeight;
          if (top < this.container.scrollHeight) {
            this.scrollBy(0, this.layout.height, true);
          } else {
            next = this.views.last().section.next();
          }
        } else {
          next = this.views.last().section.next();
        }
        if (next) {
          this.clear();
          this.updateLayout();
          let forceRight = false;
          if (this.layout.name === "pre-paginated" && this.layout.divisor === 2 && next.properties.includes("page-spread-right")) {
            forceRight = true;
          }
          return this.append(next, forceRight).then(function() {
            return this.handleNextPrePaginated(forceRight, next, this.append);
          }.bind(this), (err) => {
            return err;
          }).then(function() {
            if (!this.isPaginated && this.settings.axis === "horizontal" && this.settings.direction === "rtl" && this.settings.rtlScrollType === "default") {
              this.scrollTo(this.container.scrollWidth, 0, true);
            }
            this.views.show();
          }.bind(this));
        }
      }
      prev() {
        var prev;
        var left;
        let dir = this.settings.direction;
        if (!this.views.length)
          return;
        if (this.isPaginated && this.settings.axis === "horizontal" && (!dir || dir === "ltr")) {
          this.scrollLeft = this.container.scrollLeft;
          left = this.container.scrollLeft;
          if (left > 0) {
            this.scrollBy(-this.layout.delta, 0, true);
          } else {
            prev = this.views.first().section.prev();
          }
        } else if (this.isPaginated && this.settings.axis === "horizontal" && dir === "rtl") {
          this.scrollLeft = this.container.scrollLeft;
          if (this.settings.rtlScrollType === "default") {
            left = this.container.scrollLeft + this.container.offsetWidth;
            if (left < this.container.scrollWidth) {
              this.scrollBy(-this.layout.delta, 0, true);
            } else {
              prev = this.views.first().section.prev();
            }
          } else {
            left = this.container.scrollLeft;
            if (left < 0) {
              this.scrollBy(-this.layout.delta, 0, true);
            } else {
              prev = this.views.first().section.prev();
            }
          }
        } else if (this.isPaginated && this.settings.axis === "vertical") {
          this.scrollTop = this.container.scrollTop;
          let top = this.container.scrollTop;
          if (top > 0) {
            this.scrollBy(0, -this.layout.height, true);
          } else {
            prev = this.views.first().section.prev();
          }
        } else {
          prev = this.views.first().section.prev();
        }
        if (prev) {
          this.clear();
          this.updateLayout();
          let forceRight = false;
          if (this.layout.name === "pre-paginated" && this.layout.divisor === 2 && typeof prev.prev() !== "object") {
            forceRight = true;
          }
          return this.prepend(prev, forceRight).then(function() {
            var left2;
            if (this.layout.name === "pre-paginated" && this.layout.divisor > 1) {
              left2 = prev.prev();
              if (left2) {
                return this.prepend(left2);
              }
            }
          }.bind(this), (err) => {
            return err;
          }).then(function() {
            if (this.isPaginated && this.settings.axis === "horizontal") {
              if (this.settings.direction === "rtl") {
                if (this.settings.rtlScrollType === "default") {
                  this.scrollTo(0, 0, true);
                } else {
                  this.scrollTo(this.container.scrollWidth * -1 + this.layout.delta, 0, true);
                }
              } else {
                this.scrollTo(this.container.scrollWidth - this.layout.delta, 0, true);
              }
            }
            this.views.show();
          }.bind(this));
        }
      }
      current() {
        var visible = this.visible();
        if (visible.length) {
          return visible[visible.length - 1];
        }
        return null;
      }
      clear() {
        if (this.views) {
          this.views.hide();
          this.scrollTo(0, 0, true);
          this.views.clear();
        }
      }
      currentLocation() {
        this.updateLayout();
        if (this.isPaginated && this.settings.axis === "horizontal") {
          this.location = this.paginatedLocation();
        } else {
          this.location = this.scrolledLocation();
        }
        return this.location;
      }
      scrolledLocation() {
        let visible = this.visible();
        let container = this.container.getBoundingClientRect();
        let pageHeight = container.height < window.innerHeight ? container.height : window.innerHeight;
        let pageWidth = container.width < window.innerWidth ? container.width : window.innerWidth;
        let vertical = this.settings.axis === "vertical";
        let rtl = this.settings.direction === "rtl";
        let offset = 0;
        let used = 0;
        if (this.settings.fullsize) {
          offset = vertical ? window.scrollY : window.scrollX;
        }
        let sections = visible.map((view) => {
          let {
            index,
            href
          } = view.section;
          let position = view.position();
          let width = view.width();
          let height = view.height();
          let startPos;
          let endPos;
          let stopPos;
          let totalPages;
          if (vertical) {
            startPos = offset + container.top - position.top + used;
            endPos = startPos + pageHeight - used;
            totalPages = this.layout.count(height, pageHeight).pages;
            stopPos = pageHeight;
          } else {
            startPos = offset + container.left - position.left + used;
            endPos = startPos + pageWidth - used;
            totalPages = this.layout.count(width, pageWidth).pages;
            stopPos = pageWidth;
          }
          let currPage = Math.ceil(startPos / stopPos);
          let pages = [];
          let endPage = Math.ceil(endPos / stopPos);
          if (this.settings.direction === "rtl" && !vertical) {
            let tempStartPage = currPage;
            currPage = totalPages - endPage;
            endPage = totalPages - tempStartPage;
          }
          pages = [];
          for (var i3 = currPage; i3 <= endPage; i3++) {
            let pg = i3 + 1;
            pages.push(pg);
          }
          let mapping = this.mapping.page(view.contents, view.section.cfiBase, startPos, endPos);
          return {
            index,
            href,
            pages,
            totalPages,
            mapping
          };
        });
        return sections;
      }
      paginatedLocation() {
        let visible = this.visible();
        let container = this.container.getBoundingClientRect();
        let left = 0;
        let used = 0;
        if (this.settings.fullsize) {
          left = window.scrollX;
        }
        let sections = visible.map((view) => {
          let {
            index,
            href
          } = view.section;
          let offset;
          let position = view.position();
          let width = view.width();
          let start;
          let end;
          let pageWidth;
          if (this.settings.direction === "rtl") {
            offset = container.right - left;
            pageWidth = Math.min(Math.abs(offset - position.left), this.layout.width) - used;
            end = position.width - (position.right - offset) - used;
            start = end - pageWidth;
          } else {
            offset = container.left + left;
            pageWidth = Math.min(position.right - offset, this.layout.width) - used;
            start = offset - position.left + used;
            end = start + pageWidth;
          }
          used += pageWidth;
          let mapping = this.mapping.page(view.contents, view.section.cfiBase, start, end);
          let totalPages = this.layout.count(width).pages;
          let startPage = Math.floor(start / this.layout.pageWidth);
          let pages = [];
          let endPage = Math.floor(end / this.layout.pageWidth);
          if (startPage < 0) {
            startPage = 0;
            endPage = endPage + 1;
          }
          if (this.settings.direction === "rtl") {
            let tempStartPage = startPage;
            startPage = totalPages - endPage;
            endPage = totalPages - tempStartPage;
          }
          for (var i3 = startPage + 1; i3 <= endPage; i3++) {
            let pg = i3;
            pages.push(pg);
          }
          return {
            index,
            href,
            pages,
            totalPages,
            mapping
          };
        });
        return sections;
      }
      isVisible(view, offsetPrev, offsetNext, _container) {
        var position = view.position();
        var container = _container || this.bounds();
        if (this.settings.axis === "horizontal" && position.right > container.left - offsetPrev && position.left < container.right + offsetNext) {
          return true;
        } else if (this.settings.axis === "vertical" && position.bottom > container.top - offsetPrev && position.top < container.bottom + offsetNext) {
          return true;
        }
        return false;
      }
      visible() {
        var container = this.bounds();
        var views = this.views.displayed();
        var viewsLength = views.length;
        var visible = [];
        var isVisible;
        var view;
        for (var i3 = 0; i3 < viewsLength; i3++) {
          view = views[i3];
          isVisible = this.isVisible(view, 0, 0, container);
          if (isVisible === true) {
            visible.push(view);
          }
        }
        return visible;
      }
      scrollBy(x4, y3, silent) {
        let dir = this.settings.direction === "rtl" ? -1 : 1;
        if (silent) {
          this.ignore = true;
        }
        if (!this.settings.fullsize) {
          if (x4)
            this.container.scrollLeft += x4 * dir;
          if (y3)
            this.container.scrollTop += y3;
        } else {
          window.scrollBy(x4 * dir, y3 * dir);
        }
        this.scrolled = true;
      }
      scrollTo(x4, y3, silent) {
        if (silent) {
          this.ignore = true;
        }
        if (!this.settings.fullsize) {
          this.container.scrollLeft = x4;
          this.container.scrollTop = y3;
        } else {
          window.scrollTo(x4, y3);
        }
        this.scrolled = true;
      }
      onScroll() {
        let scrollTop;
        let scrollLeft;
        if (!this.settings.fullsize) {
          scrollTop = this.container.scrollTop;
          scrollLeft = this.container.scrollLeft;
        } else {
          scrollTop = window.scrollY;
          scrollLeft = window.scrollX;
        }
        this.scrollTop = scrollTop;
        this.scrollLeft = scrollLeft;
        if (!this.ignore) {
          this.emit(_constants.EVENTS.MANAGERS.SCROLL, {
            top: scrollTop,
            left: scrollLeft
          });
          clearTimeout(this.afterScrolled);
          this.afterScrolled = setTimeout(function() {
            this.emit(_constants.EVENTS.MANAGERS.SCROLLED, {
              top: this.scrollTop,
              left: this.scrollLeft
            });
          }.bind(this), 20);
        } else {
          this.ignore = false;
        }
      }
      bounds() {
        var bounds;
        bounds = this.stage.bounds();
        return bounds;
      }
      applyLayout(layout) {
        this.layout = layout;
        this.updateLayout();
        if (this.views && this.views.length > 0 && this.layout.name === "pre-paginated") {
          this.display(this.views.first().section);
        }
      }
      updateLayout() {
        if (!this.stage) {
          return;
        }
        this._stageSize = this.stage.size();
        if (!this.isPaginated) {
          this.layout.calculate(this._stageSize.width, this._stageSize.height);
        } else {
          this.layout.calculate(this._stageSize.width, this._stageSize.height, this.settings.gap);
          this.settings.offset = this.layout.delta / this.layout.divisor;
        }
        this.viewSettings.width = this.layout.width;
        this.viewSettings.height = this.layout.height;
        this.setLayout(this.layout);
      }
      setLayout(layout) {
        this.viewSettings.layout = layout;
        this.mapping = new _mapping.default(layout.props, this.settings.direction, this.settings.axis);
        if (this.views) {
          this.views.forEach(function(view) {
            if (view) {
              view.setLayout(layout);
            }
          });
        }
      }
      updateWritingMode(mode) {
        this.writingMode = mode;
      }
      updateAxis(axis, forceUpdate) {
        if (!forceUpdate && axis === this.settings.axis) {
          return;
        }
        this.settings.axis = axis;
        this.stage && this.stage.axis(axis);
        this.viewSettings.axis = axis;
        if (this.mapping) {
          this.mapping = new _mapping.default(this.layout.props, this.settings.direction, this.settings.axis);
        }
        if (this.layout) {
          if (axis === "vertical") {
            this.layout.spread("none");
          } else {
            this.layout.spread(this.layout.settings.spread);
          }
        }
      }
      updateFlow(flow, defaultScrolledOverflow = "auto") {
        let isPaginated = flow === "paginated" || flow === "auto";
        this.isPaginated = isPaginated;
        if (flow === "scrolled-doc" || flow === "scrolled-continuous" || flow === "scrolled") {
          this.updateAxis("vertical");
        } else {
          this.updateAxis("horizontal");
        }
        this.viewSettings.flow = flow;
        if (!this.settings.overflow) {
          this.overflow = isPaginated ? "hidden" : defaultScrolledOverflow;
        } else {
          this.overflow = this.settings.overflow;
        }
        this.stage && this.stage.overflow(this.overflow);
        this.updateLayout();
      }
      getContents() {
        var contents = [];
        if (!this.views) {
          return contents;
        }
        this.views.forEach(function(view) {
          const viewContents = view && view.contents;
          if (viewContents) {
            contents.push(viewContents);
          }
        });
        return contents;
      }
      direction(dir = "ltr") {
        this.settings.direction = dir;
        this.stage && this.stage.direction(dir);
        this.viewSettings.direction = dir;
        this.updateLayout();
      }
      isRendered() {
        return this.rendered;
      }
    };
    (0, _eventEmitter.default)(DefaultViewManager.prototype);
    var _default = DefaultViewManager;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/managers/helpers/snap.js
var require_snap = __commonJS({
  "node_modules/epubjs/lib/managers/helpers/snap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _constants = require_constants();
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var PI_D2 = Math.PI / 2;
    var EASING_EQUATIONS = {
      easeOutSine: function(pos) {
        return Math.sin(pos * PI_D2);
      },
      easeInOutSine: function(pos) {
        return -0.5 * (Math.cos(Math.PI * pos) - 1);
      },
      easeInOutQuint: function(pos) {
        if ((pos /= 0.5) < 1) {
          return 0.5 * Math.pow(pos, 5);
        }
        return 0.5 * (Math.pow(pos - 2, 5) + 2);
      },
      easeInCubic: function(pos) {
        return Math.pow(pos, 3);
      }
    };
    var Snap = class {
      constructor(manager, options) {
        this.settings = (0, _core.extend)({
          duration: 80,
          minVelocity: 0.2,
          minDistance: 10,
          easing: EASING_EQUATIONS["easeInCubic"]
        }, options || {});
        this.supportsTouch = this.supportsTouch();
        if (this.supportsTouch) {
          this.setup(manager);
        }
      }
      setup(manager) {
        this.manager = manager;
        this.layout = this.manager.layout;
        this.fullsize = this.manager.settings.fullsize;
        if (this.fullsize) {
          this.element = this.manager.stage.element;
          this.scroller = window;
          this.disableScroll();
        } else {
          this.element = this.manager.stage.container;
          this.scroller = this.element;
          this.element.style["WebkitOverflowScrolling"] = "touch";
        }
        this.manager.settings.offset = this.layout.width;
        this.manager.settings.afterScrolledTimeout = this.settings.duration * 2;
        this.isVertical = this.manager.settings.axis === "vertical";
        if (!this.manager.isPaginated || this.isVertical) {
          return;
        }
        this.touchCanceler = false;
        this.resizeCanceler = false;
        this.snapping = false;
        this.scrollLeft;
        this.scrollTop;
        this.startTouchX = void 0;
        this.startTouchY = void 0;
        this.startTime = void 0;
        this.endTouchX = void 0;
        this.endTouchY = void 0;
        this.endTime = void 0;
        this.addListeners();
      }
      supportsTouch() {
        if ("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch) {
          return true;
        }
        return false;
      }
      disableScroll() {
        this.element.style.overflow = "hidden";
      }
      enableScroll() {
        this.element.style.overflow = "";
      }
      addListeners() {
        this._onResize = this.onResize.bind(this);
        window.addEventListener("resize", this._onResize);
        this._onScroll = this.onScroll.bind(this);
        this.scroller.addEventListener("scroll", this._onScroll);
        this._onTouchStart = this.onTouchStart.bind(this);
        this.scroller.addEventListener("touchstart", this._onTouchStart, {
          passive: true
        });
        this.on("touchstart", this._onTouchStart);
        this._onTouchMove = this.onTouchMove.bind(this);
        this.scroller.addEventListener("touchmove", this._onTouchMove, {
          passive: true
        });
        this.on("touchmove", this._onTouchMove);
        this._onTouchEnd = this.onTouchEnd.bind(this);
        this.scroller.addEventListener("touchend", this._onTouchEnd, {
          passive: true
        });
        this.on("touchend", this._onTouchEnd);
        this._afterDisplayed = this.afterDisplayed.bind(this);
        this.manager.on(_constants.EVENTS.MANAGERS.ADDED, this._afterDisplayed);
      }
      removeListeners() {
        window.removeEventListener("resize", this._onResize);
        this._onResize = void 0;
        this.scroller.removeEventListener("scroll", this._onScroll);
        this._onScroll = void 0;
        this.scroller.removeEventListener("touchstart", this._onTouchStart, {
          passive: true
        });
        this.off("touchstart", this._onTouchStart);
        this._onTouchStart = void 0;
        this.scroller.removeEventListener("touchmove", this._onTouchMove, {
          passive: true
        });
        this.off("touchmove", this._onTouchMove);
        this._onTouchMove = void 0;
        this.scroller.removeEventListener("touchend", this._onTouchEnd, {
          passive: true
        });
        this.off("touchend", this._onTouchEnd);
        this._onTouchEnd = void 0;
        this.manager.off(_constants.EVENTS.MANAGERS.ADDED, this._afterDisplayed);
        this._afterDisplayed = void 0;
      }
      afterDisplayed(view) {
        let contents = view.contents;
        ["touchstart", "touchmove", "touchend"].forEach((e3) => {
          contents.on(e3, (ev) => this.triggerViewEvent(ev, contents));
        });
      }
      triggerViewEvent(e3, contents) {
        this.emit(e3.type, e3, contents);
      }
      onScroll(e3) {
        this.scrollLeft = this.fullsize ? window.scrollX : this.scroller.scrollLeft;
        this.scrollTop = this.fullsize ? window.scrollY : this.scroller.scrollTop;
      }
      onResize(e3) {
        this.resizeCanceler = true;
      }
      onTouchStart(e3) {
        let {
          screenX,
          screenY
        } = e3.touches[0];
        if (this.fullsize) {
          this.enableScroll();
        }
        this.touchCanceler = true;
        if (!this.startTouchX) {
          this.startTouchX = screenX;
          this.startTouchY = screenY;
          this.startTime = this.now();
        }
        this.endTouchX = screenX;
        this.endTouchY = screenY;
        this.endTime = this.now();
      }
      onTouchMove(e3) {
        let {
          screenX,
          screenY
        } = e3.touches[0];
        let deltaY = Math.abs(screenY - this.endTouchY);
        this.touchCanceler = true;
        if (!this.fullsize && deltaY < 10) {
          this.element.scrollLeft -= screenX - this.endTouchX;
        }
        this.endTouchX = screenX;
        this.endTouchY = screenY;
        this.endTime = this.now();
      }
      onTouchEnd(e3) {
        if (this.fullsize) {
          this.disableScroll();
        }
        this.touchCanceler = false;
        let swipped = this.wasSwiped();
        if (swipped !== 0) {
          this.snap(swipped);
        } else {
          this.snap();
        }
        this.startTouchX = void 0;
        this.startTouchY = void 0;
        this.startTime = void 0;
        this.endTouchX = void 0;
        this.endTouchY = void 0;
        this.endTime = void 0;
      }
      wasSwiped() {
        let snapWidth = this.layout.pageWidth * this.layout.divisor;
        let distance = this.endTouchX - this.startTouchX;
        let absolute = Math.abs(distance);
        let time = this.endTime - this.startTime;
        let velocity = distance / time;
        let minVelocity = this.settings.minVelocity;
        if (absolute <= this.settings.minDistance || absolute >= snapWidth) {
          return 0;
        }
        if (velocity > minVelocity) {
          return -1;
        } else if (velocity < -minVelocity) {
          return 1;
        }
      }
      needsSnap() {
        let left = this.scrollLeft;
        let snapWidth = this.layout.pageWidth * this.layout.divisor;
        return left % snapWidth !== 0;
      }
      snap(howMany = 0) {
        let left = this.scrollLeft;
        let snapWidth = this.layout.pageWidth * this.layout.divisor;
        let snapTo = Math.round(left / snapWidth) * snapWidth;
        if (howMany) {
          snapTo += howMany * snapWidth;
        }
        return this.smoothScrollTo(snapTo);
      }
      smoothScrollTo(destination) {
        const deferred = new _core.defer();
        const start = this.scrollLeft;
        const startTime = this.now();
        const duration = this.settings.duration;
        const easing = this.settings.easing;
        this.snapping = true;
        function tick() {
          const now = this.now();
          const time = Math.min(1, (now - startTime) / duration);
          const timeFunction = easing(time);
          if (this.touchCanceler || this.resizeCanceler) {
            this.resizeCanceler = false;
            this.snapping = false;
            deferred.resolve();
            return;
          }
          if (time < 1) {
            window.requestAnimationFrame(tick.bind(this));
            this.scrollTo(start + (destination - start) * time, 0);
          } else {
            this.scrollTo(destination, 0);
            this.snapping = false;
            deferred.resolve();
          }
        }
        tick.call(this);
        return deferred.promise;
      }
      scrollTo(left = 0, top = 0) {
        if (this.fullsize) {
          window.scroll(left, top);
        } else {
          this.scroller.scrollLeft = left;
          this.scroller.scrollTop = top;
        }
      }
      now() {
        return "now" in window.performance ? performance.now() : new Date().getTime();
      }
      destroy() {
        if (!this.scroller) {
          return;
        }
        if (this.fullsize) {
          this.enableScroll();
        }
        this.removeListeners();
        this.scroller = void 0;
      }
    };
    (0, _eventEmitter.default)(Snap.prototype);
    var _default = Snap;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/managers/continuous/index.js
var require_continuous = __commonJS({
  "node_modules/epubjs/lib/managers/continuous/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _default2 = _interopRequireDefault(require_default());
    var _snap = _interopRequireDefault(require_snap());
    var _constants = require_constants();
    var _debounce = _interopRequireDefault(require_debounce());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ContinuousViewManager = class extends _default2.default {
      constructor(options) {
        super(options);
        this.name = "continuous";
        this.settings = (0, _core.extend)(this.settings || {}, {
          infinite: true,
          overflow: void 0,
          axis: void 0,
          writingMode: void 0,
          flow: "scrolled",
          offset: 500,
          offsetDelta: 250,
          width: void 0,
          height: void 0,
          snap: false,
          afterScrolledTimeout: 10,
          allowScriptedContent: false,
          allowPopups: false
        });
        (0, _core.extend)(this.settings, options.settings || {});
        if (options.settings.gap != "undefined" && options.settings.gap === 0) {
          this.settings.gap = options.settings.gap;
        }
        this.viewSettings = {
          ignoreClass: this.settings.ignoreClass,
          axis: this.settings.axis,
          flow: this.settings.flow,
          layout: this.layout,
          width: 0,
          height: 0,
          forceEvenPages: false,
          allowScriptedContent: this.settings.allowScriptedContent,
          allowPopups: this.settings.allowPopups
        };
        this.scrollTop = 0;
        this.scrollLeft = 0;
      }
      display(section, target) {
        return _default2.default.prototype.display.call(this, section, target).then(function() {
          return this.fill();
        }.bind(this));
      }
      fill(_full) {
        var full = _full || new _core.defer();
        this.q.enqueue(() => {
          return this.check();
        }).then((result) => {
          if (result) {
            this.fill(full);
          } else {
            full.resolve();
          }
        });
        return full.promise;
      }
      moveTo(offset) {
        var distX = 0, distY = 0;
        var offsetX = 0, offsetY = 0;
        if (!this.isPaginated) {
          distY = offset.top;
          offsetY = offset.top + this.settings.offsetDelta;
        } else {
          distX = Math.floor(offset.left / this.layout.delta) * this.layout.delta;
          offsetX = distX + this.settings.offsetDelta;
        }
        if (distX > 0 || distY > 0) {
          this.scrollBy(distX, distY, true);
        }
      }
      afterResized(view) {
        this.emit(_constants.EVENTS.MANAGERS.RESIZE, view.section);
      }
      removeShownListeners(view) {
        view.onDisplayed = function() {
        };
      }
      add(section) {
        var view = this.createView(section);
        this.views.append(view);
        view.on(_constants.EVENTS.VIEWS.RESIZED, (bounds) => {
          view.expanded = true;
        });
        view.on(_constants.EVENTS.VIEWS.AXIS, (axis) => {
          this.updateAxis(axis);
        });
        view.on(_constants.EVENTS.VIEWS.WRITING_MODE, (mode) => {
          this.updateWritingMode(mode);
        });
        view.onDisplayed = this.afterDisplayed.bind(this);
        view.onResize = this.afterResized.bind(this);
        return view.display(this.request);
      }
      append(section) {
        var view = this.createView(section);
        view.on(_constants.EVENTS.VIEWS.RESIZED, (bounds) => {
          view.expanded = true;
        });
        view.on(_constants.EVENTS.VIEWS.AXIS, (axis) => {
          this.updateAxis(axis);
        });
        view.on(_constants.EVENTS.VIEWS.WRITING_MODE, (mode) => {
          this.updateWritingMode(mode);
        });
        this.views.append(view);
        view.onDisplayed = this.afterDisplayed.bind(this);
        return view;
      }
      prepend(section) {
        var view = this.createView(section);
        view.on(_constants.EVENTS.VIEWS.RESIZED, (bounds) => {
          this.counter(bounds);
          view.expanded = true;
        });
        view.on(_constants.EVENTS.VIEWS.AXIS, (axis) => {
          this.updateAxis(axis);
        });
        view.on(_constants.EVENTS.VIEWS.WRITING_MODE, (mode) => {
          this.updateWritingMode(mode);
        });
        this.views.prepend(view);
        view.onDisplayed = this.afterDisplayed.bind(this);
        return view;
      }
      counter(bounds) {
        if (this.settings.axis === "vertical") {
          this.scrollBy(0, bounds.heightDelta, true);
        } else {
          this.scrollBy(bounds.widthDelta, 0, true);
        }
      }
      update(_offset) {
        var container = this.bounds();
        var views = this.views.all();
        var viewsLength = views.length;
        var visible = [];
        var offset = typeof _offset != "undefined" ? _offset : this.settings.offset || 0;
        var isVisible;
        var view;
        var updating = new _core.defer();
        var promises = [];
        for (var i3 = 0; i3 < viewsLength; i3++) {
          view = views[i3];
          isVisible = this.isVisible(view, offset, offset, container);
          if (isVisible === true) {
            if (!view.displayed) {
              let displayed = view.display(this.request).then(function(view2) {
                view2.show();
              }, (err) => {
                view.hide();
              });
              promises.push(displayed);
            } else {
              view.show();
            }
            visible.push(view);
          } else {
            this.q.enqueue(view.destroy.bind(view));
            clearTimeout(this.trimTimeout);
            this.trimTimeout = setTimeout(function() {
              this.q.enqueue(this.trim.bind(this));
            }.bind(this), 250);
          }
        }
        if (promises.length) {
          return Promise.all(promises).catch((err) => {
            updating.reject(err);
          });
        } else {
          updating.resolve();
          return updating.promise;
        }
      }
      check(_offsetLeft, _offsetTop) {
        var checking = new _core.defer();
        var newViews = [];
        var horizontal = this.settings.axis === "horizontal";
        var delta = this.settings.offset || 0;
        if (_offsetLeft && horizontal) {
          delta = _offsetLeft;
        }
        if (_offsetTop && !horizontal) {
          delta = _offsetTop;
        }
        var bounds = this._bounds;
        let offset = horizontal ? this.scrollLeft : this.scrollTop;
        let visibleLength = horizontal ? Math.floor(bounds.width) : bounds.height;
        let contentLength = horizontal ? this.container.scrollWidth : this.container.scrollHeight;
        let writingMode = this.writingMode && this.writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal";
        let rtlScrollType = this.settings.rtlScrollType;
        let rtl = this.settings.direction === "rtl";
        if (!this.settings.fullsize) {
          if (rtl && rtlScrollType === "default" && writingMode === "horizontal") {
            offset = contentLength - visibleLength - offset;
          }
          if (rtl && rtlScrollType === "negative" && writingMode === "horizontal") {
            offset = offset * -1;
          }
        } else {
          if (horizontal && rtl && rtlScrollType === "negative" || !horizontal && rtl && rtlScrollType === "default") {
            offset = offset * -1;
          }
        }
        let prepend = () => {
          let first = this.views.first();
          let prev = first && first.section.prev();
          if (prev) {
            newViews.push(this.prepend(prev));
          }
        };
        let append = () => {
          let last = this.views.last();
          let next = last && last.section.next();
          if (next) {
            newViews.push(this.append(next));
          }
        };
        let end = offset + visibleLength + delta;
        let start = offset - delta;
        if (end >= contentLength) {
          append();
        }
        if (start < 0) {
          prepend();
        }
        let promises = newViews.map((view) => {
          return view.display(this.request);
        });
        if (newViews.length) {
          return Promise.all(promises).then(() => {
            return this.check();
          }).then(() => {
            return this.update(delta);
          }, (err) => {
            return err;
          });
        } else {
          this.q.enqueue(function() {
            this.update();
          }.bind(this));
          checking.resolve(false);
          return checking.promise;
        }
      }
      trim() {
        var task = new _core.defer();
        var displayed = this.views.displayed();
        var first = displayed[0];
        var last = displayed[displayed.length - 1];
        var firstIndex = this.views.indexOf(first);
        var lastIndex = this.views.indexOf(last);
        var above = this.views.slice(0, firstIndex);
        var below = this.views.slice(lastIndex + 1);
        for (var i3 = 0; i3 < above.length - 1; i3++) {
          this.erase(above[i3], above);
        }
        for (var j4 = 1; j4 < below.length; j4++) {
          this.erase(below[j4]);
        }
        task.resolve();
        return task.promise;
      }
      erase(view, above) {
        var prevTop;
        var prevLeft;
        if (!this.settings.fullsize) {
          prevTop = this.container.scrollTop;
          prevLeft = this.container.scrollLeft;
        } else {
          prevTop = window.scrollY;
          prevLeft = window.scrollX;
        }
        var bounds = view.bounds();
        this.views.remove(view);
        if (above) {
          if (this.settings.axis === "vertical") {
            this.scrollTo(0, prevTop - bounds.height, true);
          } else {
            if (this.settings.direction === "rtl") {
              if (!this.settings.fullsize) {
                this.scrollTo(prevLeft, 0, true);
              } else {
                this.scrollTo(prevLeft + Math.floor(bounds.width), 0, true);
              }
            } else {
              this.scrollTo(prevLeft - Math.floor(bounds.width), 0, true);
            }
          }
        }
      }
      addEventListeners(stage) {
        window.addEventListener("unload", function(e3) {
          this.ignore = true;
          this.destroy();
        }.bind(this));
        this.addScrollListeners();
        if (this.isPaginated && this.settings.snap) {
          this.snapper = new _snap.default(this, this.settings.snap && typeof this.settings.snap === "object" && this.settings.snap);
        }
      }
      addScrollListeners() {
        var scroller;
        this.tick = _core.requestAnimationFrame;
        let dir = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
        this.scrollDeltaVert = 0;
        this.scrollDeltaHorz = 0;
        if (!this.settings.fullsize) {
          scroller = this.container;
          this.scrollTop = this.container.scrollTop;
          this.scrollLeft = this.container.scrollLeft;
        } else {
          scroller = window;
          this.scrollTop = window.scrollY * dir;
          this.scrollLeft = window.scrollX * dir;
        }
        this._onScroll = this.onScroll.bind(this);
        scroller.addEventListener("scroll", this._onScroll);
        this._scrolled = (0, _debounce.default)(this.scrolled.bind(this), 30);
        this.didScroll = false;
      }
      removeEventListeners() {
        var scroller;
        if (!this.settings.fullsize) {
          scroller = this.container;
        } else {
          scroller = window;
        }
        scroller.removeEventListener("scroll", this._onScroll);
        this._onScroll = void 0;
      }
      onScroll() {
        let scrollTop;
        let scrollLeft;
        let dir = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
        if (!this.settings.fullsize) {
          scrollTop = this.container.scrollTop;
          scrollLeft = this.container.scrollLeft;
        } else {
          scrollTop = window.scrollY * dir;
          scrollLeft = window.scrollX * dir;
        }
        this.scrollTop = scrollTop;
        this.scrollLeft = scrollLeft;
        if (!this.ignore) {
          this._scrolled();
        } else {
          this.ignore = false;
        }
        this.scrollDeltaVert += Math.abs(scrollTop - this.prevScrollTop);
        this.scrollDeltaHorz += Math.abs(scrollLeft - this.prevScrollLeft);
        this.prevScrollTop = scrollTop;
        this.prevScrollLeft = scrollLeft;
        clearTimeout(this.scrollTimeout);
        this.scrollTimeout = setTimeout(function() {
          this.scrollDeltaVert = 0;
          this.scrollDeltaHorz = 0;
        }.bind(this), 150);
        clearTimeout(this.afterScrolled);
        this.didScroll = false;
      }
      scrolled() {
        this.q.enqueue(function() {
          return this.check();
        }.bind(this));
        this.emit(_constants.EVENTS.MANAGERS.SCROLL, {
          top: this.scrollTop,
          left: this.scrollLeft
        });
        clearTimeout(this.afterScrolled);
        this.afterScrolled = setTimeout(function() {
          if (this.snapper && this.snapper.supportsTouch && this.snapper.needsSnap()) {
            return;
          }
          this.emit(_constants.EVENTS.MANAGERS.SCROLLED, {
            top: this.scrollTop,
            left: this.scrollLeft
          });
        }.bind(this), this.settings.afterScrolledTimeout);
      }
      next() {
        let delta = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
        if (!this.views.length)
          return;
        if (this.isPaginated && this.settings.axis === "horizontal") {
          this.scrollBy(delta, 0, true);
        } else {
          this.scrollBy(0, this.layout.height, true);
        }
        this.q.enqueue(function() {
          return this.check();
        }.bind(this));
      }
      prev() {
        let delta = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
        if (!this.views.length)
          return;
        if (this.isPaginated && this.settings.axis === "horizontal") {
          this.scrollBy(-delta, 0, true);
        } else {
          this.scrollBy(0, -this.layout.height, true);
        }
        this.q.enqueue(function() {
          return this.check();
        }.bind(this));
      }
      updateFlow(flow) {
        if (this.rendered && this.snapper) {
          this.snapper.destroy();
          this.snapper = void 0;
        }
        super.updateFlow(flow, "scroll");
        if (this.rendered && this.isPaginated && this.settings.snap) {
          this.snapper = new _snap.default(this, this.settings.snap && typeof this.settings.snap === "object" && this.settings.snap);
        }
      }
      destroy() {
        super.destroy();
        if (this.snapper) {
          this.snapper.destroy();
        }
      }
    };
    var _default = ContinuousViewManager;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/rendition.js
var require_rendition = __commonJS({
  "node_modules/epubjs/lib/rendition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _core = require_core();
    var _hook = _interopRequireDefault(require_hook());
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _queue = _interopRequireDefault(require_queue());
    var _layout = _interopRequireDefault(require_layout());
    var _themes = _interopRequireDefault(require_themes());
    var _contents = _interopRequireDefault(require_contents());
    var _annotations = _interopRequireDefault(require_annotations());
    var _constants = require_constants();
    var _iframe = _interopRequireDefault(require_iframe());
    var _index = _interopRequireDefault(require_default());
    var _index2 = _interopRequireDefault(require_continuous());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Rendition = class {
      constructor(book, options) {
        this.settings = (0, _core.extend)(this.settings || {}, {
          width: null,
          height: null,
          ignoreClass: "",
          manager: "default",
          view: "iframe",
          flow: null,
          layout: null,
          spread: null,
          minSpreadWidth: 800,
          stylesheet: null,
          resizeOnOrientationChange: true,
          script: null,
          snap: false,
          defaultDirection: "ltr",
          allowScriptedContent: false,
          allowPopups: false
        });
        (0, _core.extend)(this.settings, options);
        if (typeof this.settings.manager === "object") {
          this.manager = this.settings.manager;
        }
        this.book = book;
        this.hooks = {};
        this.hooks.display = new _hook.default(this);
        this.hooks.serialize = new _hook.default(this);
        this.hooks.content = new _hook.default(this);
        this.hooks.unloaded = new _hook.default(this);
        this.hooks.layout = new _hook.default(this);
        this.hooks.render = new _hook.default(this);
        this.hooks.show = new _hook.default(this);
        this.hooks.content.register(this.handleLinks.bind(this));
        this.hooks.content.register(this.passEvents.bind(this));
        this.hooks.content.register(this.adjustImages.bind(this));
        this.book.spine.hooks.content.register(this.injectIdentifier.bind(this));
        if (this.settings.stylesheet) {
          this.book.spine.hooks.content.register(this.injectStylesheet.bind(this));
        }
        if (this.settings.script) {
          this.book.spine.hooks.content.register(this.injectScript.bind(this));
        }
        this.themes = new _themes.default(this);
        this.annotations = new _annotations.default(this);
        this.epubcfi = new _epubcfi.default();
        this.q = new _queue.default(this);
        this.location = void 0;
        this.q.enqueue(this.book.opened);
        this.starting = new _core.defer();
        this.started = this.starting.promise;
        this.q.enqueue(this.start);
      }
      setManager(manager) {
        this.manager = manager;
      }
      requireManager(manager) {
        var viewManager;
        if (typeof manager === "string" && manager === "default") {
          viewManager = _index.default;
        } else if (typeof manager === "string" && manager === "continuous") {
          viewManager = _index2.default;
        } else {
          viewManager = manager;
        }
        return viewManager;
      }
      requireView(view) {
        var View;
        if (typeof view == "string" && view === "iframe") {
          View = _iframe.default;
        } else {
          View = view;
        }
        return View;
      }
      start() {
        if (!this.settings.layout && (this.book.package.metadata.layout === "pre-paginated" || this.book.displayOptions.fixedLayout === "true")) {
          this.settings.layout = "pre-paginated";
        }
        switch (this.book.package.metadata.spread) {
          case "none":
            this.settings.spread = "none";
            break;
          case "both":
            this.settings.spread = true;
            break;
        }
        if (!this.manager) {
          this.ViewManager = this.requireManager(this.settings.manager);
          this.View = this.requireView(this.settings.view);
          this.manager = new this.ViewManager({
            view: this.View,
            queue: this.q,
            request: this.book.load.bind(this.book),
            settings: this.settings
          });
        }
        this.direction(this.book.package.metadata.direction || this.settings.defaultDirection);
        this.settings.globalLayoutProperties = this.determineLayoutProperties(this.book.package.metadata);
        this.flow(this.settings.globalLayoutProperties.flow);
        this.layout(this.settings.globalLayoutProperties);
        this.manager.on(_constants.EVENTS.MANAGERS.ADDED, this.afterDisplayed.bind(this));
        this.manager.on(_constants.EVENTS.MANAGERS.REMOVED, this.afterRemoved.bind(this));
        this.manager.on(_constants.EVENTS.MANAGERS.RESIZED, this.onResized.bind(this));
        this.manager.on(_constants.EVENTS.MANAGERS.ORIENTATION_CHANGE, this.onOrientationChange.bind(this));
        this.manager.on(_constants.EVENTS.MANAGERS.SCROLLED, this.reportLocation.bind(this));
        this.emit(_constants.EVENTS.RENDITION.STARTED);
        this.starting.resolve();
      }
      attachTo(element) {
        return this.q.enqueue(function() {
          this.manager.render(element, {
            "width": this.settings.width,
            "height": this.settings.height
          });
          this.emit(_constants.EVENTS.RENDITION.ATTACHED);
        }.bind(this));
      }
      display(target) {
        if (this.displaying) {
          this.displaying.resolve();
        }
        return this.q.enqueue(this._display, target);
      }
      _display(target) {
        if (!this.book) {
          return;
        }
        var isCfiString = this.epubcfi.isCfiString(target);
        var displaying = new _core.defer();
        var displayed = displaying.promise;
        var section;
        var moveTo;
        this.displaying = displaying;
        if (this.book.locations.length() && (0, _core.isFloat)(target)) {
          target = this.book.locations.cfiFromPercentage(parseFloat(target));
        }
        section = this.book.spine.get(target);
        if (!section) {
          displaying.reject(new Error("No Section Found"));
          return displayed;
        }
        this.manager.display(section, target).then(() => {
          displaying.resolve(section);
          this.displaying = void 0;
          this.emit(_constants.EVENTS.RENDITION.DISPLAYED, section);
          this.reportLocation();
        }, (err) => {
          this.emit(_constants.EVENTS.RENDITION.DISPLAY_ERROR, err);
        });
        return displayed;
      }
      afterDisplayed(view) {
        view.on(_constants.EVENTS.VIEWS.MARK_CLICKED, (cfiRange, data) => this.triggerMarkEvent(cfiRange, data, view.contents));
        this.hooks.render.trigger(view, this).then(() => {
          if (view.contents) {
            this.hooks.content.trigger(view.contents, this).then(() => {
              this.emit(_constants.EVENTS.RENDITION.RENDERED, view.section, view);
            });
          } else {
            this.emit(_constants.EVENTS.RENDITION.RENDERED, view.section, view);
          }
        });
      }
      afterRemoved(view) {
        this.hooks.unloaded.trigger(view, this).then(() => {
          this.emit(_constants.EVENTS.RENDITION.REMOVED, view.section, view);
        });
      }
      onResized(size, epubcfi) {
        this.emit(_constants.EVENTS.RENDITION.RESIZED, {
          width: size.width,
          height: size.height
        }, epubcfi);
        if (this.location && this.location.start) {
          this.display(epubcfi || this.location.start.cfi);
        }
      }
      onOrientationChange(orientation) {
        this.emit(_constants.EVENTS.RENDITION.ORIENTATION_CHANGE, orientation);
      }
      moveTo(offset) {
        this.manager.moveTo(offset);
      }
      resize(width, height, epubcfi) {
        if (width) {
          this.settings.width = width;
        }
        if (height) {
          this.settings.height = height;
        }
        this.manager.resize(width, height, epubcfi);
      }
      clear() {
        this.manager.clear();
      }
      next() {
        return this.q.enqueue(this.manager.next.bind(this.manager)).then(this.reportLocation.bind(this));
      }
      prev() {
        return this.q.enqueue(this.manager.prev.bind(this.manager)).then(this.reportLocation.bind(this));
      }
      determineLayoutProperties(metadata) {
        var properties;
        var layout = this.settings.layout || metadata.layout || "reflowable";
        var spread = this.settings.spread || metadata.spread || "auto";
        var orientation = this.settings.orientation || metadata.orientation || "auto";
        var flow = this.settings.flow || metadata.flow || "auto";
        var viewport = metadata.viewport || "";
        var minSpreadWidth = this.settings.minSpreadWidth || metadata.minSpreadWidth || 800;
        var direction = this.settings.direction || metadata.direction || "ltr";
        if ((this.settings.width === 0 || this.settings.width > 0) && (this.settings.height === 0 || this.settings.height > 0)) {
        }
        properties = {
          layout,
          spread,
          orientation,
          flow,
          viewport,
          minSpreadWidth,
          direction
        };
        return properties;
      }
      flow(flow) {
        var _flow = flow;
        if (flow === "scrolled" || flow === "scrolled-doc" || flow === "scrolled-continuous") {
          _flow = "scrolled";
        }
        if (flow === "auto" || flow === "paginated") {
          _flow = "paginated";
        }
        this.settings.flow = flow;
        if (this._layout) {
          this._layout.flow(_flow);
        }
        if (this.manager && this._layout) {
          this.manager.applyLayout(this._layout);
        }
        if (this.manager) {
          this.manager.updateFlow(_flow);
        }
        if (this.manager && this.manager.isRendered() && this.location) {
          this.manager.clear();
          this.display(this.location.start.cfi);
        }
      }
      layout(settings) {
        if (settings) {
          this._layout = new _layout.default(settings);
          this._layout.spread(settings.spread, this.settings.minSpreadWidth);
          this._layout.on(_constants.EVENTS.LAYOUT.UPDATED, (props, changed) => {
            this.emit(_constants.EVENTS.RENDITION.LAYOUT, props, changed);
          });
        }
        if (this.manager && this._layout) {
          this.manager.applyLayout(this._layout);
        }
        return this._layout;
      }
      spread(spread, min) {
        this.settings.spread = spread;
        if (min) {
          this.settings.minSpreadWidth = min;
        }
        if (this._layout) {
          this._layout.spread(spread, min);
        }
        if (this.manager && this.manager.isRendered()) {
          this.manager.updateLayout();
        }
      }
      direction(dir) {
        this.settings.direction = dir || "ltr";
        if (this.manager) {
          this.manager.direction(this.settings.direction);
        }
        if (this.manager && this.manager.isRendered() && this.location) {
          this.manager.clear();
          this.display(this.location.start.cfi);
        }
      }
      reportLocation() {
        return this.q.enqueue(function reportedLocation() {
          requestAnimationFrame(function reportedLocationAfterRAF() {
            var location = this.manager.currentLocation();
            if (location && location.then && typeof location.then === "function") {
              location.then(function(result) {
                let located = this.located(result);
                if (!located || !located.start || !located.end) {
                  return;
                }
                this.location = located;
                this.emit(_constants.EVENTS.RENDITION.LOCATION_CHANGED, {
                  index: this.location.start.index,
                  href: this.location.start.href,
                  start: this.location.start.cfi,
                  end: this.location.end.cfi,
                  percentage: this.location.start.percentage
                });
                this.emit(_constants.EVENTS.RENDITION.RELOCATED, this.location);
              }.bind(this));
            } else if (location) {
              let located = this.located(location);
              if (!located || !located.start || !located.end) {
                return;
              }
              this.location = located;
              this.emit(_constants.EVENTS.RENDITION.LOCATION_CHANGED, {
                index: this.location.start.index,
                href: this.location.start.href,
                start: this.location.start.cfi,
                end: this.location.end.cfi,
                percentage: this.location.start.percentage
              });
              this.emit(_constants.EVENTS.RENDITION.RELOCATED, this.location);
            }
          }.bind(this));
        }.bind(this));
      }
      currentLocation() {
        var location = this.manager.currentLocation();
        if (location && location.then && typeof location.then === "function") {
          location.then(function(result) {
            let located = this.located(result);
            return located;
          }.bind(this));
        } else if (location) {
          let located = this.located(location);
          return located;
        }
      }
      located(location) {
        if (!location.length) {
          return {};
        }
        let start = location[0];
        let end = location[location.length - 1];
        let located = {
          start: {
            index: start.index,
            href: start.href,
            cfi: start.mapping.start,
            displayed: {
              page: start.pages[0] || 1,
              total: start.totalPages
            }
          },
          end: {
            index: end.index,
            href: end.href,
            cfi: end.mapping.end,
            displayed: {
              page: end.pages[end.pages.length - 1] || 1,
              total: end.totalPages
            }
          }
        };
        let locationStart = this.book.locations.locationFromCfi(start.mapping.start);
        let locationEnd = this.book.locations.locationFromCfi(end.mapping.end);
        if (locationStart != null) {
          located.start.location = locationStart;
          located.start.percentage = this.book.locations.percentageFromLocation(locationStart);
        }
        if (locationEnd != null) {
          located.end.location = locationEnd;
          located.end.percentage = this.book.locations.percentageFromLocation(locationEnd);
        }
        let pageStart = this.book.pageList.pageFromCfi(start.mapping.start);
        let pageEnd = this.book.pageList.pageFromCfi(end.mapping.end);
        if (pageStart != -1) {
          located.start.page = pageStart;
        }
        if (pageEnd != -1) {
          located.end.page = pageEnd;
        }
        if (end.index === this.book.spine.last().index && located.end.displayed.page >= located.end.displayed.total) {
          located.atEnd = true;
        }
        if (start.index === this.book.spine.first().index && located.start.displayed.page === 1) {
          located.atStart = true;
        }
        return located;
      }
      destroy() {
        this.manager && this.manager.destroy();
        this.book = void 0;
      }
      passEvents(contents) {
        _constants.DOM_EVENTS.forEach((e3) => {
          contents.on(e3, (ev) => this.triggerViewEvent(ev, contents));
        });
        contents.on(_constants.EVENTS.CONTENTS.SELECTED, (e3) => this.triggerSelectedEvent(e3, contents));
      }
      triggerViewEvent(e3, contents) {
        this.emit(e3.type, e3, contents);
      }
      triggerSelectedEvent(cfirange, contents) {
        this.emit(_constants.EVENTS.RENDITION.SELECTED, cfirange, contents);
      }
      triggerMarkEvent(cfiRange, data, contents) {
        this.emit(_constants.EVENTS.RENDITION.MARK_CLICKED, cfiRange, data, contents);
      }
      getRange(cfi, ignoreClass) {
        var _cfi = new _epubcfi.default(cfi);
        var found = this.manager.visible().filter(function(view) {
          if (_cfi.spinePos === view.index)
            return true;
        });
        if (found.length) {
          return found[0].contents.range(_cfi, ignoreClass);
        }
      }
      adjustImages(contents) {
        if (this._layout.name === "pre-paginated") {
          return new Promise(function(resolve) {
            resolve();
          });
        }
        let computed = contents.window.getComputedStyle(contents.content, null);
        let height = (contents.content.offsetHeight - (parseFloat(computed.paddingTop) + parseFloat(computed.paddingBottom))) * 0.95;
        let horizontalPadding = parseFloat(computed.paddingLeft) + parseFloat(computed.paddingRight);
        contents.addStylesheetRules({
          "img": {
            "max-width": (this._layout.columnWidth ? this._layout.columnWidth - horizontalPadding + "px" : "100%") + "!important",
            "max-height": height + "px!important",
            "object-fit": "contain",
            "page-break-inside": "avoid",
            "break-inside": "avoid",
            "box-sizing": "border-box"
          },
          "svg": {
            "max-width": (this._layout.columnWidth ? this._layout.columnWidth - horizontalPadding + "px" : "100%") + "!important",
            "max-height": height + "px!important",
            "page-break-inside": "avoid",
            "break-inside": "avoid"
          }
        });
        return new Promise(function(resolve, reject) {
          setTimeout(function() {
            resolve();
          }, 1);
        });
      }
      getContents() {
        return this.manager ? this.manager.getContents() : [];
      }
      views() {
        let views = this.manager ? this.manager.views : void 0;
        return views || [];
      }
      handleLinks(contents) {
        if (contents) {
          contents.on(_constants.EVENTS.CONTENTS.LINK_CLICKED, (href) => {
            let relative = this.book.path.relative(href);
            this.display(relative);
          });
        }
      }
      injectStylesheet(doc, section) {
        let style = doc.createElement("link");
        style.setAttribute("type", "text/css");
        style.setAttribute("rel", "stylesheet");
        style.setAttribute("href", this.settings.stylesheet);
        doc.getElementsByTagName("head")[0].appendChild(style);
      }
      injectScript(doc, section) {
        let script = doc.createElement("script");
        script.setAttribute("type", "text/javascript");
        script.setAttribute("src", this.settings.script);
        script.textContent = " ";
        doc.getElementsByTagName("head")[0].appendChild(script);
      }
      injectIdentifier(doc, section) {
        let ident = this.book.packaging.metadata.identifier;
        let meta = doc.createElement("meta");
        meta.setAttribute("name", "dc.relation.ispartof");
        if (ident) {
          meta.setAttribute("content", ident);
        }
        doc.getElementsByTagName("head")[0].appendChild(meta);
      }
    };
    (0, _eventEmitter.default)(Rendition.prototype);
    var _default = Rendition;
    exports.default = _default;
  }
});

// node_modules/jszip/dist/jszip.js
var require_jszip = __commonJS({
  "node_modules/jszip/dist/jszip.js"(exports, module2) {
    (function(f3) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f3();
      } else if (typeof define === "function" && define.amd) {
        define([], f3);
      } else {
        var g4;
        if (typeof window !== "undefined") {
          g4 = window;
        } else if (typeof global !== "undefined") {
          g4 = global;
        } else if (typeof self !== "undefined") {
          g4 = self;
        } else {
          g4 = this;
        }
        g4.JSZip = f3();
      }
    })(function() {
      var define2, module3, exports2;
      return function e3(t3, n2, r3) {
        function s3(o4, u3) {
          if (!n2[o4]) {
            if (!t3[o4]) {
              var a3 = typeof require == "function" && require;
              if (!u3 && a3)
                return a3(o4, true);
              if (i3)
                return i3(o4, true);
              var f3 = new Error("Cannot find module '" + o4 + "'");
              throw f3.code = "MODULE_NOT_FOUND", f3;
            }
            var l3 = n2[o4] = { exports: {} };
            t3[o4][0].call(l3.exports, function(e4) {
              var n3 = t3[o4][1][e4];
              return s3(n3 ? n3 : e4);
            }, l3, l3.exports, e3, t3, n2, r3);
          }
          return n2[o4].exports;
        }
        var i3 = typeof require == "function" && require;
        for (var o3 = 0; o3 < r3.length; o3++)
          s3(r3[o3]);
        return s3;
      }({ 1: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("./utils");
        var support = require2("./support");
        var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        exports3.encode = function(input) {
          var output = [];
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
          var i3 = 0, len = input.length, remainingBytes = len;
          var isArray = utils.getTypeOf(input) !== "string";
          while (i3 < input.length) {
            remainingBytes = len - i3;
            if (!isArray) {
              chr1 = input.charCodeAt(i3++);
              chr2 = i3 < len ? input.charCodeAt(i3++) : 0;
              chr3 = i3 < len ? input.charCodeAt(i3++) : 0;
            } else {
              chr1 = input[i3++];
              chr2 = i3 < len ? input[i3++] : 0;
              chr3 = i3 < len ? input[i3++] : 0;
            }
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
            enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
            output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
          }
          return output.join("");
        };
        exports3.decode = function(input) {
          var chr1, chr2, chr3;
          var enc1, enc2, enc3, enc4;
          var i3 = 0, resultIndex = 0;
          var dataUrlPrefix = "data:";
          if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
            throw new Error("Invalid base64 input, it looks like a data url.");
          }
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          var totalLength = input.length * 3 / 4;
          if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
            totalLength--;
          }
          if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
            totalLength--;
          }
          if (totalLength % 1 !== 0) {
            throw new Error("Invalid base64 input, bad content length.");
          }
          var output;
          if (support.uint8array) {
            output = new Uint8Array(totalLength | 0);
          } else {
            output = new Array(totalLength | 0);
          }
          while (i3 < input.length) {
            enc1 = _keyStr.indexOf(input.charAt(i3++));
            enc2 = _keyStr.indexOf(input.charAt(i3++));
            enc3 = _keyStr.indexOf(input.charAt(i3++));
            enc4 = _keyStr.indexOf(input.charAt(i3++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            output[resultIndex++] = chr1;
            if (enc3 !== 64) {
              output[resultIndex++] = chr2;
            }
            if (enc4 !== 64) {
              output[resultIndex++] = chr3;
            }
          }
          return output;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(require2, module4, exports3) {
        "use strict";
        var external = require2("./external");
        var DataWorker = require2("./stream/DataWorker");
        var Crc32Probe = require2("./stream/Crc32Probe");
        var DataLengthProbe = require2("./stream/DataLengthProbe");
        function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
          this.compressedSize = compressedSize;
          this.uncompressedSize = uncompressedSize;
          this.crc32 = crc32;
          this.compression = compression;
          this.compressedContent = data;
        }
        CompressedObject.prototype = {
          getContentWorker: function() {
            var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
            var that = this;
            worker.on("end", function() {
              if (this.streamInfo["data_length"] !== that.uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
              }
            });
            return worker;
          },
          getCompressedWorker: function() {
            return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
          }
        };
        CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
          return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
        };
        module4.exports = CompressedObject;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(require2, module4, exports3) {
        "use strict";
        var GenericWorker = require2("./stream/GenericWorker");
        exports3.STORE = {
          magic: "\0\0",
          compressWorker: function(compressionOptions) {
            return new GenericWorker("STORE compression");
          },
          uncompressWorker: function() {
            return new GenericWorker("STORE decompression");
          }
        };
        exports3.DEFLATE = require2("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("./utils");
        function makeTable() {
          var c3, table = [];
          for (var n2 = 0; n2 < 256; n2++) {
            c3 = n2;
            for (var k4 = 0; k4 < 8; k4++) {
              c3 = c3 & 1 ? 3988292384 ^ c3 >>> 1 : c3 >>> 1;
            }
            table[n2] = c3;
          }
          return table;
        }
        var crcTable = makeTable();
        function crc32(crc, buf, len, pos) {
          var t3 = crcTable, end = pos + len;
          crc = crc ^ -1;
          for (var i3 = pos; i3 < end; i3++) {
            crc = crc >>> 8 ^ t3[(crc ^ buf[i3]) & 255];
          }
          return crc ^ -1;
        }
        function crc32str(crc, str, len, pos) {
          var t3 = crcTable, end = pos + len;
          crc = crc ^ -1;
          for (var i3 = pos; i3 < end; i3++) {
            crc = crc >>> 8 ^ t3[(crc ^ str.charCodeAt(i3)) & 255];
          }
          return crc ^ -1;
        }
        module4.exports = function crc32wrapper(input, crc) {
          if (typeof input === "undefined" || !input.length) {
            return 0;
          }
          var isArray = utils.getTypeOf(input) !== "string";
          if (isArray) {
            return crc32(crc | 0, input, input.length, 0);
          } else {
            return crc32str(crc | 0, input, input.length, 0);
          }
        };
      }, { "./utils": 32 }], 5: [function(require2, module4, exports3) {
        "use strict";
        exports3.base64 = false;
        exports3.binary = false;
        exports3.dir = false;
        exports3.createFolders = true;
        exports3.date = null;
        exports3.compression = null;
        exports3.compressionOptions = null;
        exports3.comment = null;
        exports3.unixPermissions = null;
        exports3.dosPermissions = null;
      }, {}], 6: [function(require2, module4, exports3) {
        "use strict";
        var ES6Promise = null;
        if (typeof Promise !== "undefined") {
          ES6Promise = Promise;
        } else {
          ES6Promise = require2("lie");
        }
        module4.exports = {
          Promise: ES6Promise
        };
      }, { "lie": 37 }], 7: [function(require2, module4, exports3) {
        "use strict";
        var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
        var pako = require2("pako");
        var utils = require2("./utils");
        var GenericWorker = require2("./stream/GenericWorker");
        var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
        exports3.magic = "\b\0";
        function FlateWorker(action, options) {
          GenericWorker.call(this, "FlateWorker/" + action);
          this._pako = null;
          this._pakoAction = action;
          this._pakoOptions = options;
          this.meta = {};
        }
        utils.inherits(FlateWorker, GenericWorker);
        FlateWorker.prototype.processChunk = function(chunk) {
          this.meta = chunk.meta;
          if (this._pako === null) {
            this._createPako();
          }
          this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
        };
        FlateWorker.prototype.flush = function() {
          GenericWorker.prototype.flush.call(this);
          if (this._pako === null) {
            this._createPako();
          }
          this._pako.push([], true);
        };
        FlateWorker.prototype.cleanUp = function() {
          GenericWorker.prototype.cleanUp.call(this);
          this._pako = null;
        };
        FlateWorker.prototype._createPako = function() {
          this._pako = new pako[this._pakoAction]({
            raw: true,
            level: this._pakoOptions.level || -1
          });
          var self2 = this;
          this._pako.onData = function(data) {
            self2.push({
              data,
              meta: self2.meta
            });
          };
        };
        exports3.compressWorker = function(compressionOptions) {
          return new FlateWorker("Deflate", compressionOptions);
        };
        exports3.uncompressWorker = function() {
          return new FlateWorker("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, "pako": 38 }], 8: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils");
        var GenericWorker = require2("../stream/GenericWorker");
        var utf8 = require2("../utf8");
        var crc32 = require2("../crc32");
        var signature = require2("../signature");
        var decToHex = function(dec, bytes) {
          var hex = "", i3;
          for (i3 = 0; i3 < bytes; i3++) {
            hex += String.fromCharCode(dec & 255);
            dec = dec >>> 8;
          }
          return hex;
        };
        var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
          var result = unixPermissions;
          if (!unixPermissions) {
            result = isDir ? 16893 : 33204;
          }
          return (result & 65535) << 16;
        };
        var generateDosExternalFileAttr = function(dosPermissions, isDir) {
          return (dosPermissions || 0) & 63;
        };
        var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
          var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
          var dataInfo = {
            crc32: 0,
            compressedSize: 0,
            uncompressedSize: 0
          };
          if (!streamedContent || streamingEnded) {
            dataInfo.crc32 = streamInfo["crc32"];
            dataInfo.compressedSize = streamInfo["compressedSize"];
            dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
          }
          var bitflag = 0;
          if (streamedContent) {
            bitflag |= 8;
          }
          if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
            bitflag |= 2048;
          }
          var extFileAttr = 0;
          var versionMadeBy = 0;
          if (dir) {
            extFileAttr |= 16;
          }
          if (platform === "UNIX") {
            versionMadeBy = 798;
            extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
          } else {
            versionMadeBy = 20;
            extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
          }
          dosTime = date.getUTCHours();
          dosTime = dosTime << 6;
          dosTime = dosTime | date.getUTCMinutes();
          dosTime = dosTime << 5;
          dosTime = dosTime | date.getUTCSeconds() / 2;
          dosDate = date.getUTCFullYear() - 1980;
          dosDate = dosDate << 4;
          dosDate = dosDate | date.getUTCMonth() + 1;
          dosDate = dosDate << 5;
          dosDate = dosDate | date.getUTCDate();
          if (useUTF8ForFileName) {
            unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName;
            extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField;
          }
          if (useUTF8ForComment) {
            unicodeCommentExtraField = decToHex(1, 1) + decToHex(crc32(encodedComment), 4) + utfEncodedComment;
            extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField;
          }
          var header = "";
          header += "\n\0";
          header += decToHex(bitflag, 2);
          header += compression.magic;
          header += decToHex(dosTime, 2);
          header += decToHex(dosDate, 2);
          header += decToHex(dataInfo.crc32, 4);
          header += decToHex(dataInfo.compressedSize, 4);
          header += decToHex(dataInfo.uncompressedSize, 4);
          header += decToHex(encodedFileName.length, 2);
          header += decToHex(extraFields.length, 2);
          var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
          var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + "\0\0\0\0" + decToHex(extFileAttr, 4) + decToHex(offset, 4) + encodedFileName + extraFields + encodedComment;
          return {
            fileRecord,
            dirRecord
          };
        };
        var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
          var dirEnd = "";
          var encodedComment = utils.transformTo("string", encodeFileName(comment));
          dirEnd = signature.CENTRAL_DIRECTORY_END + "\0\0\0\0" + decToHex(entriesCount, 2) + decToHex(entriesCount, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment;
          return dirEnd;
        };
        var generateDataDescriptors = function(streamInfo) {
          var descriptor = "";
          descriptor = signature.DATA_DESCRIPTOR + decToHex(streamInfo["crc32"], 4) + decToHex(streamInfo["compressedSize"], 4) + decToHex(streamInfo["uncompressedSize"], 4);
          return descriptor;
        };
        function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
          GenericWorker.call(this, "ZipFileWorker");
          this.bytesWritten = 0;
          this.zipComment = comment;
          this.zipPlatform = platform;
          this.encodeFileName = encodeFileName;
          this.streamFiles = streamFiles;
          this.accumulate = false;
          this.contentBuffer = [];
          this.dirRecords = [];
          this.currentSourceOffset = 0;
          this.entriesCount = 0;
          this.currentFile = null;
          this._sources = [];
        }
        utils.inherits(ZipFileWorker, GenericWorker);
        ZipFileWorker.prototype.push = function(chunk) {
          var currentFilePercent = chunk.meta.percent || 0;
          var entriesCount = this.entriesCount;
          var remainingFiles = this._sources.length;
          if (this.accumulate) {
            this.contentBuffer.push(chunk);
          } else {
            this.bytesWritten += chunk.data.length;
            GenericWorker.prototype.push.call(this, {
              data: chunk.data,
              meta: {
                currentFile: this.currentFile,
                percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
              }
            });
          }
        };
        ZipFileWorker.prototype.openedSource = function(streamInfo) {
          this.currentSourceOffset = this.bytesWritten;
          this.currentFile = streamInfo["file"].name;
          var streamedContent = this.streamFiles && !streamInfo["file"].dir;
          if (streamedContent) {
            var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({
              data: record.fileRecord,
              meta: { percent: 0 }
            });
          } else {
            this.accumulate = true;
          }
        };
        ZipFileWorker.prototype.closedSource = function(streamInfo) {
          this.accumulate = false;
          var streamedContent = this.streamFiles && !streamInfo["file"].dir;
          var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.dirRecords.push(record.dirRecord);
          if (streamedContent) {
            this.push({
              data: generateDataDescriptors(streamInfo),
              meta: { percent: 100 }
            });
          } else {
            this.push({
              data: record.fileRecord,
              meta: { percent: 0 }
            });
            while (this.contentBuffer.length) {
              this.push(this.contentBuffer.shift());
            }
          }
          this.currentFile = null;
        };
        ZipFileWorker.prototype.flush = function() {
          var localDirLength = this.bytesWritten;
          for (var i3 = 0; i3 < this.dirRecords.length; i3++) {
            this.push({
              data: this.dirRecords[i3],
              meta: { percent: 100 }
            });
          }
          var centralDirLength = this.bytesWritten - localDirLength;
          var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
          this.push({
            data: dirEnd,
            meta: { percent: 100 }
          });
        };
        ZipFileWorker.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift();
          this.openedSource(this.previous.streamInfo);
          if (this.isPaused) {
            this.previous.pause();
          } else {
            this.previous.resume();
          }
        };
        ZipFileWorker.prototype.registerPrevious = function(previous) {
          this._sources.push(previous);
          var self2 = this;
          previous.on("data", function(chunk) {
            self2.processChunk(chunk);
          });
          previous.on("end", function() {
            self2.closedSource(self2.previous.streamInfo);
            if (self2._sources.length) {
              self2.prepareNextSource();
            } else {
              self2.end();
            }
          });
          previous.on("error", function(e3) {
            self2.error(e3);
          });
          return this;
        };
        ZipFileWorker.prototype.resume = function() {
          if (!GenericWorker.prototype.resume.call(this)) {
            return false;
          }
          if (!this.previous && this._sources.length) {
            this.prepareNextSource();
            return true;
          }
          if (!this.previous && !this._sources.length && !this.generatedError) {
            this.end();
            return true;
          }
        };
        ZipFileWorker.prototype.error = function(e3) {
          var sources = this._sources;
          if (!GenericWorker.prototype.error.call(this, e3)) {
            return false;
          }
          for (var i3 = 0; i3 < sources.length; i3++) {
            try {
              sources[i3].error(e3);
            } catch (e4) {
            }
          }
          return true;
        };
        ZipFileWorker.prototype.lock = function() {
          GenericWorker.prototype.lock.call(this);
          var sources = this._sources;
          for (var i3 = 0; i3 < sources.length; i3++) {
            sources[i3].lock();
          }
        };
        module4.exports = ZipFileWorker;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(require2, module4, exports3) {
        "use strict";
        var compressions = require2("../compressions");
        var ZipFileWorker = require2("./ZipFileWorker");
        var getCompression = function(fileCompression, zipCompression) {
          var compressionName = fileCompression || zipCompression;
          var compression = compressions[compressionName];
          if (!compression) {
            throw new Error(compressionName + " is not a valid compression method !");
          }
          return compression;
        };
        exports3.generateWorker = function(zip, options, comment) {
          var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
          var entriesCount = 0;
          try {
            zip.forEach(function(relativePath, file) {
              entriesCount++;
              var compression = getCompression(file.options.compression, options.compression);
              var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
              var dir = file.dir, date = file.date;
              file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
                name: relativePath,
                dir,
                date,
                comment: file.comment || "",
                unixPermissions: file.unixPermissions,
                dosPermissions: file.dosPermissions
              }).pipe(zipFileWorker);
            });
            zipFileWorker.entriesCount = entriesCount;
          } catch (e3) {
            zipFileWorker.error(e3);
          }
          return zipFileWorker;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(require2, module4, exports3) {
        "use strict";
        function JSZip() {
          if (!(this instanceof JSZip)) {
            return new JSZip();
          }
          if (arguments.length) {
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          }
          this.files = /* @__PURE__ */ Object.create(null);
          this.comment = null;
          this.root = "";
          this.clone = function() {
            var newObj = new JSZip();
            for (var i3 in this) {
              if (typeof this[i3] !== "function") {
                newObj[i3] = this[i3];
              }
            }
            return newObj;
          };
        }
        JSZip.prototype = require2("./object");
        JSZip.prototype.loadAsync = require2("./load");
        JSZip.support = require2("./support");
        JSZip.defaults = require2("./defaults");
        JSZip.version = "3.9.1";
        JSZip.loadAsync = function(content, options) {
          return new JSZip().loadAsync(content, options);
        };
        JSZip.external = require2("./external");
        module4.exports = JSZip;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("./utils");
        var external = require2("./external");
        var utf8 = require2("./utf8");
        var ZipEntries = require2("./zipEntries");
        var Crc32Probe = require2("./stream/Crc32Probe");
        var nodejsUtils = require2("./nodejsUtils");
        function checkEntryCRC32(zipEntry) {
          return new external.Promise(function(resolve, reject) {
            var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
            worker.on("error", function(e3) {
              reject(e3);
            }).on("end", function() {
              if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                reject(new Error("Corrupted zip : CRC32 mismatch"));
              } else {
                resolve();
              }
            }).resume();
          });
        }
        module4.exports = function(data, options) {
          var zip = this;
          options = utils.extend(options || {}, {
            base64: false,
            checkCRC32: false,
            optimizedBinaryString: false,
            createFolders: false,
            decodeFileName: utf8.utf8decode
          });
          if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
            return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
          }
          return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
            var zipEntries = new ZipEntries(options);
            zipEntries.load(data2);
            return zipEntries;
          }).then(function checkCRC32(zipEntries) {
            var promises = [external.Promise.resolve(zipEntries)];
            var files = zipEntries.files;
            if (options.checkCRC32) {
              for (var i3 = 0; i3 < files.length; i3++) {
                promises.push(checkEntryCRC32(files[i3]));
              }
            }
            return external.Promise.all(promises);
          }).then(function addFiles(results) {
            var zipEntries = results.shift();
            var files = zipEntries.files;
            for (var i3 = 0; i3 < files.length; i3++) {
              var input = files[i3];
              var unsafeName = input.fileNameStr;
              var safeName = utils.resolve(input.fileNameStr);
              zip.file(safeName, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment: input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions: input.unixPermissions,
                dosPermissions: input.dosPermissions,
                createFolders: options.createFolders
              });
              if (!input.dir) {
                zip.file(safeName).unsafeOriginalName = unsafeName;
              }
            }
            if (zipEntries.zipComment.length) {
              zip.comment = zipEntries.zipComment;
            }
            return zip;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils");
        var GenericWorker = require2("../stream/GenericWorker");
        function NodejsStreamInputAdapter(filename, stream) {
          GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
          this._upstreamEnded = false;
          this._bindStream(stream);
        }
        utils.inherits(NodejsStreamInputAdapter, GenericWorker);
        NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
          var self2 = this;
          this._stream = stream;
          stream.pause();
          stream.on("data", function(chunk) {
            self2.push({
              data: chunk,
              meta: {
                percent: 0
              }
            });
          }).on("error", function(e3) {
            if (self2.isPaused) {
              this.generatedError = e3;
            } else {
              self2.error(e3);
            }
          }).on("end", function() {
            if (self2.isPaused) {
              self2._upstreamEnded = true;
            } else {
              self2.end();
            }
          });
        };
        NodejsStreamInputAdapter.prototype.pause = function() {
          if (!GenericWorker.prototype.pause.call(this)) {
            return false;
          }
          this._stream.pause();
          return true;
        };
        NodejsStreamInputAdapter.prototype.resume = function() {
          if (!GenericWorker.prototype.resume.call(this)) {
            return false;
          }
          if (this._upstreamEnded) {
            this.end();
          } else {
            this._stream.resume();
          }
          return true;
        };
        module4.exports = NodejsStreamInputAdapter;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(require2, module4, exports3) {
        "use strict";
        var Readable = require2("readable-stream").Readable;
        var utils = require2("../utils");
        utils.inherits(NodejsStreamOutputAdapter, Readable);
        function NodejsStreamOutputAdapter(helper, options, updateCb) {
          Readable.call(this, options);
          this._helper = helper;
          var self2 = this;
          helper.on("data", function(data, meta) {
            if (!self2.push(data)) {
              self2._helper.pause();
            }
            if (updateCb) {
              updateCb(meta);
            }
          }).on("error", function(e3) {
            self2.emit("error", e3);
          }).on("end", function() {
            self2.push(null);
          });
        }
        NodejsStreamOutputAdapter.prototype._read = function() {
          this._helper.resume();
        };
        module4.exports = NodejsStreamOutputAdapter;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(require2, module4, exports3) {
        "use strict";
        module4.exports = {
          isNode: typeof Buffer !== "undefined",
          newBufferFrom: function(data, encoding) {
            if (Buffer.from && Buffer.from !== Uint8Array.from) {
              return Buffer.from(data, encoding);
            } else {
              if (typeof data === "number") {
                throw new Error('The "data" argument must not be a number');
              }
              return new Buffer(data, encoding);
            }
          },
          allocBuffer: function(size) {
            if (Buffer.alloc) {
              return Buffer.alloc(size);
            } else {
              var buf = new Buffer(size);
              buf.fill(0);
              return buf;
            }
          },
          isBuffer: function(b3) {
            return Buffer.isBuffer(b3);
          },
          isStream: function(obj) {
            return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
          }
        };
      }, {}], 15: [function(require2, module4, exports3) {
        "use strict";
        var utf8 = require2("./utf8");
        var utils = require2("./utils");
        var GenericWorker = require2("./stream/GenericWorker");
        var StreamHelper = require2("./stream/StreamHelper");
        var defaults = require2("./defaults");
        var CompressedObject = require2("./compressedObject");
        var ZipObject = require2("./zipObject");
        var generate = require2("./generate");
        var nodejsUtils = require2("./nodejsUtils");
        var NodejsStreamInputAdapter = require2("./nodejs/NodejsStreamInputAdapter");
        var fileAdd = function(name, data, originalOptions) {
          var dataType = utils.getTypeOf(data), parent2;
          var o3 = utils.extend(originalOptions || {}, defaults);
          o3.date = o3.date || new Date();
          if (o3.compression !== null) {
            o3.compression = o3.compression.toUpperCase();
          }
          if (typeof o3.unixPermissions === "string") {
            o3.unixPermissions = parseInt(o3.unixPermissions, 8);
          }
          if (o3.unixPermissions && o3.unixPermissions & 16384) {
            o3.dir = true;
          }
          if (o3.dosPermissions && o3.dosPermissions & 16) {
            o3.dir = true;
          }
          if (o3.dir) {
            name = forceTrailingSlash(name);
          }
          if (o3.createFolders && (parent2 = parentFolder(name))) {
            folderAdd.call(this, parent2, true);
          }
          var isUnicodeString = dataType === "string" && o3.binary === false && o3.base64 === false;
          if (!originalOptions || typeof originalOptions.binary === "undefined") {
            o3.binary = !isUnicodeString;
          }
          var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
          if (isCompressedEmpty || o3.dir || !data || data.length === 0) {
            o3.base64 = false;
            o3.binary = true;
            data = "";
            o3.compression = "STORE";
            dataType = "string";
          }
          var zipObjectContent = null;
          if (data instanceof CompressedObject || data instanceof GenericWorker) {
            zipObjectContent = data;
          } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
            zipObjectContent = new NodejsStreamInputAdapter(name, data);
          } else {
            zipObjectContent = utils.prepareContent(name, data, o3.binary, o3.optimizedBinaryString, o3.base64);
          }
          var object = new ZipObject(name, zipObjectContent, o3);
          this.files[name] = object;
        };
        var parentFolder = function(path) {
          if (path.slice(-1) === "/") {
            path = path.substring(0, path.length - 1);
          }
          var lastSlash = path.lastIndexOf("/");
          return lastSlash > 0 ? path.substring(0, lastSlash) : "";
        };
        var forceTrailingSlash = function(path) {
          if (path.slice(-1) !== "/") {
            path += "/";
          }
          return path;
        };
        var folderAdd = function(name, createFolders) {
          createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
          name = forceTrailingSlash(name);
          if (!this.files[name]) {
            fileAdd.call(this, name, null, {
              dir: true,
              createFolders
            });
          }
          return this.files[name];
        };
        function isRegExp(object) {
          return Object.prototype.toString.call(object) === "[object RegExp]";
        }
        var out = {
          load: function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          },
          forEach: function(cb) {
            var filename, relativePath, file;
            for (filename in this.files) {
              file = this.files[filename];
              relativePath = filename.slice(this.root.length, filename.length);
              if (relativePath && filename.slice(0, this.root.length) === this.root) {
                cb(relativePath, file);
              }
            }
          },
          filter: function(search) {
            var result = [];
            this.forEach(function(relativePath, entry) {
              if (search(relativePath, entry)) {
                result.push(entry);
              }
            });
            return result;
          },
          file: function(name, data, o3) {
            if (arguments.length === 1) {
              if (isRegExp(name)) {
                var regexp = name;
                return this.filter(function(relativePath, file) {
                  return !file.dir && regexp.test(relativePath);
                });
              } else {
                var obj = this.files[this.root + name];
                if (obj && !obj.dir) {
                  return obj;
                } else {
                  return null;
                }
              }
            } else {
              name = this.root + name;
              fileAdd.call(this, name, data, o3);
            }
            return this;
          },
          folder: function(arg) {
            if (!arg) {
              return this;
            }
            if (isRegExp(arg)) {
              return this.filter(function(relativePath, file) {
                return file.dir && arg.test(relativePath);
              });
            }
            var name = this.root + arg;
            var newFolder = folderAdd.call(this, name);
            var ret = this.clone();
            ret.root = newFolder.name;
            return ret;
          },
          remove: function(name) {
            name = this.root + name;
            var file = this.files[name];
            if (!file) {
              if (name.slice(-1) !== "/") {
                name += "/";
              }
              file = this.files[name];
            }
            if (file && !file.dir) {
              delete this.files[name];
            } else {
              var kids = this.filter(function(relativePath, file2) {
                return file2.name.slice(0, name.length) === name;
              });
              for (var i3 = 0; i3 < kids.length; i3++) {
                delete this.files[kids[i3].name];
              }
            }
            return this;
          },
          generate: function(options) {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          },
          generateInternalStream: function(options) {
            var worker, opts = {};
            try {
              opts = utils.extend(options || {}, {
                streamFiles: false,
                compression: "STORE",
                compressionOptions: null,
                type: "",
                platform: "DOS",
                comment: null,
                mimeType: "application/zip",
                encodeFileName: utf8.utf8encode
              });
              opts.type = opts.type.toLowerCase();
              opts.compression = opts.compression.toUpperCase();
              if (opts.type === "binarystring") {
                opts.type = "string";
              }
              if (!opts.type) {
                throw new Error("No output type specified.");
              }
              utils.checkSupport(opts.type);
              if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
                opts.platform = "UNIX";
              }
              if (opts.platform === "win32") {
                opts.platform = "DOS";
              }
              var comment = opts.comment || this.comment || "";
              worker = generate.generateWorker(this, opts, comment);
            } catch (e3) {
              worker = new GenericWorker("error");
              worker.error(e3);
            }
            return new StreamHelper(worker, opts.type || "string", opts.mimeType);
          },
          generateAsync: function(options, onUpdate) {
            return this.generateInternalStream(options).accumulate(onUpdate);
          },
          generateNodeStream: function(options, onUpdate) {
            options = options || {};
            if (!options.type) {
              options.type = "nodebuffer";
            }
            return this.generateInternalStream(options).toNodejsStream(onUpdate);
          }
        };
        module4.exports = out;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(require2, module4, exports3) {
        module4.exports = require2("stream");
      }, { "stream": void 0 }], 17: [function(require2, module4, exports3) {
        "use strict";
        var DataReader = require2("./DataReader");
        var utils = require2("../utils");
        function ArrayReader(data) {
          DataReader.call(this, data);
          for (var i3 = 0; i3 < this.data.length; i3++) {
            data[i3] = data[i3] & 255;
          }
        }
        utils.inherits(ArrayReader, DataReader);
        ArrayReader.prototype.byteAt = function(i3) {
          return this.data[this.zero + i3];
        };
        ArrayReader.prototype.lastIndexOfSignature = function(sig) {
          var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
          for (var i3 = this.length - 4; i3 >= 0; --i3) {
            if (this.data[i3] === sig0 && this.data[i3 + 1] === sig1 && this.data[i3 + 2] === sig2 && this.data[i3 + 3] === sig3) {
              return i3 - this.zero;
            }
          }
          return -1;
        };
        ArrayReader.prototype.readAndCheckSignature = function(sig) {
          var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
          return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
        };
        ArrayReader.prototype.readData = function(size) {
          this.checkOffset(size);
          if (size === 0) {
            return [];
          }
          var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
          this.index += size;
          return result;
        };
        module4.exports = ArrayReader;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils");
        function DataReader(data) {
          this.data = data;
          this.length = data.length;
          this.index = 0;
          this.zero = 0;
        }
        DataReader.prototype = {
          checkOffset: function(offset) {
            this.checkIndex(this.index + offset);
          },
          checkIndex: function(newIndex) {
            if (this.length < this.zero + newIndex || newIndex < 0) {
              throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
            }
          },
          setIndex: function(newIndex) {
            this.checkIndex(newIndex);
            this.index = newIndex;
          },
          skip: function(n2) {
            this.setIndex(this.index + n2);
          },
          byteAt: function(i3) {
          },
          readInt: function(size) {
            var result = 0, i3;
            this.checkOffset(size);
            for (i3 = this.index + size - 1; i3 >= this.index; i3--) {
              result = (result << 8) + this.byteAt(i3);
            }
            this.index += size;
            return result;
          },
          readString: function(size) {
            return utils.transformTo("string", this.readData(size));
          },
          readData: function(size) {
          },
          lastIndexOfSignature: function(sig) {
          },
          readAndCheckSignature: function(sig) {
          },
          readDate: function() {
            var dostime = this.readInt(4);
            return new Date(Date.UTC((dostime >> 25 & 127) + 1980, (dostime >> 21 & 15) - 1, dostime >> 16 & 31, dostime >> 11 & 31, dostime >> 5 & 63, (dostime & 31) << 1));
          }
        };
        module4.exports = DataReader;
      }, { "../utils": 32 }], 19: [function(require2, module4, exports3) {
        "use strict";
        var Uint8ArrayReader = require2("./Uint8ArrayReader");
        var utils = require2("../utils");
        function NodeBufferReader(data) {
          Uint8ArrayReader.call(this, data);
        }
        utils.inherits(NodeBufferReader, Uint8ArrayReader);
        NodeBufferReader.prototype.readData = function(size) {
          this.checkOffset(size);
          var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
          this.index += size;
          return result;
        };
        module4.exports = NodeBufferReader;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(require2, module4, exports3) {
        "use strict";
        var DataReader = require2("./DataReader");
        var utils = require2("../utils");
        function StringReader(data) {
          DataReader.call(this, data);
        }
        utils.inherits(StringReader, DataReader);
        StringReader.prototype.byteAt = function(i3) {
          return this.data.charCodeAt(this.zero + i3);
        };
        StringReader.prototype.lastIndexOfSignature = function(sig) {
          return this.data.lastIndexOf(sig) - this.zero;
        };
        StringReader.prototype.readAndCheckSignature = function(sig) {
          var data = this.readData(4);
          return sig === data;
        };
        StringReader.prototype.readData = function(size) {
          this.checkOffset(size);
          var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
          this.index += size;
          return result;
        };
        module4.exports = StringReader;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(require2, module4, exports3) {
        "use strict";
        var ArrayReader = require2("./ArrayReader");
        var utils = require2("../utils");
        function Uint8ArrayReader(data) {
          ArrayReader.call(this, data);
        }
        utils.inherits(Uint8ArrayReader, ArrayReader);
        Uint8ArrayReader.prototype.readData = function(size) {
          this.checkOffset(size);
          if (size === 0) {
            return new Uint8Array(0);
          }
          var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
          this.index += size;
          return result;
        };
        module4.exports = Uint8ArrayReader;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils");
        var support = require2("../support");
        var ArrayReader = require2("./ArrayReader");
        var StringReader = require2("./StringReader");
        var NodeBufferReader = require2("./NodeBufferReader");
        var Uint8ArrayReader = require2("./Uint8ArrayReader");
        module4.exports = function(data) {
          var type = utils.getTypeOf(data);
          utils.checkSupport(type);
          if (type === "string" && !support.uint8array) {
            return new StringReader(data);
          }
          if (type === "nodebuffer") {
            return new NodeBufferReader(data);
          }
          if (support.uint8array) {
            return new Uint8ArrayReader(utils.transformTo("uint8array", data));
          }
          return new ArrayReader(utils.transformTo("array", data));
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(require2, module4, exports3) {
        "use strict";
        exports3.LOCAL_FILE_HEADER = "PK";
        exports3.CENTRAL_FILE_HEADER = "PK";
        exports3.CENTRAL_DIRECTORY_END = "PK";
        exports3.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
        exports3.ZIP64_CENTRAL_DIRECTORY_END = "PK";
        exports3.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(require2, module4, exports3) {
        "use strict";
        var GenericWorker = require2("./GenericWorker");
        var utils = require2("../utils");
        function ConvertWorker(destType) {
          GenericWorker.call(this, "ConvertWorker to " + destType);
          this.destType = destType;
        }
        utils.inherits(ConvertWorker, GenericWorker);
        ConvertWorker.prototype.processChunk = function(chunk) {
          this.push({
            data: utils.transformTo(this.destType, chunk.data),
            meta: chunk.meta
          });
        };
        module4.exports = ConvertWorker;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(require2, module4, exports3) {
        "use strict";
        var GenericWorker = require2("./GenericWorker");
        var crc32 = require2("../crc32");
        var utils = require2("../utils");
        function Crc32Probe() {
          GenericWorker.call(this, "Crc32Probe");
          this.withStreamInfo("crc32", 0);
        }
        utils.inherits(Crc32Probe, GenericWorker);
        Crc32Probe.prototype.processChunk = function(chunk) {
          this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
          this.push(chunk);
        };
        module4.exports = Crc32Probe;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils");
        var GenericWorker = require2("./GenericWorker");
        function DataLengthProbe(propName) {
          GenericWorker.call(this, "DataLengthProbe for " + propName);
          this.propName = propName;
          this.withStreamInfo(propName, 0);
        }
        utils.inherits(DataLengthProbe, GenericWorker);
        DataLengthProbe.prototype.processChunk = function(chunk) {
          if (chunk) {
            var length = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = length + chunk.data.length;
          }
          GenericWorker.prototype.processChunk.call(this, chunk);
        };
        module4.exports = DataLengthProbe;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils");
        var GenericWorker = require2("./GenericWorker");
        var DEFAULT_BLOCK_SIZE = 16 * 1024;
        function DataWorker(dataP) {
          GenericWorker.call(this, "DataWorker");
          var self2 = this;
          this.dataIsReady = false;
          this.index = 0;
          this.max = 0;
          this.data = null;
          this.type = "";
          this._tickScheduled = false;
          dataP.then(function(data) {
            self2.dataIsReady = true;
            self2.data = data;
            self2.max = data && data.length || 0;
            self2.type = utils.getTypeOf(data);
            if (!self2.isPaused) {
              self2._tickAndRepeat();
            }
          }, function(e3) {
            self2.error(e3);
          });
        }
        utils.inherits(DataWorker, GenericWorker);
        DataWorker.prototype.cleanUp = function() {
          GenericWorker.prototype.cleanUp.call(this);
          this.data = null;
        };
        DataWorker.prototype.resume = function() {
          if (!GenericWorker.prototype.resume.call(this)) {
            return false;
          }
          if (!this._tickScheduled && this.dataIsReady) {
            this._tickScheduled = true;
            utils.delay(this._tickAndRepeat, [], this);
          }
          return true;
        };
        DataWorker.prototype._tickAndRepeat = function() {
          this._tickScheduled = false;
          if (this.isPaused || this.isFinished) {
            return;
          }
          this._tick();
          if (!this.isFinished) {
            utils.delay(this._tickAndRepeat, [], this);
            this._tickScheduled = true;
          }
        };
        DataWorker.prototype._tick = function() {
          if (this.isPaused || this.isFinished) {
            return false;
          }
          var size = DEFAULT_BLOCK_SIZE;
          var data = null, nextIndex = Math.min(this.max, this.index + size);
          if (this.index >= this.max) {
            return this.end();
          } else {
            switch (this.type) {
              case "string":
                data = this.data.substring(this.index, nextIndex);
                break;
              case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
                break;
              case "array":
              case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
                break;
            }
            this.index = nextIndex;
            return this.push({
              data,
              meta: {
                percent: this.max ? this.index / this.max * 100 : 0
              }
            });
          }
        };
        module4.exports = DataWorker;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(require2, module4, exports3) {
        "use strict";
        function GenericWorker(name) {
          this.name = name || "default";
          this.streamInfo = {};
          this.generatedError = null;
          this.extraStreamInfo = {};
          this.isPaused = true;
          this.isFinished = false;
          this.isLocked = false;
          this._listeners = {
            "data": [],
            "end": [],
            "error": []
          };
          this.previous = null;
        }
        GenericWorker.prototype = {
          push: function(chunk) {
            this.emit("data", chunk);
          },
          end: function() {
            if (this.isFinished) {
              return false;
            }
            this.flush();
            try {
              this.emit("end");
              this.cleanUp();
              this.isFinished = true;
            } catch (e3) {
              this.emit("error", e3);
            }
            return true;
          },
          error: function(e3) {
            if (this.isFinished) {
              return false;
            }
            if (this.isPaused) {
              this.generatedError = e3;
            } else {
              this.isFinished = true;
              this.emit("error", e3);
              if (this.previous) {
                this.previous.error(e3);
              }
              this.cleanUp();
            }
            return true;
          },
          on: function(name, listener) {
            this._listeners[name].push(listener);
            return this;
          },
          cleanUp: function() {
            this.streamInfo = this.generatedError = this.extraStreamInfo = null;
            this._listeners = [];
          },
          emit: function(name, arg) {
            if (this._listeners[name]) {
              for (var i3 = 0; i3 < this._listeners[name].length; i3++) {
                this._listeners[name][i3].call(this, arg);
              }
            }
          },
          pipe: function(next) {
            return next.registerPrevious(this);
          },
          registerPrevious: function(previous) {
            if (this.isLocked) {
              throw new Error("The stream '" + this + "' has already been used.");
            }
            this.streamInfo = previous.streamInfo;
            this.mergeStreamInfo();
            this.previous = previous;
            var self2 = this;
            previous.on("data", function(chunk) {
              self2.processChunk(chunk);
            });
            previous.on("end", function() {
              self2.end();
            });
            previous.on("error", function(e3) {
              self2.error(e3);
            });
            return this;
          },
          pause: function() {
            if (this.isPaused || this.isFinished) {
              return false;
            }
            this.isPaused = true;
            if (this.previous) {
              this.previous.pause();
            }
            return true;
          },
          resume: function() {
            if (!this.isPaused || this.isFinished) {
              return false;
            }
            this.isPaused = false;
            var withError = false;
            if (this.generatedError) {
              this.error(this.generatedError);
              withError = true;
            }
            if (this.previous) {
              this.previous.resume();
            }
            return !withError;
          },
          flush: function() {
          },
          processChunk: function(chunk) {
            this.push(chunk);
          },
          withStreamInfo: function(key, value) {
            this.extraStreamInfo[key] = value;
            this.mergeStreamInfo();
            return this;
          },
          mergeStreamInfo: function() {
            for (var key in this.extraStreamInfo) {
              if (!this.extraStreamInfo.hasOwnProperty(key)) {
                continue;
              }
              this.streamInfo[key] = this.extraStreamInfo[key];
            }
          },
          lock: function() {
            if (this.isLocked) {
              throw new Error("The stream '" + this + "' has already been used.");
            }
            this.isLocked = true;
            if (this.previous) {
              this.previous.lock();
            }
          },
          toString: function() {
            var me = "Worker " + this.name;
            if (this.previous) {
              return this.previous + " -> " + me;
            } else {
              return me;
            }
          }
        };
        module4.exports = GenericWorker;
      }, {}], 29: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils");
        var ConvertWorker = require2("./ConvertWorker");
        var GenericWorker = require2("./GenericWorker");
        var base64 = require2("../base64");
        var support = require2("../support");
        var external = require2("../external");
        var NodejsStreamOutputAdapter = null;
        if (support.nodestream) {
          try {
            NodejsStreamOutputAdapter = require2("../nodejs/NodejsStreamOutputAdapter");
          } catch (e3) {
          }
        }
        function transformZipOutput(type, content, mimeType) {
          switch (type) {
            case "blob":
              return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
            case "base64":
              return base64.encode(content);
            default:
              return utils.transformTo(type, content);
          }
        }
        function concat(type, dataArray) {
          var i3, index = 0, res = null, totalLength = 0;
          for (i3 = 0; i3 < dataArray.length; i3++) {
            totalLength += dataArray[i3].length;
          }
          switch (type) {
            case "string":
              return dataArray.join("");
            case "array":
              return Array.prototype.concat.apply([], dataArray);
            case "uint8array":
              res = new Uint8Array(totalLength);
              for (i3 = 0; i3 < dataArray.length; i3++) {
                res.set(dataArray[i3], index);
                index += dataArray[i3].length;
              }
              return res;
            case "nodebuffer":
              return Buffer.concat(dataArray);
            default:
              throw new Error("concat : unsupported type '" + type + "'");
          }
        }
        function accumulate(helper, updateCallback) {
          return new external.Promise(function(resolve, reject) {
            var dataArray = [];
            var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
            helper.on("data", function(data, meta) {
              dataArray.push(data);
              if (updateCallback) {
                updateCallback(meta);
              }
            }).on("error", function(err) {
              dataArray = [];
              reject(err);
            }).on("end", function() {
              try {
                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                resolve(result);
              } catch (e3) {
                reject(e3);
              }
              dataArray = [];
            }).resume();
          });
        }
        function StreamHelper(worker, outputType, mimeType) {
          var internalType = outputType;
          switch (outputType) {
            case "blob":
            case "arraybuffer":
              internalType = "uint8array";
              break;
            case "base64":
              internalType = "string";
              break;
          }
          try {
            this._internalType = internalType;
            this._outputType = outputType;
            this._mimeType = mimeType;
            utils.checkSupport(internalType);
            this._worker = worker.pipe(new ConvertWorker(internalType));
            worker.lock();
          } catch (e3) {
            this._worker = new GenericWorker("error");
            this._worker.error(e3);
          }
        }
        StreamHelper.prototype = {
          accumulate: function(updateCb) {
            return accumulate(this, updateCb);
          },
          on: function(evt, fn2) {
            var self2 = this;
            if (evt === "data") {
              this._worker.on(evt, function(chunk) {
                fn2.call(self2, chunk.data, chunk.meta);
              });
            } else {
              this._worker.on(evt, function() {
                utils.delay(fn2, arguments, self2);
              });
            }
            return this;
          },
          resume: function() {
            utils.delay(this._worker.resume, [], this._worker);
            return this;
          },
          pause: function() {
            this._worker.pause();
            return this;
          },
          toNodejsStream: function(updateCb) {
            utils.checkSupport("nodestream");
            if (this._outputType !== "nodebuffer") {
              throw new Error(this._outputType + " is not supported by this method");
            }
            return new NodejsStreamOutputAdapter(this, {
              objectMode: this._outputType !== "nodebuffer"
            }, updateCb);
          }
        };
        module4.exports = StreamHelper;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(require2, module4, exports3) {
        "use strict";
        exports3.base64 = true;
        exports3.array = true;
        exports3.string = true;
        exports3.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
        exports3.nodebuffer = typeof Buffer !== "undefined";
        exports3.uint8array = typeof Uint8Array !== "undefined";
        if (typeof ArrayBuffer === "undefined") {
          exports3.blob = false;
        } else {
          var buffer = new ArrayBuffer(0);
          try {
            exports3.blob = new Blob([buffer], {
              type: "application/zip"
            }).size === 0;
          } catch (e3) {
            try {
              var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
              var builder = new Builder();
              builder.append(buffer);
              exports3.blob = builder.getBlob("application/zip").size === 0;
            } catch (e4) {
              exports3.blob = false;
            }
          }
        }
        try {
          exports3.nodestream = !!require2("readable-stream").Readable;
        } catch (e3) {
          exports3.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("./utils");
        var support = require2("./support");
        var nodejsUtils = require2("./nodejsUtils");
        var GenericWorker = require2("./stream/GenericWorker");
        var _utf8len = new Array(256);
        for (var i3 = 0; i3 < 256; i3++) {
          _utf8len[i3] = i3 >= 252 ? 6 : i3 >= 248 ? 5 : i3 >= 240 ? 4 : i3 >= 224 ? 3 : i3 >= 192 ? 2 : 1;
        }
        _utf8len[254] = _utf8len[254] = 1;
        var string2buf = function(str) {
          var buf, c3, c22, m_pos, i4, str_len = str.length, buf_len = 0;
          for (m_pos = 0; m_pos < str_len; m_pos++) {
            c3 = str.charCodeAt(m_pos);
            if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
              c22 = str.charCodeAt(m_pos + 1);
              if ((c22 & 64512) === 56320) {
                c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
                m_pos++;
              }
            }
            buf_len += c3 < 128 ? 1 : c3 < 2048 ? 2 : c3 < 65536 ? 3 : 4;
          }
          if (support.uint8array) {
            buf = new Uint8Array(buf_len);
          } else {
            buf = new Array(buf_len);
          }
          for (i4 = 0, m_pos = 0; i4 < buf_len; m_pos++) {
            c3 = str.charCodeAt(m_pos);
            if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
              c22 = str.charCodeAt(m_pos + 1);
              if ((c22 & 64512) === 56320) {
                c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
                m_pos++;
              }
            }
            if (c3 < 128) {
              buf[i4++] = c3;
            } else if (c3 < 2048) {
              buf[i4++] = 192 | c3 >>> 6;
              buf[i4++] = 128 | c3 & 63;
            } else if (c3 < 65536) {
              buf[i4++] = 224 | c3 >>> 12;
              buf[i4++] = 128 | c3 >>> 6 & 63;
              buf[i4++] = 128 | c3 & 63;
            } else {
              buf[i4++] = 240 | c3 >>> 18;
              buf[i4++] = 128 | c3 >>> 12 & 63;
              buf[i4++] = 128 | c3 >>> 6 & 63;
              buf[i4++] = 128 | c3 & 63;
            }
          }
          return buf;
        };
        var utf8border = function(buf, max) {
          var pos;
          max = max || buf.length;
          if (max > buf.length) {
            max = buf.length;
          }
          pos = max - 1;
          while (pos >= 0 && (buf[pos] & 192) === 128) {
            pos--;
          }
          if (pos < 0) {
            return max;
          }
          if (pos === 0) {
            return max;
          }
          return pos + _utf8len[buf[pos]] > max ? pos : max;
        };
        var buf2string = function(buf) {
          var str, i4, out, c3, c_len;
          var len = buf.length;
          var utf16buf = new Array(len * 2);
          for (out = 0, i4 = 0; i4 < len; ) {
            c3 = buf[i4++];
            if (c3 < 128) {
              utf16buf[out++] = c3;
              continue;
            }
            c_len = _utf8len[c3];
            if (c_len > 4) {
              utf16buf[out++] = 65533;
              i4 += c_len - 1;
              continue;
            }
            c3 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i4 < len) {
              c3 = c3 << 6 | buf[i4++] & 63;
              c_len--;
            }
            if (c_len > 1) {
              utf16buf[out++] = 65533;
              continue;
            }
            if (c3 < 65536) {
              utf16buf[out++] = c3;
            } else {
              c3 -= 65536;
              utf16buf[out++] = 55296 | c3 >> 10 & 1023;
              utf16buf[out++] = 56320 | c3 & 1023;
            }
          }
          if (utf16buf.length !== out) {
            if (utf16buf.subarray) {
              utf16buf = utf16buf.subarray(0, out);
            } else {
              utf16buf.length = out;
            }
          }
          return utils.applyFromCharCode(utf16buf);
        };
        exports3.utf8encode = function utf8encode(str) {
          if (support.nodebuffer) {
            return nodejsUtils.newBufferFrom(str, "utf-8");
          }
          return string2buf(str);
        };
        exports3.utf8decode = function utf8decode(buf) {
          if (support.nodebuffer) {
            return utils.transformTo("nodebuffer", buf).toString("utf-8");
          }
          buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
          return buf2string(buf);
        };
        function Utf8DecodeWorker() {
          GenericWorker.call(this, "utf-8 decode");
          this.leftOver = null;
        }
        utils.inherits(Utf8DecodeWorker, GenericWorker);
        Utf8DecodeWorker.prototype.processChunk = function(chunk) {
          var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
          if (this.leftOver && this.leftOver.length) {
            if (support.uint8array) {
              var previousData = data;
              data = new Uint8Array(previousData.length + this.leftOver.length);
              data.set(this.leftOver, 0);
              data.set(previousData, this.leftOver.length);
            } else {
              data = this.leftOver.concat(data);
            }
            this.leftOver = null;
          }
          var nextBoundary = utf8border(data);
          var usableData = data;
          if (nextBoundary !== data.length) {
            if (support.uint8array) {
              usableData = data.subarray(0, nextBoundary);
              this.leftOver = data.subarray(nextBoundary, data.length);
            } else {
              usableData = data.slice(0, nextBoundary);
              this.leftOver = data.slice(nextBoundary, data.length);
            }
          }
          this.push({
            data: exports3.utf8decode(usableData),
            meta: chunk.meta
          });
        };
        Utf8DecodeWorker.prototype.flush = function() {
          if (this.leftOver && this.leftOver.length) {
            this.push({
              data: exports3.utf8decode(this.leftOver),
              meta: {}
            });
            this.leftOver = null;
          }
        };
        exports3.Utf8DecodeWorker = Utf8DecodeWorker;
        function Utf8EncodeWorker() {
          GenericWorker.call(this, "utf-8 encode");
        }
        utils.inherits(Utf8EncodeWorker, GenericWorker);
        Utf8EncodeWorker.prototype.processChunk = function(chunk) {
          this.push({
            data: exports3.utf8encode(chunk.data),
            meta: chunk.meta
          });
        };
        exports3.Utf8EncodeWorker = Utf8EncodeWorker;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(require2, module4, exports3) {
        "use strict";
        var support = require2("./support");
        var base64 = require2("./base64");
        var nodejsUtils = require2("./nodejsUtils");
        var setImmediate2 = require2("set-immediate-shim");
        var external = require2("./external");
        function string2binary(str) {
          var result = null;
          if (support.uint8array) {
            result = new Uint8Array(str.length);
          } else {
            result = new Array(str.length);
          }
          return stringToArrayLike(str, result);
        }
        exports3.newBlob = function(part, type) {
          exports3.checkSupport("blob");
          try {
            return new Blob([part], {
              type
            });
          } catch (e3) {
            try {
              var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
              var builder = new Builder();
              builder.append(part);
              return builder.getBlob(type);
            } catch (e4) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        function identity(input) {
          return input;
        }
        function stringToArrayLike(str, array) {
          for (var i3 = 0; i3 < str.length; ++i3) {
            array[i3] = str.charCodeAt(i3) & 255;
          }
          return array;
        }
        var arrayToStringHelper = {
          stringifyByChunk: function(array, type, chunk) {
            var result = [], k4 = 0, len = array.length;
            if (len <= chunk) {
              return String.fromCharCode.apply(null, array);
            }
            while (k4 < len) {
              if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k4, Math.min(k4 + chunk, len))));
              } else {
                result.push(String.fromCharCode.apply(null, array.subarray(k4, Math.min(k4 + chunk, len))));
              }
              k4 += chunk;
            }
            return result.join("");
          },
          stringifyByChar: function(array) {
            var resultStr = "";
            for (var i3 = 0; i3 < array.length; i3++) {
              resultStr += String.fromCharCode(array[i3]);
            }
            return resultStr;
          },
          applyCanBeUsed: {
            uint8array: function() {
              try {
                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
              } catch (e3) {
                return false;
              }
            }(),
            nodebuffer: function() {
              try {
                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
              } catch (e3) {
                return false;
              }
            }()
          }
        };
        function arrayLikeToString(array) {
          var chunk = 65536, type = exports3.getTypeOf(array), canUseApply = true;
          if (type === "uint8array") {
            canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
          } else if (type === "nodebuffer") {
            canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
          }
          if (canUseApply) {
            while (chunk > 1) {
              try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
              } catch (e3) {
                chunk = Math.floor(chunk / 2);
              }
            }
          }
          return arrayToStringHelper.stringifyByChar(array);
        }
        exports3.applyFromCharCode = arrayLikeToString;
        function arrayLikeToArrayLike(arrayFrom, arrayTo) {
          for (var i3 = 0; i3 < arrayFrom.length; i3++) {
            arrayTo[i3] = arrayFrom[i3];
          }
          return arrayTo;
        }
        var transform = {};
        transform["string"] = {
          "string": identity,
          "array": function(input) {
            return stringToArrayLike(input, new Array(input.length));
          },
          "arraybuffer": function(input) {
            return transform["string"]["uint8array"](input).buffer;
          },
          "uint8array": function(input) {
            return stringToArrayLike(input, new Uint8Array(input.length));
          },
          "nodebuffer": function(input) {
            return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
          }
        };
        transform["array"] = {
          "string": arrayLikeToString,
          "array": identity,
          "arraybuffer": function(input) {
            return new Uint8Array(input).buffer;
          },
          "uint8array": function(input) {
            return new Uint8Array(input);
          },
          "nodebuffer": function(input) {
            return nodejsUtils.newBufferFrom(input);
          }
        };
        transform["arraybuffer"] = {
          "string": function(input) {
            return arrayLikeToString(new Uint8Array(input));
          },
          "array": function(input) {
            return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
          },
          "arraybuffer": identity,
          "uint8array": function(input) {
            return new Uint8Array(input);
          },
          "nodebuffer": function(input) {
            return nodejsUtils.newBufferFrom(new Uint8Array(input));
          }
        };
        transform["uint8array"] = {
          "string": arrayLikeToString,
          "array": function(input) {
            return arrayLikeToArrayLike(input, new Array(input.length));
          },
          "arraybuffer": function(input) {
            return input.buffer;
          },
          "uint8array": identity,
          "nodebuffer": function(input) {
            return nodejsUtils.newBufferFrom(input);
          }
        };
        transform["nodebuffer"] = {
          "string": arrayLikeToString,
          "array": function(input) {
            return arrayLikeToArrayLike(input, new Array(input.length));
          },
          "arraybuffer": function(input) {
            return transform["nodebuffer"]["uint8array"](input).buffer;
          },
          "uint8array": function(input) {
            return arrayLikeToArrayLike(input, new Uint8Array(input.length));
          },
          "nodebuffer": identity
        };
        exports3.transformTo = function(outputType, input) {
          if (!input) {
            input = "";
          }
          if (!outputType) {
            return input;
          }
          exports3.checkSupport(outputType);
          var inputType = exports3.getTypeOf(input);
          var result = transform[inputType][outputType](input);
          return result;
        };
        exports3.resolve = function(path) {
          var parts = path.split("/");
          var result = [];
          for (var index = 0; index < parts.length; index++) {
            var part = parts[index];
            if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
              continue;
            } else if (part === "..") {
              result.pop();
            } else {
              result.push(part);
            }
          }
          return result.join("/");
        };
        exports3.getTypeOf = function(input) {
          if (typeof input === "string") {
            return "string";
          }
          if (Object.prototype.toString.call(input) === "[object Array]") {
            return "array";
          }
          if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
            return "nodebuffer";
          }
          if (support.uint8array && input instanceof Uint8Array) {
            return "uint8array";
          }
          if (support.arraybuffer && input instanceof ArrayBuffer) {
            return "arraybuffer";
          }
        };
        exports3.checkSupport = function(type) {
          var supported = support[type.toLowerCase()];
          if (!supported) {
            throw new Error(type + " is not supported by this platform");
          }
        };
        exports3.MAX_VALUE_16BITS = 65535;
        exports3.MAX_VALUE_32BITS = -1;
        exports3.pretty = function(str) {
          var res = "", code, i3;
          for (i3 = 0; i3 < (str || "").length; i3++) {
            code = str.charCodeAt(i3);
            res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
          }
          return res;
        };
        exports3.delay = function(callback, args, self2) {
          setImmediate2(function() {
            callback.apply(self2 || null, args || []);
          });
        };
        exports3.inherits = function(ctor, superCtor) {
          var Obj = function() {
          };
          Obj.prototype = superCtor.prototype;
          ctor.prototype = new Obj();
        };
        exports3.extend = function() {
          var result = {}, i3, attr;
          for (i3 = 0; i3 < arguments.length; i3++) {
            for (attr in arguments[i3]) {
              if (arguments[i3].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i3][attr];
              }
            }
          }
          return result;
        };
        exports3.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
          var promise = external.Promise.resolve(inputData).then(function(data) {
            var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
            if (isBlob && typeof FileReader !== "undefined") {
              return new external.Promise(function(resolve, reject) {
                var reader = new FileReader();
                reader.onload = function(e3) {
                  resolve(e3.target.result);
                };
                reader.onerror = function(e3) {
                  reject(e3.target.error);
                };
                reader.readAsArrayBuffer(data);
              });
            } else {
              return data;
            }
          });
          return promise.then(function(data) {
            var dataType = exports3.getTypeOf(data);
            if (!dataType) {
              return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
            }
            if (dataType === "arraybuffer") {
              data = exports3.transformTo("uint8array", data);
            } else if (dataType === "string") {
              if (isBase64) {
                data = base64.decode(data);
              } else if (isBinary) {
                if (isOptimizedBinaryString !== true) {
                  data = string2binary(data);
                }
              }
            }
            return data;
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function(require2, module4, exports3) {
        "use strict";
        var readerFor = require2("./reader/readerFor");
        var utils = require2("./utils");
        var sig = require2("./signature");
        var ZipEntry = require2("./zipEntry");
        var utf8 = require2("./utf8");
        var support = require2("./support");
        function ZipEntries(loadOptions) {
          this.files = [];
          this.loadOptions = loadOptions;
        }
        ZipEntries.prototype = {
          checkSignature: function(expectedSignature) {
            if (!this.reader.readAndCheckSignature(expectedSignature)) {
              this.reader.index -= 4;
              var signature = this.reader.readString(4);
              throw new Error("Corrupted zip or bug: unexpected signature (" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
            }
          },
          isSignature: function(askedIndex, expectedSignature) {
            var currentIndex = this.reader.index;
            this.reader.setIndex(askedIndex);
            var signature = this.reader.readString(4);
            var result = signature === expectedSignature;
            this.reader.setIndex(currentIndex);
            return result;
          },
          readBlockEndOfCentral: function() {
            this.diskNumber = this.reader.readInt(2);
            this.diskWithCentralDirStart = this.reader.readInt(2);
            this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
            this.centralDirRecords = this.reader.readInt(2);
            this.centralDirSize = this.reader.readInt(4);
            this.centralDirOffset = this.reader.readInt(4);
            this.zipCommentLength = this.reader.readInt(2);
            var zipComment = this.reader.readData(this.zipCommentLength);
            var decodeParamType = support.uint8array ? "uint8array" : "array";
            var decodeContent = utils.transformTo(decodeParamType, zipComment);
            this.zipComment = this.loadOptions.decodeFileName(decodeContent);
          },
          readBlockZip64EndOfCentral: function() {
            this.zip64EndOfCentralSize = this.reader.readInt(8);
            this.reader.skip(4);
            this.diskNumber = this.reader.readInt(4);
            this.diskWithCentralDirStart = this.reader.readInt(4);
            this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
            this.centralDirRecords = this.reader.readInt(8);
            this.centralDirSize = this.reader.readInt(8);
            this.centralDirOffset = this.reader.readInt(8);
            this.zip64ExtensibleData = {};
            var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
            while (index < extraDataSize) {
              extraFieldId = this.reader.readInt(2);
              extraFieldLength = this.reader.readInt(4);
              extraFieldValue = this.reader.readData(extraFieldLength);
              this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
              };
            }
          },
          readBlockZip64EndOfCentralLocator: function() {
            this.diskWithZip64CentralDirStart = this.reader.readInt(4);
            this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
            this.disksCount = this.reader.readInt(4);
            if (this.disksCount > 1) {
              throw new Error("Multi-volumes zip are not supported");
            }
          },
          readLocalFiles: function() {
            var i3, file;
            for (i3 = 0; i3 < this.files.length; i3++) {
              file = this.files[i3];
              this.reader.setIndex(file.localHeaderOffset);
              this.checkSignature(sig.LOCAL_FILE_HEADER);
              file.readLocalPart(this.reader);
              file.handleUTF8();
              file.processAttributes();
            }
          },
          readCentralDir: function() {
            var file;
            this.reader.setIndex(this.centralDirOffset);
            while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
              file = new ZipEntry({
                zip64: this.zip64
              }, this.loadOptions);
              file.readCentralPart(this.reader);
              this.files.push(file);
            }
            if (this.centralDirRecords !== this.files.length) {
              if (this.centralDirRecords !== 0 && this.files.length === 0) {
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
              } else {
              }
            }
          },
          readEndOfCentral: function() {
            var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
            if (offset < 0) {
              var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
              if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
              } else {
                throw new Error("Corrupted zip: can't find end of central directory");
              }
            }
            this.reader.setIndex(offset);
            var endOfCentralDirOffset = offset;
            this.checkSignature(sig.CENTRAL_DIRECTORY_END);
            this.readBlockEndOfCentral();
            if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
              this.zip64 = true;
              offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
              if (offset < 0) {
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
              }
              this.reader.setIndex(offset);
              this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
              this.readBlockZip64EndOfCentralLocator();
              if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                  throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                }
              }
              this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
              this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
              this.readBlockZip64EndOfCentral();
            }
            var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
            if (this.zip64) {
              expectedEndOfCentralDirOffset += 20;
              expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
            }
            var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
            if (extraBytes > 0) {
              if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
              } else {
                this.reader.zero = extraBytes;
              }
            } else if (extraBytes < 0) {
              throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
            }
          },
          prepareReader: function(data) {
            this.reader = readerFor(data);
          },
          load: function(data) {
            this.prepareReader(data);
            this.readEndOfCentral();
            this.readCentralDir();
            this.readLocalFiles();
          }
        };
        module4.exports = ZipEntries;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(require2, module4, exports3) {
        "use strict";
        var readerFor = require2("./reader/readerFor");
        var utils = require2("./utils");
        var CompressedObject = require2("./compressedObject");
        var crc32fn = require2("./crc32");
        var utf8 = require2("./utf8");
        var compressions = require2("./compressions");
        var support = require2("./support");
        var MADE_BY_DOS = 0;
        var MADE_BY_UNIX = 3;
        var findCompression = function(compressionMethod) {
          for (var method in compressions) {
            if (!compressions.hasOwnProperty(method)) {
              continue;
            }
            if (compressions[method].magic === compressionMethod) {
              return compressions[method];
            }
          }
          return null;
        };
        function ZipEntry(options, loadOptions) {
          this.options = options;
          this.loadOptions = loadOptions;
        }
        ZipEntry.prototype = {
          isEncrypted: function() {
            return (this.bitFlag & 1) === 1;
          },
          useUTF8: function() {
            return (this.bitFlag & 2048) === 2048;
          },
          readLocalPart: function(reader) {
            var compression, localExtraFieldsLength;
            reader.skip(22);
            this.fileNameLength = reader.readInt(2);
            localExtraFieldsLength = reader.readInt(2);
            this.fileName = reader.readData(this.fileNameLength);
            reader.skip(localExtraFieldsLength);
            if (this.compressedSize === -1 || this.uncompressedSize === -1) {
              throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
            }
            compression = findCompression(this.compressionMethod);
            if (compression === null) {
              throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
            }
            this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
          },
          readCentralPart: function(reader) {
            this.versionMadeBy = reader.readInt(2);
            reader.skip(2);
            this.bitFlag = reader.readInt(2);
            this.compressionMethod = reader.readString(2);
            this.date = reader.readDate();
            this.crc32 = reader.readInt(4);
            this.compressedSize = reader.readInt(4);
            this.uncompressedSize = reader.readInt(4);
            var fileNameLength = reader.readInt(2);
            this.extraFieldsLength = reader.readInt(2);
            this.fileCommentLength = reader.readInt(2);
            this.diskNumberStart = reader.readInt(2);
            this.internalFileAttributes = reader.readInt(2);
            this.externalFileAttributes = reader.readInt(4);
            this.localHeaderOffset = reader.readInt(4);
            if (this.isEncrypted()) {
              throw new Error("Encrypted zip are not supported");
            }
            reader.skip(fileNameLength);
            this.readExtraFields(reader);
            this.parseZIP64ExtraField(reader);
            this.fileComment = reader.readData(this.fileCommentLength);
          },
          processAttributes: function() {
            this.unixPermissions = null;
            this.dosPermissions = null;
            var madeBy = this.versionMadeBy >> 8;
            this.dir = this.externalFileAttributes & 16 ? true : false;
            if (madeBy === MADE_BY_DOS) {
              this.dosPermissions = this.externalFileAttributes & 63;
            }
            if (madeBy === MADE_BY_UNIX) {
              this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
            }
            if (!this.dir && this.fileNameStr.slice(-1) === "/") {
              this.dir = true;
            }
          },
          parseZIP64ExtraField: function(reader) {
            if (!this.extraFields[1]) {
              return;
            }
            var extraReader = readerFor(this.extraFields[1].value);
            if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
              this.uncompressedSize = extraReader.readInt(8);
            }
            if (this.compressedSize === utils.MAX_VALUE_32BITS) {
              this.compressedSize = extraReader.readInt(8);
            }
            if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
              this.localHeaderOffset = extraReader.readInt(8);
            }
            if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
              this.diskNumberStart = extraReader.readInt(4);
            }
          },
          readExtraFields: function(reader) {
            var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
            if (!this.extraFields) {
              this.extraFields = {};
            }
            while (reader.index + 4 < end) {
              extraFieldId = reader.readInt(2);
              extraFieldLength = reader.readInt(2);
              extraFieldValue = reader.readData(extraFieldLength);
              this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
              };
            }
            reader.setIndex(end);
          },
          handleUTF8: function() {
            var decodeParamType = support.uint8array ? "uint8array" : "array";
            if (this.useUTF8()) {
              this.fileNameStr = utf8.utf8decode(this.fileName);
              this.fileCommentStr = utf8.utf8decode(this.fileComment);
            } else {
              var upath = this.findExtraFieldUnicodePath();
              if (upath !== null) {
                this.fileNameStr = upath;
              } else {
                var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
              }
              var ucomment = this.findExtraFieldUnicodeComment();
              if (ucomment !== null) {
                this.fileCommentStr = ucomment;
              } else {
                var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
              }
            }
          },
          findExtraFieldUnicodePath: function() {
            var upathField = this.extraFields[28789];
            if (upathField) {
              var extraReader = readerFor(upathField.value);
              if (extraReader.readInt(1) !== 1) {
                return null;
              }
              if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                return null;
              }
              return utf8.utf8decode(extraReader.readData(upathField.length - 5));
            }
            return null;
          },
          findExtraFieldUnicodeComment: function() {
            var ucommentField = this.extraFields[25461];
            if (ucommentField) {
              var extraReader = readerFor(ucommentField.value);
              if (extraReader.readInt(1) !== 1) {
                return null;
              }
              if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                return null;
              }
              return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
            }
            return null;
          }
        };
        module4.exports = ZipEntry;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(require2, module4, exports3) {
        "use strict";
        var StreamHelper = require2("./stream/StreamHelper");
        var DataWorker = require2("./stream/DataWorker");
        var utf8 = require2("./utf8");
        var CompressedObject = require2("./compressedObject");
        var GenericWorker = require2("./stream/GenericWorker");
        var ZipObject = function(name, data, options) {
          this.name = name;
          this.dir = options.dir;
          this.date = options.date;
          this.comment = options.comment;
          this.unixPermissions = options.unixPermissions;
          this.dosPermissions = options.dosPermissions;
          this._data = data;
          this._dataBinary = options.binary;
          this.options = {
            compression: options.compression,
            compressionOptions: options.compressionOptions
          };
        };
        ZipObject.prototype = {
          internalStream: function(type) {
            var result = null, outputType = "string";
            try {
              if (!type) {
                throw new Error("No output type specified.");
              }
              outputType = type.toLowerCase();
              var askUnicodeString = outputType === "string" || outputType === "text";
              if (outputType === "binarystring" || outputType === "text") {
                outputType = "string";
              }
              result = this._decompressWorker();
              var isUnicodeString = !this._dataBinary;
              if (isUnicodeString && !askUnicodeString) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
              }
              if (!isUnicodeString && askUnicodeString) {
                result = result.pipe(new utf8.Utf8DecodeWorker());
              }
            } catch (e3) {
              result = new GenericWorker("error");
              result.error(e3);
            }
            return new StreamHelper(result, outputType, "");
          },
          async: function(type, onUpdate) {
            return this.internalStream(type).accumulate(onUpdate);
          },
          nodeStream: function(type, onUpdate) {
            return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
          },
          _compressWorker: function(compression, compressionOptions) {
            if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
              return this._data.getCompressedWorker();
            } else {
              var result = this._decompressWorker();
              if (!this._dataBinary) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
              }
              return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
            }
          },
          _decompressWorker: function() {
            if (this._data instanceof CompressedObject) {
              return this._data.getContentWorker();
            } else if (this._data instanceof GenericWorker) {
              return this._data;
            } else {
              return new DataWorker(this._data);
            }
          }
        };
        var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
        var removedFn = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        };
        for (var i3 = 0; i3 < removedMethods.length; i3++) {
          ZipObject.prototype[removedMethods[i3]] = removedFn;
        }
        module4.exports = ZipObject;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(require2, module4, exports3) {
        (function(global2) {
          "use strict";
          var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
          var scheduleDrain;
          {
            if (Mutation) {
              var called = 0;
              var observer = new Mutation(nextTick);
              var element = global2.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              scheduleDrain = function() {
                element.data = called = ++called % 2;
              };
            } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
              var channel = new global2.MessageChannel();
              channel.port1.onmessage = nextTick;
              scheduleDrain = function() {
                channel.port2.postMessage(0);
              };
            } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
              scheduleDrain = function() {
                var scriptEl = global2.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  nextTick();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global2.document.documentElement.appendChild(scriptEl);
              };
            } else {
              scheduleDrain = function() {
                setTimeout(nextTick, 0);
              };
            }
          }
          var draining;
          var queue = [];
          function nextTick() {
            draining = true;
            var i3, oldQueue;
            var len = queue.length;
            while (len) {
              oldQueue = queue;
              queue = [];
              i3 = -1;
              while (++i3 < len) {
                oldQueue[i3]();
              }
              len = queue.length;
            }
            draining = false;
          }
          module4.exports = immediate;
          function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
              scheduleDrain();
            }
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 37: [function(require2, module4, exports3) {
        "use strict";
        var immediate = require2("immediate");
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module4.exports = Promise2;
        function Promise2(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise2.prototype["finally"] = function(callback) {
          if (typeof callback !== "function") {
            return this;
          }
          var p3 = this.constructor;
          return this.then(resolve2, reject2);
          function resolve2(value) {
            function yes() {
              return value;
            }
            return p3.resolve(callback()).then(yes);
          }
          function reject2(reason) {
            function no() {
              throw reason;
            }
            return p3.resolve(callback()).then(no);
          }
        };
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap(this.promise, this.onRejected, value);
        };
        function unwrap(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e3) {
              return handlers.reject(promise, e3);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i3 = -1;
            var len = self2.queue.length;
            while (++i3 < len) {
              self2.queue[i3].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i3 = -1;
          var len = self2.queue.length;
          while (++i3 < len) {
            self2.queue[i3].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e3) {
            out.status = "error";
            out.value = e3;
          }
          return out;
        }
        Promise2.resolve = resolve;
        function resolve(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        Promise2.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        Promise2.all = all;
        function all(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i3 = -1;
          var promise = new this(INTERNAL);
          while (++i3 < len) {
            allResolver(iterable[i3], i3);
          }
          return promise;
          function allResolver(value, i4) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i4] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        Promise2.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i3 = -1;
          var promise = new this(INTERNAL);
          while (++i3 < len) {
            resolver(iterable[i3]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "immediate": 36 }], 38: [function(require2, module4, exports3) {
        "use strict";
        var assign = require2("./lib/utils/common").assign;
        var deflate = require2("./lib/deflate");
        var inflate = require2("./lib/inflate");
        var constants = require2("./lib/zlib/constants");
        var pako = {};
        assign(pako, deflate, inflate, constants);
        module4.exports = pako;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(require2, module4, exports3) {
        "use strict";
        var zlib_deflate = require2("./zlib/deflate");
        var utils = require2("./utils/common");
        var strings = require2("./utils/strings");
        var msg = require2("./zlib/messages");
        var ZStream = require2("./zlib/zstream");
        var toString = Object.prototype.toString;
        var Z_NO_FLUSH = 0;
        var Z_FINISH = 4;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_SYNC_FLUSH = 2;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_DEFLATED = 8;
        function Deflate(options) {
          if (!(this instanceof Deflate))
            return new Deflate(options);
          this.options = utils.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits > 0) {
            opt.windowBits = -opt.windowBits;
          } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
            opt.windowBits += 16;
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new ZStream();
          this.strm.avail_out = 0;
          var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          if (opt.header) {
            zlib_deflate.deflateSetHeader(this.strm, opt.header);
          }
          if (opt.dictionary) {
            var dict;
            if (typeof opt.dictionary === "string") {
              dict = strings.string2buf(opt.dictionary);
            } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
              dict = new Uint8Array(opt.dictionary);
            } else {
              dict = opt.dictionary;
            }
            status = zlib_deflate.deflateSetDictionary(this.strm, dict);
            if (status !== Z_OK) {
              throw new Error(msg[status]);
            }
            this._dict_set = true;
          }
        }
        Deflate.prototype.push = function(data, mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var status, _mode;
          if (this.ended) {
            return false;
          }
          _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
          if (typeof data === "string") {
            strm.input = strings.string2buf(data);
          } else if (toString.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          do {
            if (strm.avail_out === 0) {
              strm.output = new utils.Buf8(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = zlib_deflate.deflate(strm, _mode);
            if (status !== Z_STREAM_END && status !== Z_OK) {
              this.onEnd(status);
              this.ended = true;
              return false;
            }
            if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
              }
            }
          } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
          if (_mode === Z_FINISH) {
            status = zlib_deflate.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK;
          }
          if (_mode === Z_SYNC_FLUSH) {
            this.onEnd(Z_OK);
            strm.avail_out = 0;
            return true;
          }
          return true;
        };
        Deflate.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Deflate.prototype.onEnd = function(status) {
          if (status === Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = utils.flattenChunks(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function deflate(input, options) {
          var deflator = new Deflate(options);
          deflator.push(input, true);
          if (deflator.err) {
            throw deflator.msg || msg[deflator.err];
          }
          return deflator.result;
        }
        function deflateRaw(input, options) {
          options = options || {};
          options.raw = true;
          return deflate(input, options);
        }
        function gzip(input, options) {
          options = options || {};
          options.gzip = true;
          return deflate(input, options);
        }
        exports3.Deflate = Deflate;
        exports3.deflate = deflate;
        exports3.deflateRaw = deflateRaw;
        exports3.gzip = gzip;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(require2, module4, exports3) {
        "use strict";
        var zlib_inflate = require2("./zlib/inflate");
        var utils = require2("./utils/common");
        var strings = require2("./utils/strings");
        var c3 = require2("./zlib/constants");
        var msg = require2("./zlib/messages");
        var ZStream = require2("./zlib/zstream");
        var GZheader = require2("./zlib/gzheader");
        var toString = Object.prototype.toString;
        function Inflate(options) {
          if (!(this instanceof Inflate))
            return new Inflate(options);
          this.options = utils.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) {
              opt.windowBits = -15;
            }
          }
          if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
            opt.windowBits += 32;
          }
          if (opt.windowBits > 15 && opt.windowBits < 48) {
            if ((opt.windowBits & 15) === 0) {
              opt.windowBits |= 15;
            }
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new ZStream();
          this.strm.avail_out = 0;
          var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
          if (status !== c3.Z_OK) {
            throw new Error(msg[status]);
          }
          this.header = new GZheader();
          zlib_inflate.inflateGetHeader(this.strm, this.header);
        }
        Inflate.prototype.push = function(data, mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var dictionary = this.options.dictionary;
          var status, _mode;
          var next_out_utf8, tail, utf8str;
          var dict;
          var allowBufError = false;
          if (this.ended) {
            return false;
          }
          _mode = mode === ~~mode ? mode : mode === true ? c3.Z_FINISH : c3.Z_NO_FLUSH;
          if (typeof data === "string") {
            strm.input = strings.binstring2buf(data);
          } else if (toString.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          do {
            if (strm.avail_out === 0) {
              strm.output = new utils.Buf8(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = zlib_inflate.inflate(strm, c3.Z_NO_FLUSH);
            if (status === c3.Z_NEED_DICT && dictionary) {
              if (typeof dictionary === "string") {
                dict = strings.string2buf(dictionary);
              } else if (toString.call(dictionary) === "[object ArrayBuffer]") {
                dict = new Uint8Array(dictionary);
              } else {
                dict = dictionary;
              }
              status = zlib_inflate.inflateSetDictionary(this.strm, dict);
            }
            if (status === c3.Z_BUF_ERROR && allowBufError === true) {
              status = c3.Z_OK;
              allowBufError = false;
            }
            if (status !== c3.Z_STREAM_END && status !== c3.Z_OK) {
              this.onEnd(status);
              this.ended = true;
              return false;
            }
            if (strm.next_out) {
              if (strm.avail_out === 0 || status === c3.Z_STREAM_END || strm.avail_in === 0 && (_mode === c3.Z_FINISH || _mode === c3.Z_SYNC_FLUSH)) {
                if (this.options.to === "string") {
                  next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                  tail = strm.next_out - next_out_utf8;
                  utf8str = strings.buf2string(strm.output, next_out_utf8);
                  strm.next_out = tail;
                  strm.avail_out = chunkSize - tail;
                  if (tail) {
                    utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                  }
                  this.onData(utf8str);
                } else {
                  this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                }
              }
            }
            if (strm.avail_in === 0 && strm.avail_out === 0) {
              allowBufError = true;
            }
          } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c3.Z_STREAM_END);
          if (status === c3.Z_STREAM_END) {
            _mode = c3.Z_FINISH;
          }
          if (_mode === c3.Z_FINISH) {
            status = zlib_inflate.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === c3.Z_OK;
          }
          if (_mode === c3.Z_SYNC_FLUSH) {
            this.onEnd(c3.Z_OK);
            strm.avail_out = 0;
            return true;
          }
          return true;
        };
        Inflate.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Inflate.prototype.onEnd = function(status) {
          if (status === c3.Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = utils.flattenChunks(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function inflate(input, options) {
          var inflator = new Inflate(options);
          inflator.push(input, true);
          if (inflator.err) {
            throw inflator.msg || msg[inflator.err];
          }
          return inflator.result;
        }
        function inflateRaw(input, options) {
          options = options || {};
          options.raw = true;
          return inflate(input, options);
        }
        exports3.Inflate = Inflate;
        exports3.inflate = inflate;
        exports3.inflateRaw = inflateRaw;
        exports3.ungzip = inflate;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(require2, module4, exports3) {
        "use strict";
        var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
        exports3.assign = function(obj) {
          var sources = Array.prototype.slice.call(arguments, 1);
          while (sources.length) {
            var source = sources.shift();
            if (!source) {
              continue;
            }
            if (typeof source !== "object") {
              throw new TypeError(source + "must be non-object");
            }
            for (var p3 in source) {
              if (source.hasOwnProperty(p3)) {
                obj[p3] = source[p3];
              }
            }
          }
          return obj;
        };
        exports3.shrinkBuf = function(buf, size) {
          if (buf.length === size) {
            return buf;
          }
          if (buf.subarray) {
            return buf.subarray(0, size);
          }
          buf.length = size;
          return buf;
        };
        var fnTyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            if (src.subarray && dest.subarray) {
              dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
              return;
            }
            for (var i3 = 0; i3 < len; i3++) {
              dest[dest_offs + i3] = src[src_offs + i3];
            }
          },
          flattenChunks: function(chunks) {
            var i3, l3, len, pos, chunk, result;
            len = 0;
            for (i3 = 0, l3 = chunks.length; i3 < l3; i3++) {
              len += chunks[i3].length;
            }
            result = new Uint8Array(len);
            pos = 0;
            for (i3 = 0, l3 = chunks.length; i3 < l3; i3++) {
              chunk = chunks[i3];
              result.set(chunk, pos);
              pos += chunk.length;
            }
            return result;
          }
        };
        var fnUntyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            for (var i3 = 0; i3 < len; i3++) {
              dest[dest_offs + i3] = src[src_offs + i3];
            }
          },
          flattenChunks: function(chunks) {
            return [].concat.apply([], chunks);
          }
        };
        exports3.setTyped = function(on2) {
          if (on2) {
            exports3.Buf8 = Uint8Array;
            exports3.Buf16 = Uint16Array;
            exports3.Buf32 = Int32Array;
            exports3.assign(exports3, fnTyped);
          } else {
            exports3.Buf8 = Array;
            exports3.Buf16 = Array;
            exports3.Buf32 = Array;
            exports3.assign(exports3, fnUntyped);
          }
        };
        exports3.setTyped(TYPED_OK);
      }, {}], 42: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("./common");
        var STR_APPLY_OK = true;
        var STR_APPLY_UIA_OK = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (__) {
          STR_APPLY_OK = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (__) {
          STR_APPLY_UIA_OK = false;
        }
        var _utf8len = new utils.Buf8(256);
        for (var q4 = 0; q4 < 256; q4++) {
          _utf8len[q4] = q4 >= 252 ? 6 : q4 >= 248 ? 5 : q4 >= 240 ? 4 : q4 >= 224 ? 3 : q4 >= 192 ? 2 : 1;
        }
        _utf8len[254] = _utf8len[254] = 1;
        exports3.string2buf = function(str) {
          var buf, c3, c22, m_pos, i3, str_len = str.length, buf_len = 0;
          for (m_pos = 0; m_pos < str_len; m_pos++) {
            c3 = str.charCodeAt(m_pos);
            if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
              c22 = str.charCodeAt(m_pos + 1);
              if ((c22 & 64512) === 56320) {
                c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
                m_pos++;
              }
            }
            buf_len += c3 < 128 ? 1 : c3 < 2048 ? 2 : c3 < 65536 ? 3 : 4;
          }
          buf = new utils.Buf8(buf_len);
          for (i3 = 0, m_pos = 0; i3 < buf_len; m_pos++) {
            c3 = str.charCodeAt(m_pos);
            if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
              c22 = str.charCodeAt(m_pos + 1);
              if ((c22 & 64512) === 56320) {
                c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
                m_pos++;
              }
            }
            if (c3 < 128) {
              buf[i3++] = c3;
            } else if (c3 < 2048) {
              buf[i3++] = 192 | c3 >>> 6;
              buf[i3++] = 128 | c3 & 63;
            } else if (c3 < 65536) {
              buf[i3++] = 224 | c3 >>> 12;
              buf[i3++] = 128 | c3 >>> 6 & 63;
              buf[i3++] = 128 | c3 & 63;
            } else {
              buf[i3++] = 240 | c3 >>> 18;
              buf[i3++] = 128 | c3 >>> 12 & 63;
              buf[i3++] = 128 | c3 >>> 6 & 63;
              buf[i3++] = 128 | c3 & 63;
            }
          }
          return buf;
        };
        function buf2binstring(buf, len) {
          if (len < 65537) {
            if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
              return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
            }
          }
          var result = "";
          for (var i3 = 0; i3 < len; i3++) {
            result += String.fromCharCode(buf[i3]);
          }
          return result;
        }
        exports3.buf2binstring = function(buf) {
          return buf2binstring(buf, buf.length);
        };
        exports3.binstring2buf = function(str) {
          var buf = new utils.Buf8(str.length);
          for (var i3 = 0, len = buf.length; i3 < len; i3++) {
            buf[i3] = str.charCodeAt(i3);
          }
          return buf;
        };
        exports3.buf2string = function(buf, max) {
          var i3, out, c3, c_len;
          var len = max || buf.length;
          var utf16buf = new Array(len * 2);
          for (out = 0, i3 = 0; i3 < len; ) {
            c3 = buf[i3++];
            if (c3 < 128) {
              utf16buf[out++] = c3;
              continue;
            }
            c_len = _utf8len[c3];
            if (c_len > 4) {
              utf16buf[out++] = 65533;
              i3 += c_len - 1;
              continue;
            }
            c3 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i3 < len) {
              c3 = c3 << 6 | buf[i3++] & 63;
              c_len--;
            }
            if (c_len > 1) {
              utf16buf[out++] = 65533;
              continue;
            }
            if (c3 < 65536) {
              utf16buf[out++] = c3;
            } else {
              c3 -= 65536;
              utf16buf[out++] = 55296 | c3 >> 10 & 1023;
              utf16buf[out++] = 56320 | c3 & 1023;
            }
          }
          return buf2binstring(utf16buf, out);
        };
        exports3.utf8border = function(buf, max) {
          var pos;
          max = max || buf.length;
          if (max > buf.length) {
            max = buf.length;
          }
          pos = max - 1;
          while (pos >= 0 && (buf[pos] & 192) === 128) {
            pos--;
          }
          if (pos < 0) {
            return max;
          }
          if (pos === 0) {
            return max;
          }
          return pos + _utf8len[buf[pos]] > max ? pos : max;
        };
      }, { "./common": 41 }], 43: [function(require2, module4, exports3) {
        "use strict";
        function adler32(adler, buf, len, pos) {
          var s1 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n2 = 0;
          while (len !== 0) {
            n2 = len > 2e3 ? 2e3 : len;
            len -= n2;
            do {
              s1 = s1 + buf[pos++] | 0;
              s22 = s22 + s1 | 0;
            } while (--n2);
            s1 %= 65521;
            s22 %= 65521;
          }
          return s1 | s22 << 16 | 0;
        }
        module4.exports = adler32;
      }, {}], 44: [function(require2, module4, exports3) {
        "use strict";
        module4.exports = {
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          Z_BUF_ERROR: -5,
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          Z_BINARY: 0,
          Z_TEXT: 1,
          Z_UNKNOWN: 2,
          Z_DEFLATED: 8
        };
      }, {}], 45: [function(require2, module4, exports3) {
        "use strict";
        function makeTable() {
          var c3, table = [];
          for (var n2 = 0; n2 < 256; n2++) {
            c3 = n2;
            for (var k4 = 0; k4 < 8; k4++) {
              c3 = c3 & 1 ? 3988292384 ^ c3 >>> 1 : c3 >>> 1;
            }
            table[n2] = c3;
          }
          return table;
        }
        var crcTable = makeTable();
        function crc32(crc, buf, len, pos) {
          var t3 = crcTable, end = pos + len;
          crc ^= -1;
          for (var i3 = pos; i3 < end; i3++) {
            crc = crc >>> 8 ^ t3[(crc ^ buf[i3]) & 255];
          }
          return crc ^ -1;
        }
        module4.exports = crc32;
      }, {}], 46: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var trees = require2("./trees");
        var adler32 = require2("./adler32");
        var crc32 = require2("./crc32");
        var msg = require2("./messages");
        var Z_NO_FLUSH = 0;
        var Z_PARTIAL_FLUSH = 1;
        var Z_FULL_FLUSH = 3;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_BUF_ERROR = -5;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_FILTERED = 1;
        var Z_HUFFMAN_ONLY = 2;
        var Z_RLE = 3;
        var Z_FIXED = 4;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_UNKNOWN = 2;
        var Z_DEFLATED = 8;
        var MAX_MEM_LEVEL = 9;
        var MAX_WBITS = 15;
        var DEF_MEM_LEVEL = 8;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
        var PRESET_DICT = 32;
        var INIT_STATE = 42;
        var EXTRA_STATE = 69;
        var NAME_STATE = 73;
        var COMMENT_STATE = 91;
        var HCRC_STATE = 103;
        var BUSY_STATE = 113;
        var FINISH_STATE = 666;
        var BS_NEED_MORE = 1;
        var BS_BLOCK_DONE = 2;
        var BS_FINISH_STARTED = 3;
        var BS_FINISH_DONE = 4;
        var OS_CODE = 3;
        function err(strm, errorCode) {
          strm.msg = msg[errorCode];
          return errorCode;
        }
        function rank(f3) {
          return (f3 << 1) - (f3 > 4 ? 9 : 0);
        }
        function zero(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        function flush_pending(strm) {
          var s3 = strm.state;
          var len = s3.pending;
          if (len > strm.avail_out) {
            len = strm.avail_out;
          }
          if (len === 0) {
            return;
          }
          utils.arraySet(strm.output, s3.pending_buf, s3.pending_out, len, strm.next_out);
          strm.next_out += len;
          s3.pending_out += len;
          strm.total_out += len;
          strm.avail_out -= len;
          s3.pending -= len;
          if (s3.pending === 0) {
            s3.pending_out = 0;
          }
        }
        function flush_block_only(s3, last) {
          trees._tr_flush_block(s3, s3.block_start >= 0 ? s3.block_start : -1, s3.strstart - s3.block_start, last);
          s3.block_start = s3.strstart;
          flush_pending(s3.strm);
        }
        function put_byte(s3, b3) {
          s3.pending_buf[s3.pending++] = b3;
        }
        function putShortMSB(s3, b3) {
          s3.pending_buf[s3.pending++] = b3 >>> 8 & 255;
          s3.pending_buf[s3.pending++] = b3 & 255;
        }
        function read_buf(strm, buf, start, size) {
          var len = strm.avail_in;
          if (len > size) {
            len = size;
          }
          if (len === 0) {
            return 0;
          }
          strm.avail_in -= len;
          utils.arraySet(buf, strm.input, strm.next_in, len, start);
          if (strm.state.wrap === 1) {
            strm.adler = adler32(strm.adler, buf, len, start);
          } else if (strm.state.wrap === 2) {
            strm.adler = crc32(strm.adler, buf, len, start);
          }
          strm.next_in += len;
          strm.total_in += len;
          return len;
        }
        function longest_match(s3, cur_match) {
          var chain_length = s3.max_chain_length;
          var scan = s3.strstart;
          var match;
          var len;
          var best_len = s3.prev_length;
          var nice_match = s3.nice_match;
          var limit = s3.strstart > s3.w_size - MIN_LOOKAHEAD ? s3.strstart - (s3.w_size - MIN_LOOKAHEAD) : 0;
          var _win = s3.window;
          var wmask = s3.w_mask;
          var prev = s3.prev;
          var strend = s3.strstart + MAX_MATCH;
          var scan_end1 = _win[scan + best_len - 1];
          var scan_end = _win[scan + best_len];
          if (s3.prev_length >= s3.good_match) {
            chain_length >>= 2;
          }
          if (nice_match > s3.lookahead) {
            nice_match = s3.lookahead;
          }
          do {
            match = cur_match;
            if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
              continue;
            }
            scan += 2;
            match++;
            do {
            } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
              s3.match_start = cur_match;
              best_len = len;
              if (len >= nice_match) {
                break;
              }
              scan_end1 = _win[scan + best_len - 1];
              scan_end = _win[scan + best_len];
            }
          } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
          if (best_len <= s3.lookahead) {
            return best_len;
          }
          return s3.lookahead;
        }
        function fill_window(s3) {
          var _w_size = s3.w_size;
          var p3, n2, m3, more, str;
          do {
            more = s3.window_size - s3.lookahead - s3.strstart;
            if (s3.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
              utils.arraySet(s3.window, s3.window, _w_size, _w_size, 0);
              s3.match_start -= _w_size;
              s3.strstart -= _w_size;
              s3.block_start -= _w_size;
              n2 = s3.hash_size;
              p3 = n2;
              do {
                m3 = s3.head[--p3];
                s3.head[p3] = m3 >= _w_size ? m3 - _w_size : 0;
              } while (--n2);
              n2 = _w_size;
              p3 = n2;
              do {
                m3 = s3.prev[--p3];
                s3.prev[p3] = m3 >= _w_size ? m3 - _w_size : 0;
              } while (--n2);
              more += _w_size;
            }
            if (s3.strm.avail_in === 0) {
              break;
            }
            n2 = read_buf(s3.strm, s3.window, s3.strstart + s3.lookahead, more);
            s3.lookahead += n2;
            if (s3.lookahead + s3.insert >= MIN_MATCH) {
              str = s3.strstart - s3.insert;
              s3.ins_h = s3.window[str];
              s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[str + 1]) & s3.hash_mask;
              while (s3.insert) {
                s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[str + MIN_MATCH - 1]) & s3.hash_mask;
                s3.prev[str & s3.w_mask] = s3.head[s3.ins_h];
                s3.head[s3.ins_h] = str;
                str++;
                s3.insert--;
                if (s3.lookahead + s3.insert < MIN_MATCH) {
                  break;
                }
              }
            }
          } while (s3.lookahead < MIN_LOOKAHEAD && s3.strm.avail_in !== 0);
        }
        function deflate_stored(s3, flush) {
          var max_block_size = 65535;
          if (max_block_size > s3.pending_buf_size - 5) {
            max_block_size = s3.pending_buf_size - 5;
          }
          for (; ; ) {
            if (s3.lookahead <= 1) {
              fill_window(s3);
              if (s3.lookahead === 0 && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s3.lookahead === 0) {
                break;
              }
            }
            s3.strstart += s3.lookahead;
            s3.lookahead = 0;
            var max_start = s3.block_start + max_block_size;
            if (s3.strstart === 0 || s3.strstart >= max_start) {
              s3.lookahead = s3.strstart - max_start;
              s3.strstart = max_start;
              flush_block_only(s3, false);
              if (s3.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            if (s3.strstart - s3.block_start >= s3.w_size - MIN_LOOKAHEAD) {
              flush_block_only(s3, false);
              if (s3.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s3.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s3, true);
            if (s3.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s3.strstart > s3.block_start) {
            flush_block_only(s3, false);
            if (s3.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_NEED_MORE;
        }
        function deflate_fast(s3, flush) {
          var hash_head;
          var bflush;
          for (; ; ) {
            if (s3.lookahead < MIN_LOOKAHEAD) {
              fill_window(s3);
              if (s3.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s3.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s3.lookahead >= MIN_MATCH) {
              s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[s3.strstart + MIN_MATCH - 1]) & s3.hash_mask;
              hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h];
              s3.head[s3.ins_h] = s3.strstart;
            }
            if (hash_head !== 0 && s3.strstart - hash_head <= s3.w_size - MIN_LOOKAHEAD) {
              s3.match_length = longest_match(s3, hash_head);
            }
            if (s3.match_length >= MIN_MATCH) {
              bflush = trees._tr_tally(s3, s3.strstart - s3.match_start, s3.match_length - MIN_MATCH);
              s3.lookahead -= s3.match_length;
              if (s3.match_length <= s3.max_lazy_match && s3.lookahead >= MIN_MATCH) {
                s3.match_length--;
                do {
                  s3.strstart++;
                  s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[s3.strstart + MIN_MATCH - 1]) & s3.hash_mask;
                  hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h];
                  s3.head[s3.ins_h] = s3.strstart;
                } while (--s3.match_length !== 0);
                s3.strstart++;
              } else {
                s3.strstart += s3.match_length;
                s3.match_length = 0;
                s3.ins_h = s3.window[s3.strstart];
                s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[s3.strstart + 1]) & s3.hash_mask;
              }
            } else {
              bflush = trees._tr_tally(s3, 0, s3.window[s3.strstart]);
              s3.lookahead--;
              s3.strstart++;
            }
            if (bflush) {
              flush_block_only(s3, false);
              if (s3.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s3.insert = s3.strstart < MIN_MATCH - 1 ? s3.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH) {
            flush_block_only(s3, true);
            if (s3.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s3.last_lit) {
            flush_block_only(s3, false);
            if (s3.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_slow(s3, flush) {
          var hash_head;
          var bflush;
          var max_insert;
          for (; ; ) {
            if (s3.lookahead < MIN_LOOKAHEAD) {
              fill_window(s3);
              if (s3.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s3.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s3.lookahead >= MIN_MATCH) {
              s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[s3.strstart + MIN_MATCH - 1]) & s3.hash_mask;
              hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h];
              s3.head[s3.ins_h] = s3.strstart;
            }
            s3.prev_length = s3.match_length;
            s3.prev_match = s3.match_start;
            s3.match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && s3.prev_length < s3.max_lazy_match && s3.strstart - hash_head <= s3.w_size - MIN_LOOKAHEAD) {
              s3.match_length = longest_match(s3, hash_head);
              if (s3.match_length <= 5 && (s3.strategy === Z_FILTERED || s3.match_length === MIN_MATCH && s3.strstart - s3.match_start > 4096)) {
                s3.match_length = MIN_MATCH - 1;
              }
            }
            if (s3.prev_length >= MIN_MATCH && s3.match_length <= s3.prev_length) {
              max_insert = s3.strstart + s3.lookahead - MIN_MATCH;
              bflush = trees._tr_tally(s3, s3.strstart - 1 - s3.prev_match, s3.prev_length - MIN_MATCH);
              s3.lookahead -= s3.prev_length - 1;
              s3.prev_length -= 2;
              do {
                if (++s3.strstart <= max_insert) {
                  s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[s3.strstart + MIN_MATCH - 1]) & s3.hash_mask;
                  hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h];
                  s3.head[s3.ins_h] = s3.strstart;
                }
              } while (--s3.prev_length !== 0);
              s3.match_available = 0;
              s3.match_length = MIN_MATCH - 1;
              s3.strstart++;
              if (bflush) {
                flush_block_only(s3, false);
                if (s3.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            } else if (s3.match_available) {
              bflush = trees._tr_tally(s3, 0, s3.window[s3.strstart - 1]);
              if (bflush) {
                flush_block_only(s3, false);
              }
              s3.strstart++;
              s3.lookahead--;
              if (s3.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            } else {
              s3.match_available = 1;
              s3.strstart++;
              s3.lookahead--;
            }
          }
          if (s3.match_available) {
            bflush = trees._tr_tally(s3, 0, s3.window[s3.strstart - 1]);
            s3.match_available = 0;
          }
          s3.insert = s3.strstart < MIN_MATCH - 1 ? s3.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH) {
            flush_block_only(s3, true);
            if (s3.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s3.last_lit) {
            flush_block_only(s3, false);
            if (s3.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_rle(s3, flush) {
          var bflush;
          var prev;
          var scan, strend;
          var _win = s3.window;
          for (; ; ) {
            if (s3.lookahead <= MAX_MATCH) {
              fill_window(s3);
              if (s3.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s3.lookahead === 0) {
                break;
              }
            }
            s3.match_length = 0;
            if (s3.lookahead >= MIN_MATCH && s3.strstart > 0) {
              scan = s3.strstart - 1;
              prev = _win[scan];
              if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                strend = s3.strstart + MAX_MATCH;
                do {
                } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                s3.match_length = MAX_MATCH - (strend - scan);
                if (s3.match_length > s3.lookahead) {
                  s3.match_length = s3.lookahead;
                }
              }
            }
            if (s3.match_length >= MIN_MATCH) {
              bflush = trees._tr_tally(s3, 1, s3.match_length - MIN_MATCH);
              s3.lookahead -= s3.match_length;
              s3.strstart += s3.match_length;
              s3.match_length = 0;
            } else {
              bflush = trees._tr_tally(s3, 0, s3.window[s3.strstart]);
              s3.lookahead--;
              s3.strstart++;
            }
            if (bflush) {
              flush_block_only(s3, false);
              if (s3.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s3.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s3, true);
            if (s3.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s3.last_lit) {
            flush_block_only(s3, false);
            if (s3.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_huff(s3, flush) {
          var bflush;
          for (; ; ) {
            if (s3.lookahead === 0) {
              fill_window(s3);
              if (s3.lookahead === 0) {
                if (flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                break;
              }
            }
            s3.match_length = 0;
            bflush = trees._tr_tally(s3, 0, s3.window[s3.strstart]);
            s3.lookahead--;
            s3.strstart++;
            if (bflush) {
              flush_block_only(s3, false);
              if (s3.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s3.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s3, true);
            if (s3.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s3.last_lit) {
            flush_block_only(s3, false);
            if (s3.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function Config(good_length, max_lazy, nice_length, max_chain, func) {
          this.good_length = good_length;
          this.max_lazy = max_lazy;
          this.nice_length = nice_length;
          this.max_chain = max_chain;
          this.func = func;
        }
        var configuration_table;
        configuration_table = [
          new Config(0, 0, 0, 0, deflate_stored),
          new Config(4, 4, 8, 4, deflate_fast),
          new Config(4, 5, 16, 8, deflate_fast),
          new Config(4, 6, 32, 32, deflate_fast),
          new Config(4, 4, 16, 16, deflate_slow),
          new Config(8, 16, 32, 32, deflate_slow),
          new Config(8, 16, 128, 128, deflate_slow),
          new Config(8, 32, 128, 256, deflate_slow),
          new Config(32, 128, 258, 1024, deflate_slow),
          new Config(32, 258, 258, 4096, deflate_slow)
        ];
        function lm_init(s3) {
          s3.window_size = 2 * s3.w_size;
          zero(s3.head);
          s3.max_lazy_match = configuration_table[s3.level].max_lazy;
          s3.good_match = configuration_table[s3.level].good_length;
          s3.nice_match = configuration_table[s3.level].nice_length;
          s3.max_chain_length = configuration_table[s3.level].max_chain;
          s3.strstart = 0;
          s3.block_start = 0;
          s3.lookahead = 0;
          s3.insert = 0;
          s3.match_length = s3.prev_length = MIN_MATCH - 1;
          s3.match_available = 0;
          s3.ins_h = 0;
        }
        function DeflateState() {
          this.strm = null;
          this.status = 0;
          this.pending_buf = null;
          this.pending_buf_size = 0;
          this.pending_out = 0;
          this.pending = 0;
          this.wrap = 0;
          this.gzhead = null;
          this.gzindex = 0;
          this.method = Z_DEFLATED;
          this.last_flush = -1;
          this.w_size = 0;
          this.w_bits = 0;
          this.w_mask = 0;
          this.window = null;
          this.window_size = 0;
          this.prev = null;
          this.head = null;
          this.ins_h = 0;
          this.hash_size = 0;
          this.hash_bits = 0;
          this.hash_mask = 0;
          this.hash_shift = 0;
          this.block_start = 0;
          this.match_length = 0;
          this.prev_match = 0;
          this.match_available = 0;
          this.strstart = 0;
          this.match_start = 0;
          this.lookahead = 0;
          this.prev_length = 0;
          this.max_chain_length = 0;
          this.max_lazy_match = 0;
          this.level = 0;
          this.strategy = 0;
          this.good_match = 0;
          this.nice_match = 0;
          this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
          this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
          this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
          zero(this.dyn_ltree);
          zero(this.dyn_dtree);
          zero(this.bl_tree);
          this.l_desc = null;
          this.d_desc = null;
          this.bl_desc = null;
          this.bl_count = new utils.Buf16(MAX_BITS + 1);
          this.heap = new utils.Buf16(2 * L_CODES + 1);
          zero(this.heap);
          this.heap_len = 0;
          this.heap_max = 0;
          this.depth = new utils.Buf16(2 * L_CODES + 1);
          zero(this.depth);
          this.l_buf = 0;
          this.lit_bufsize = 0;
          this.last_lit = 0;
          this.d_buf = 0;
          this.opt_len = 0;
          this.static_len = 0;
          this.matches = 0;
          this.insert = 0;
          this.bi_buf = 0;
          this.bi_valid = 0;
        }
        function deflateResetKeep(strm) {
          var s3;
          if (!strm || !strm.state) {
            return err(strm, Z_STREAM_ERROR);
          }
          strm.total_in = strm.total_out = 0;
          strm.data_type = Z_UNKNOWN;
          s3 = strm.state;
          s3.pending = 0;
          s3.pending_out = 0;
          if (s3.wrap < 0) {
            s3.wrap = -s3.wrap;
          }
          s3.status = s3.wrap ? INIT_STATE : BUSY_STATE;
          strm.adler = s3.wrap === 2 ? 0 : 1;
          s3.last_flush = Z_NO_FLUSH;
          trees._tr_init(s3);
          return Z_OK;
        }
        function deflateReset(strm) {
          var ret = deflateResetKeep(strm);
          if (ret === Z_OK) {
            lm_init(strm.state);
          }
          return ret;
        }
        function deflateSetHeader(strm, head) {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          if (strm.state.wrap !== 2) {
            return Z_STREAM_ERROR;
          }
          strm.state.gzhead = head;
          return Z_OK;
        }
        function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
          if (!strm) {
            return Z_STREAM_ERROR;
          }
          var wrap = 1;
          if (level === Z_DEFAULT_COMPRESSION) {
            level = 6;
          }
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else if (windowBits > 15) {
            wrap = 2;
            windowBits -= 16;
          }
          if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
            return err(strm, Z_STREAM_ERROR);
          }
          if (windowBits === 8) {
            windowBits = 9;
          }
          var s3 = new DeflateState();
          strm.state = s3;
          s3.strm = strm;
          s3.wrap = wrap;
          s3.gzhead = null;
          s3.w_bits = windowBits;
          s3.w_size = 1 << s3.w_bits;
          s3.w_mask = s3.w_size - 1;
          s3.hash_bits = memLevel + 7;
          s3.hash_size = 1 << s3.hash_bits;
          s3.hash_mask = s3.hash_size - 1;
          s3.hash_shift = ~~((s3.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
          s3.window = new utils.Buf8(s3.w_size * 2);
          s3.head = new utils.Buf16(s3.hash_size);
          s3.prev = new utils.Buf16(s3.w_size);
          s3.lit_bufsize = 1 << memLevel + 6;
          s3.pending_buf_size = s3.lit_bufsize * 4;
          s3.pending_buf = new utils.Buf8(s3.pending_buf_size);
          s3.d_buf = 1 * s3.lit_bufsize;
          s3.l_buf = (1 + 2) * s3.lit_bufsize;
          s3.level = level;
          s3.strategy = strategy;
          s3.method = method;
          return deflateReset(strm);
        }
        function deflateInit(strm, level) {
          return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
        }
        function deflate(strm, flush) {
          var old_flush, s3;
          var beg, val;
          if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
          }
          s3 = strm.state;
          if (!strm.output || !strm.input && strm.avail_in !== 0 || s3.status === FINISH_STATE && flush !== Z_FINISH) {
            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
          }
          s3.strm = strm;
          old_flush = s3.last_flush;
          s3.last_flush = flush;
          if (s3.status === INIT_STATE) {
            if (s3.wrap === 2) {
              strm.adler = 0;
              put_byte(s3, 31);
              put_byte(s3, 139);
              put_byte(s3, 8);
              if (!s3.gzhead) {
                put_byte(s3, 0);
                put_byte(s3, 0);
                put_byte(s3, 0);
                put_byte(s3, 0);
                put_byte(s3, 0);
                put_byte(s3, s3.level === 9 ? 2 : s3.strategy >= Z_HUFFMAN_ONLY || s3.level < 2 ? 4 : 0);
                put_byte(s3, OS_CODE);
                s3.status = BUSY_STATE;
              } else {
                put_byte(s3, (s3.gzhead.text ? 1 : 0) + (s3.gzhead.hcrc ? 2 : 0) + (!s3.gzhead.extra ? 0 : 4) + (!s3.gzhead.name ? 0 : 8) + (!s3.gzhead.comment ? 0 : 16));
                put_byte(s3, s3.gzhead.time & 255);
                put_byte(s3, s3.gzhead.time >> 8 & 255);
                put_byte(s3, s3.gzhead.time >> 16 & 255);
                put_byte(s3, s3.gzhead.time >> 24 & 255);
                put_byte(s3, s3.level === 9 ? 2 : s3.strategy >= Z_HUFFMAN_ONLY || s3.level < 2 ? 4 : 0);
                put_byte(s3, s3.gzhead.os & 255);
                if (s3.gzhead.extra && s3.gzhead.extra.length) {
                  put_byte(s3, s3.gzhead.extra.length & 255);
                  put_byte(s3, s3.gzhead.extra.length >> 8 & 255);
                }
                if (s3.gzhead.hcrc) {
                  strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending, 0);
                }
                s3.gzindex = 0;
                s3.status = EXTRA_STATE;
              }
            } else {
              var header = Z_DEFLATED + (s3.w_bits - 8 << 4) << 8;
              var level_flags = -1;
              if (s3.strategy >= Z_HUFFMAN_ONLY || s3.level < 2) {
                level_flags = 0;
              } else if (s3.level < 6) {
                level_flags = 1;
              } else if (s3.level === 6) {
                level_flags = 2;
              } else {
                level_flags = 3;
              }
              header |= level_flags << 6;
              if (s3.strstart !== 0) {
                header |= PRESET_DICT;
              }
              header += 31 - header % 31;
              s3.status = BUSY_STATE;
              putShortMSB(s3, header);
              if (s3.strstart !== 0) {
                putShortMSB(s3, strm.adler >>> 16);
                putShortMSB(s3, strm.adler & 65535);
              }
              strm.adler = 1;
            }
          }
          if (s3.status === EXTRA_STATE) {
            if (s3.gzhead.extra) {
              beg = s3.pending;
              while (s3.gzindex < (s3.gzhead.extra.length & 65535)) {
                if (s3.pending === s3.pending_buf_size) {
                  if (s3.gzhead.hcrc && s3.pending > beg) {
                    strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s3.pending;
                  if (s3.pending === s3.pending_buf_size) {
                    break;
                  }
                }
                put_byte(s3, s3.gzhead.extra[s3.gzindex] & 255);
                s3.gzindex++;
              }
              if (s3.gzhead.hcrc && s3.pending > beg) {
                strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending - beg, beg);
              }
              if (s3.gzindex === s3.gzhead.extra.length) {
                s3.gzindex = 0;
                s3.status = NAME_STATE;
              }
            } else {
              s3.status = NAME_STATE;
            }
          }
          if (s3.status === NAME_STATE) {
            if (s3.gzhead.name) {
              beg = s3.pending;
              do {
                if (s3.pending === s3.pending_buf_size) {
                  if (s3.gzhead.hcrc && s3.pending > beg) {
                    strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s3.pending;
                  if (s3.pending === s3.pending_buf_size) {
                    val = 1;
                    break;
                  }
                }
                if (s3.gzindex < s3.gzhead.name.length) {
                  val = s3.gzhead.name.charCodeAt(s3.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s3, val);
              } while (val !== 0);
              if (s3.gzhead.hcrc && s3.pending > beg) {
                strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending - beg, beg);
              }
              if (val === 0) {
                s3.gzindex = 0;
                s3.status = COMMENT_STATE;
              }
            } else {
              s3.status = COMMENT_STATE;
            }
          }
          if (s3.status === COMMENT_STATE) {
            if (s3.gzhead.comment) {
              beg = s3.pending;
              do {
                if (s3.pending === s3.pending_buf_size) {
                  if (s3.gzhead.hcrc && s3.pending > beg) {
                    strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s3.pending;
                  if (s3.pending === s3.pending_buf_size) {
                    val = 1;
                    break;
                  }
                }
                if (s3.gzindex < s3.gzhead.comment.length) {
                  val = s3.gzhead.comment.charCodeAt(s3.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s3, val);
              } while (val !== 0);
              if (s3.gzhead.hcrc && s3.pending > beg) {
                strm.adler = crc32(strm.adler, s3.pending_buf, s3.pending - beg, beg);
              }
              if (val === 0) {
                s3.status = HCRC_STATE;
              }
            } else {
              s3.status = HCRC_STATE;
            }
          }
          if (s3.status === HCRC_STATE) {
            if (s3.gzhead.hcrc) {
              if (s3.pending + 2 > s3.pending_buf_size) {
                flush_pending(strm);
              }
              if (s3.pending + 2 <= s3.pending_buf_size) {
                put_byte(s3, strm.adler & 255);
                put_byte(s3, strm.adler >> 8 & 255);
                strm.adler = 0;
                s3.status = BUSY_STATE;
              }
            } else {
              s3.status = BUSY_STATE;
            }
          }
          if (s3.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s3.last_flush = -1;
              return Z_OK;
            }
          } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
            return err(strm, Z_BUF_ERROR);
          }
          if (s3.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR);
          }
          if (strm.avail_in !== 0 || s3.lookahead !== 0 || flush !== Z_NO_FLUSH && s3.status !== FINISH_STATE) {
            var bstate = s3.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s3, flush) : s3.strategy === Z_RLE ? deflate_rle(s3, flush) : configuration_table[s3.level].func(s3, flush);
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
              s3.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
              if (strm.avail_out === 0) {
                s3.last_flush = -1;
              }
              return Z_OK;
            }
            if (bstate === BS_BLOCK_DONE) {
              if (flush === Z_PARTIAL_FLUSH) {
                trees._tr_align(s3);
              } else if (flush !== Z_BLOCK) {
                trees._tr_stored_block(s3, 0, 0, false);
                if (flush === Z_FULL_FLUSH) {
                  zero(s3.head);
                  if (s3.lookahead === 0) {
                    s3.strstart = 0;
                    s3.block_start = 0;
                    s3.insert = 0;
                  }
                }
              }
              flush_pending(strm);
              if (strm.avail_out === 0) {
                s3.last_flush = -1;
                return Z_OK;
              }
            }
          }
          if (flush !== Z_FINISH) {
            return Z_OK;
          }
          if (s3.wrap <= 0) {
            return Z_STREAM_END;
          }
          if (s3.wrap === 2) {
            put_byte(s3, strm.adler & 255);
            put_byte(s3, strm.adler >> 8 & 255);
            put_byte(s3, strm.adler >> 16 & 255);
            put_byte(s3, strm.adler >> 24 & 255);
            put_byte(s3, strm.total_in & 255);
            put_byte(s3, strm.total_in >> 8 & 255);
            put_byte(s3, strm.total_in >> 16 & 255);
            put_byte(s3, strm.total_in >> 24 & 255);
          } else {
            putShortMSB(s3, strm.adler >>> 16);
            putShortMSB(s3, strm.adler & 65535);
          }
          flush_pending(strm);
          if (s3.wrap > 0) {
            s3.wrap = -s3.wrap;
          }
          return s3.pending !== 0 ? Z_OK : Z_STREAM_END;
        }
        function deflateEnd(strm) {
          var status;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          status = strm.state.status;
          if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
            return err(strm, Z_STREAM_ERROR);
          }
          strm.state = null;
          return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
        }
        function deflateSetDictionary(strm, dictionary) {
          var dictLength = dictionary.length;
          var s3;
          var str, n2;
          var wrap;
          var avail;
          var next;
          var input;
          var tmpDict;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          s3 = strm.state;
          wrap = s3.wrap;
          if (wrap === 2 || wrap === 1 && s3.status !== INIT_STATE || s3.lookahead) {
            return Z_STREAM_ERROR;
          }
          if (wrap === 1) {
            strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
          }
          s3.wrap = 0;
          if (dictLength >= s3.w_size) {
            if (wrap === 0) {
              zero(s3.head);
              s3.strstart = 0;
              s3.block_start = 0;
              s3.insert = 0;
            }
            tmpDict = new utils.Buf8(s3.w_size);
            utils.arraySet(tmpDict, dictionary, dictLength - s3.w_size, s3.w_size, 0);
            dictionary = tmpDict;
            dictLength = s3.w_size;
          }
          avail = strm.avail_in;
          next = strm.next_in;
          input = strm.input;
          strm.avail_in = dictLength;
          strm.next_in = 0;
          strm.input = dictionary;
          fill_window(s3);
          while (s3.lookahead >= MIN_MATCH) {
            str = s3.strstart;
            n2 = s3.lookahead - (MIN_MATCH - 1);
            do {
              s3.ins_h = (s3.ins_h << s3.hash_shift ^ s3.window[str + MIN_MATCH - 1]) & s3.hash_mask;
              s3.prev[str & s3.w_mask] = s3.head[s3.ins_h];
              s3.head[s3.ins_h] = str;
              str++;
            } while (--n2);
            s3.strstart = str;
            s3.lookahead = MIN_MATCH - 1;
            fill_window(s3);
          }
          s3.strstart += s3.lookahead;
          s3.block_start = s3.strstart;
          s3.insert = s3.lookahead;
          s3.lookahead = 0;
          s3.match_length = s3.prev_length = MIN_MATCH - 1;
          s3.match_available = 0;
          strm.next_in = next;
          strm.input = input;
          strm.avail_in = avail;
          s3.wrap = wrap;
          return Z_OK;
        }
        exports3.deflateInit = deflateInit;
        exports3.deflateInit2 = deflateInit2;
        exports3.deflateReset = deflateReset;
        exports3.deflateResetKeep = deflateResetKeep;
        exports3.deflateSetHeader = deflateSetHeader;
        exports3.deflate = deflate;
        exports3.deflateEnd = deflateEnd;
        exports3.deflateSetDictionary = deflateSetDictionary;
        exports3.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(require2, module4, exports3) {
        "use strict";
        function GZheader() {
          this.text = 0;
          this.time = 0;
          this.xflags = 0;
          this.os = 0;
          this.extra = null;
          this.extra_len = 0;
          this.name = "";
          this.comment = "";
          this.hcrc = 0;
          this.done = false;
        }
        module4.exports = GZheader;
      }, {}], 48: [function(require2, module4, exports3) {
        "use strict";
        var BAD = 30;
        var TYPE = 12;
        module4.exports = function inflate_fast(strm, start) {
          var state;
          var _in;
          var last;
          var _out;
          var beg;
          var end;
          var dmax;
          var wsize;
          var whave;
          var wnext;
          var s_window;
          var hold;
          var bits;
          var lcode;
          var dcode;
          var lmask;
          var dmask;
          var here;
          var op;
          var len;
          var dist;
          var from;
          var from_source;
          var input, output;
          state = strm.state;
          _in = strm.next_in;
          input = strm.input;
          last = _in + (strm.avail_in - 5);
          _out = strm.next_out;
          output = strm.output;
          beg = _out - (start - strm.avail_out);
          end = _out + (strm.avail_out - 257);
          dmax = state.dmax;
          wsize = state.wsize;
          whave = state.whave;
          wnext = state.wnext;
          s_window = state.window;
          hold = state.hold;
          bits = state.bits;
          lcode = state.lencode;
          dcode = state.distcode;
          lmask = (1 << state.lenbits) - 1;
          dmask = (1 << state.distbits) - 1;
          top:
            do {
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = lcode[hold & lmask];
              dolen:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op === 0) {
                    output[_out++] = here & 65535;
                  } else if (op & 16) {
                    len = here & 65535;
                    op &= 15;
                    if (op) {
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                      len += hold & (1 << op) - 1;
                      hold >>>= op;
                      bits -= op;
                    }
                    if (bits < 15) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    here = dcode[hold & dmask];
                    dodist:
                      for (; ; ) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op & 16) {
                          dist = here & 65535;
                          op &= 15;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            if (bits < op) {
                              hold += input[_in++] << bits;
                              bits += 8;
                            }
                          }
                          dist += hold & (1 << op) - 1;
                          if (dist > dmax) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                          hold >>>= op;
                          bits -= op;
                          op = _out - beg;
                          if (dist > op) {
                            op = dist - op;
                            if (op > whave) {
                              if (state.sane) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD;
                                break top;
                              }
                            }
                            from = 0;
                            from_source = s_window;
                            if (wnext === 0) {
                              from += wsize - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            } else if (wnext < op) {
                              from += wsize + wnext - op;
                              op -= wnext;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = 0;
                                if (wnext < len) {
                                  op = wnext;
                                  len -= op;
                                  do {
                                    output[_out++] = s_window[from++];
                                  } while (--op);
                                  from = _out - dist;
                                  from_source = output;
                                }
                              }
                            } else {
                              from += wnext - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                            while (len > 2) {
                              output[_out++] = from_source[from++];
                              output[_out++] = from_source[from++];
                              output[_out++] = from_source[from++];
                              len -= 3;
                            }
                            if (len) {
                              output[_out++] = from_source[from++];
                              if (len > 1) {
                                output[_out++] = from_source[from++];
                              }
                            }
                          } else {
                            from = _out - dist;
                            do {
                              output[_out++] = output[from++];
                              output[_out++] = output[from++];
                              output[_out++] = output[from++];
                              len -= 3;
                            } while (len > 2);
                            if (len) {
                              output[_out++] = output[from++];
                              if (len > 1) {
                                output[_out++] = output[from++];
                              }
                            }
                          }
                        } else if ((op & 64) === 0) {
                          here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                          continue dodist;
                        } else {
                          strm.msg = "invalid distance code";
                          state.mode = BAD;
                          break top;
                        }
                        break;
                      }
                  } else if ((op & 64) === 0) {
                    here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dolen;
                  } else if (op & 32) {
                    state.mode = TYPE;
                    break top;
                  } else {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } while (_in < last && _out < end);
          len = bits >> 3;
          _in -= len;
          bits -= len << 3;
          hold &= (1 << bits) - 1;
          strm.next_in = _in;
          strm.next_out = _out;
          strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
          strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
          state.hold = hold;
          state.bits = bits;
          return;
        };
      }, {}], 49: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var adler32 = require2("./adler32");
        var crc32 = require2("./crc32");
        var inflate_fast = require2("./inffast");
        var inflate_table = require2("./inftrees");
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_TREES = 6;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_NEED_DICT = 2;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_MEM_ERROR = -4;
        var Z_BUF_ERROR = -5;
        var Z_DEFLATED = 8;
        var HEAD = 1;
        var FLAGS = 2;
        var TIME = 3;
        var OS = 4;
        var EXLEN = 5;
        var EXTRA = 6;
        var NAME = 7;
        var COMMENT = 8;
        var HCRC = 9;
        var DICTID = 10;
        var DICT = 11;
        var TYPE = 12;
        var TYPEDO = 13;
        var STORED = 14;
        var COPY_ = 15;
        var COPY = 16;
        var TABLE = 17;
        var LENLENS = 18;
        var CODELENS = 19;
        var LEN_ = 20;
        var LEN = 21;
        var LENEXT = 22;
        var DIST = 23;
        var DISTEXT = 24;
        var MATCH = 25;
        var LIT = 26;
        var CHECK = 27;
        var LENGTH = 28;
        var DONE = 29;
        var BAD = 30;
        var MEM = 31;
        var SYNC = 32;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var MAX_WBITS = 15;
        var DEF_WBITS = MAX_WBITS;
        function zswap32(q4) {
          return (q4 >>> 24 & 255) + (q4 >>> 8 & 65280) + ((q4 & 65280) << 8) + ((q4 & 255) << 24);
        }
        function InflateState() {
          this.mode = 0;
          this.last = false;
          this.wrap = 0;
          this.havedict = false;
          this.flags = 0;
          this.dmax = 0;
          this.check = 0;
          this.total = 0;
          this.head = null;
          this.wbits = 0;
          this.wsize = 0;
          this.whave = 0;
          this.wnext = 0;
          this.window = null;
          this.hold = 0;
          this.bits = 0;
          this.length = 0;
          this.offset = 0;
          this.extra = 0;
          this.lencode = null;
          this.distcode = null;
          this.lenbits = 0;
          this.distbits = 0;
          this.ncode = 0;
          this.nlen = 0;
          this.ndist = 0;
          this.have = 0;
          this.next = null;
          this.lens = new utils.Buf16(320);
          this.work = new utils.Buf16(288);
          this.lendyn = null;
          this.distdyn = null;
          this.sane = 0;
          this.back = 0;
          this.was = 0;
        }
        function inflateResetKeep(strm) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          strm.total_in = strm.total_out = state.total = 0;
          strm.msg = "";
          if (state.wrap) {
            strm.adler = state.wrap & 1;
          }
          state.mode = HEAD;
          state.last = 0;
          state.havedict = 0;
          state.dmax = 32768;
          state.head = null;
          state.hold = 0;
          state.bits = 0;
          state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
          state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
          state.sane = 1;
          state.back = -1;
          return Z_OK;
        }
        function inflateReset(strm) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          state.wsize = 0;
          state.whave = 0;
          state.wnext = 0;
          return inflateResetKeep(strm);
        }
        function inflateReset2(strm, windowBits) {
          var wrap;
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else {
            wrap = (windowBits >> 4) + 1;
            if (windowBits < 48) {
              windowBits &= 15;
            }
          }
          if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR;
          }
          if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
          }
          state.wrap = wrap;
          state.wbits = windowBits;
          return inflateReset(strm);
        }
        function inflateInit2(strm, windowBits) {
          var ret;
          var state;
          if (!strm) {
            return Z_STREAM_ERROR;
          }
          state = new InflateState();
          strm.state = state;
          state.window = null;
          ret = inflateReset2(strm, windowBits);
          if (ret !== Z_OK) {
            strm.state = null;
          }
          return ret;
        }
        function inflateInit(strm) {
          return inflateInit2(strm, DEF_WBITS);
        }
        var virgin = true;
        var lenfix, distfix;
        function fixedtables(state) {
          if (virgin) {
            var sym;
            lenfix = new utils.Buf32(512);
            distfix = new utils.Buf32(32);
            sym = 0;
            while (sym < 144) {
              state.lens[sym++] = 8;
            }
            while (sym < 256) {
              state.lens[sym++] = 9;
            }
            while (sym < 280) {
              state.lens[sym++] = 7;
            }
            while (sym < 288) {
              state.lens[sym++] = 8;
            }
            inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
            sym = 0;
            while (sym < 32) {
              state.lens[sym++] = 5;
            }
            inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
            virgin = false;
          }
          state.lencode = lenfix;
          state.lenbits = 9;
          state.distcode = distfix;
          state.distbits = 5;
        }
        function updatewindow(strm, src, end, copy) {
          var dist;
          var state = strm.state;
          if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;
            state.window = new utils.Buf8(state.wsize);
          }
          if (copy >= state.wsize) {
            utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
            state.wnext = 0;
            state.whave = state.wsize;
          } else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
              dist = copy;
            }
            utils.arraySet(state.window, src, end - copy, dist, state.wnext);
            copy -= dist;
            if (copy) {
              utils.arraySet(state.window, src, end - copy, copy, 0);
              state.wnext = copy;
              state.whave = state.wsize;
            } else {
              state.wnext += dist;
              if (state.wnext === state.wsize) {
                state.wnext = 0;
              }
              if (state.whave < state.wsize) {
                state.whave += dist;
              }
            }
          }
          return 0;
        }
        function inflate(strm, flush) {
          var state;
          var input, output;
          var next;
          var put;
          var have, left;
          var hold;
          var bits;
          var _in, _out;
          var copy;
          var from;
          var from_source;
          var here = 0;
          var here_bits, here_op, here_val;
          var last_bits, last_op, last_val;
          var len;
          var ret;
          var hbuf = new utils.Buf8(4);
          var opts;
          var n2;
          var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (state.mode === TYPE) {
            state.mode = TYPEDO;
          }
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          _in = have;
          _out = left;
          ret = Z_OK;
          inf_leave:
            for (; ; ) {
              switch (state.mode) {
                case HEAD:
                  if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                  }
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 2 && hold === 35615) {
                    state.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                  }
                  state.flags = 0;
                  if (state.head) {
                    state.head.done = false;
                  }
                  if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD;
                    break;
                  }
                  if ((hold & 15) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  hold >>>= 4;
                  bits -= 4;
                  len = (hold & 15) + 8;
                  if (state.wbits === 0) {
                    state.wbits = len;
                  } else if (len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD;
                    break;
                  }
                  state.dmax = 1 << len;
                  strm.adler = state.check = 1;
                  state.mode = hold & 512 ? DICTID : TYPE;
                  hold = 0;
                  bits = 0;
                  break;
                case FLAGS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.flags = hold;
                  if ((state.flags & 255) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  if (state.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD;
                    break;
                  }
                  if (state.head) {
                    state.head.text = hold >> 8 & 1;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = TIME;
                case TIME:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.time = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state.check = crc32(state.check, hbuf, 4, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = OS;
                case OS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.xflags = hold & 255;
                    state.head.os = hold >> 8;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = EXLEN;
                case EXLEN:
                  if (state.flags & 1024) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                      state.head.extra_len = hold;
                    }
                    if (state.flags & 512) {
                      hbuf[0] = hold & 255;
                      hbuf[1] = hold >>> 8 & 255;
                      state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                  } else if (state.head) {
                    state.head.extra = null;
                  }
                  state.mode = EXTRA;
                case EXTRA:
                  if (state.flags & 1024) {
                    copy = state.length;
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy) {
                      if (state.head) {
                        len = state.head.extra_len - state.length;
                        if (!state.head.extra) {
                          state.head.extra = new Array(state.head.extra_len);
                        }
                        utils.arraySet(state.head.extra, input, next, copy, len);
                      }
                      if (state.flags & 512) {
                        state.check = crc32(state.check, input, copy, next);
                      }
                      have -= copy;
                      next += copy;
                      state.length -= copy;
                    }
                    if (state.length) {
                      break inf_leave;
                    }
                  }
                  state.length = 0;
                  state.mode = NAME;
                case NAME:
                  if (state.flags & 2048) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.name += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.name = null;
                  }
                  state.length = 0;
                  state.mode = COMMENT;
                case COMMENT:
                  if (state.flags & 4096) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.comment += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.comment = null;
                  }
                  state.mode = HCRC;
                case HCRC:
                  if (state.flags & 512) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.check & 65535)) {
                      strm.msg = "header crc mismatch";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                  }
                  strm.adler = state.check = 0;
                  state.mode = TYPE;
                  break;
                case DICTID:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  strm.adler = state.check = zswap32(hold);
                  hold = 0;
                  bits = 0;
                  state.mode = DICT;
                case DICT:
                  if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT;
                  }
                  strm.adler = state.check = 1;
                  state.mode = TYPE;
                case TYPE:
                  if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                  }
                case TYPEDO:
                  if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                  }
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.last = hold & 1;
                  hold >>>= 1;
                  bits -= 1;
                  switch (hold & 3) {
                    case 0:
                      state.mode = STORED;
                      break;
                    case 1:
                      fixedtables(state);
                      state.mode = LEN_;
                      if (flush === Z_TREES) {
                        hold >>>= 2;
                        bits -= 2;
                        break inf_leave;
                      }
                      break;
                    case 2:
                      state.mode = TABLE;
                      break;
                    case 3:
                      strm.msg = "invalid block type";
                      state.mode = BAD;
                  }
                  hold >>>= 2;
                  bits -= 2;
                  break;
                case STORED:
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD;
                    break;
                  }
                  state.length = hold & 65535;
                  hold = 0;
                  bits = 0;
                  state.mode = COPY_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case COPY_:
                  state.mode = COPY;
                case COPY:
                  copy = state.length;
                  if (copy) {
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy > left) {
                      copy = left;
                    }
                    if (copy === 0) {
                      break inf_leave;
                    }
                    utils.arraySet(output, input, next, copy, put);
                    have -= copy;
                    next += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                  }
                  state.mode = TYPE;
                  break;
                case TABLE:
                  while (bits < 14) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.nlen = (hold & 31) + 257;
                  hold >>>= 5;
                  bits -= 5;
                  state.ndist = (hold & 31) + 1;
                  hold >>>= 5;
                  bits -= 5;
                  state.ncode = (hold & 15) + 4;
                  hold >>>= 4;
                  bits -= 4;
                  if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = LENLENS;
                case LENLENS:
                  while (state.have < state.ncode) {
                    while (bits < 3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                  }
                  while (state.have < 19) {
                    state.lens[order[state.have++]] = 0;
                  }
                  state.lencode = state.lendyn;
                  state.lenbits = 7;
                  opts = { bits: state.lenbits };
                  ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = CODELENS;
                case CODELENS:
                  while (state.have < state.nlen + state.ndist) {
                    for (; ; ) {
                      here = state.lencode[hold & (1 << state.lenbits) - 1];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (here_val < 16) {
                      hold >>>= here_bits;
                      bits -= here_bits;
                      state.lens[state.have++] = here_val;
                    } else {
                      if (here_val === 16) {
                        n2 = here_bits + 2;
                        while (bits < n2) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        if (state.have === 0) {
                          strm.msg = "invalid bit length repeat";
                          state.mode = BAD;
                          break;
                        }
                        len = state.lens[state.have - 1];
                        copy = 3 + (hold & 3);
                        hold >>>= 2;
                        bits -= 2;
                      } else if (here_val === 17) {
                        n2 = here_bits + 3;
                        while (bits < n2) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 3 + (hold & 7);
                        hold >>>= 3;
                        bits -= 3;
                      } else {
                        n2 = here_bits + 7;
                        while (bits < n2) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 11 + (hold & 127);
                        hold >>>= 7;
                        bits -= 7;
                      }
                      if (state.have + copy > state.nlen + state.ndist) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      while (copy--) {
                        state.lens[state.have++] = len;
                      }
                    }
                  }
                  if (state.mode === BAD) {
                    break;
                  }
                  if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD;
                    break;
                  }
                  state.lenbits = 9;
                  opts = { bits: state.lenbits };
                  ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.distbits = 6;
                  state.distcode = state.distdyn;
                  opts = { bits: state.distbits };
                  ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                  state.distbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case LEN_:
                  state.mode = LEN;
                case LEN:
                  if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inflate_fast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === TYPE) {
                      state.back = -1;
                    }
                    break;
                  }
                  state.back = 0;
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  state.length = here_val;
                  if (here_op === 0) {
                    state.mode = LIT;
                    break;
                  }
                  if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                  }
                  if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break;
                  }
                  state.extra = here_op & 15;
                  state.mode = LENEXT;
                case LENEXT:
                  if (state.extra) {
                    n2 = state.extra;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  state.was = state.length;
                  state.mode = DIST;
                case DIST:
                  for (; ; ) {
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break;
                  }
                  state.offset = here_val;
                  state.extra = here_op & 15;
                  state.mode = DISTEXT;
                case DISTEXT:
                  if (state.extra) {
                    n2 = state.extra;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = MATCH;
                case MATCH:
                  if (left === 0) {
                    break inf_leave;
                  }
                  copy = _out - left;
                  if (state.offset > copy) {
                    copy = state.offset - copy;
                    if (copy > state.whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break;
                      }
                    }
                    if (copy > state.wnext) {
                      copy -= state.wnext;
                      from = state.wsize - copy;
                    } else {
                      from = state.wnext - copy;
                    }
                    if (copy > state.length) {
                      copy = state.length;
                    }
                    from_source = state.window;
                  } else {
                    from_source = output;
                    from = put - state.offset;
                    copy = state.length;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  left -= copy;
                  state.length -= copy;
                  do {
                    output[put++] = from_source[from++];
                  } while (--copy);
                  if (state.length === 0) {
                    state.mode = LEN;
                  }
                  break;
                case LIT:
                  if (left === 0) {
                    break inf_leave;
                  }
                  output[put++] = state.length;
                  left--;
                  state.mode = LEN;
                  break;
                case CHECK:
                  if (state.wrap) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold |= input[next++] << bits;
                      bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (_out) {
                      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                      strm.msg = "incorrect data check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = LENGTH;
                case LENGTH:
                  if (state.wrap && state.flags) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.total & 4294967295)) {
                      strm.msg = "incorrect length check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = DONE;
                case DONE:
                  ret = Z_STREAM_END;
                  break inf_leave;
                case BAD:
                  ret = Z_DATA_ERROR;
                  break inf_leave;
                case MEM:
                  return Z_MEM_ERROR;
                case SYNC:
                default:
                  return Z_STREAM_ERROR;
              }
            }
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
              state.mode = MEM;
              return Z_MEM_ERROR;
            }
          }
          _in -= strm.avail_in;
          _out -= strm.avail_out;
          strm.total_in += _in;
          strm.total_out += _out;
          state.total += _out;
          if (state.wrap && _out) {
            strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
          }
          strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
          if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
            ret = Z_BUF_ERROR;
          }
          return ret;
        }
        function inflateEnd(strm) {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          var state = strm.state;
          if (state.window) {
            state.window = null;
          }
          strm.state = null;
          return Z_OK;
        }
        function inflateGetHeader(strm, head) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if ((state.wrap & 2) === 0) {
            return Z_STREAM_ERROR;
          }
          state.head = head;
          head.done = false;
          return Z_OK;
        }
        function inflateSetDictionary(strm, dictionary) {
          var dictLength = dictionary.length;
          var state;
          var dictid;
          var ret;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (state.wrap !== 0 && state.mode !== DICT) {
            return Z_STREAM_ERROR;
          }
          if (state.mode === DICT) {
            dictid = 1;
            dictid = adler32(dictid, dictionary, dictLength, 0);
            if (dictid !== state.check) {
              return Z_DATA_ERROR;
            }
          }
          ret = updatewindow(strm, dictionary, dictLength, dictLength);
          if (ret) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
          state.havedict = 1;
          return Z_OK;
        }
        exports3.inflateReset = inflateReset;
        exports3.inflateReset2 = inflateReset2;
        exports3.inflateResetKeep = inflateResetKeep;
        exports3.inflateInit = inflateInit;
        exports3.inflateInit2 = inflateInit2;
        exports3.inflate = inflate;
        exports3.inflateEnd = inflateEnd;
        exports3.inflateGetHeader = inflateGetHeader;
        exports3.inflateSetDictionary = inflateSetDictionary;
        exports3.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var MAXBITS = 15;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var lbase = [
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          13,
          15,
          17,
          19,
          23,
          27,
          31,
          35,
          43,
          51,
          59,
          67,
          83,
          99,
          115,
          131,
          163,
          195,
          227,
          258,
          0,
          0
        ];
        var lext = [
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          16,
          72,
          78
        ];
        var dbase = [
          1,
          2,
          3,
          4,
          5,
          7,
          9,
          13,
          17,
          25,
          33,
          49,
          65,
          97,
          129,
          193,
          257,
          385,
          513,
          769,
          1025,
          1537,
          2049,
          3073,
          4097,
          6145,
          8193,
          12289,
          16385,
          24577,
          0,
          0
        ];
        var dext = [
          16,
          16,
          16,
          16,
          17,
          17,
          18,
          18,
          19,
          19,
          20,
          20,
          21,
          21,
          22,
          22,
          23,
          23,
          24,
          24,
          25,
          25,
          26,
          26,
          27,
          27,
          28,
          28,
          29,
          29,
          64,
          64
        ];
        module4.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
          var bits = opts.bits;
          var len = 0;
          var sym = 0;
          var min = 0, max = 0;
          var root = 0;
          var curr = 0;
          var drop = 0;
          var left = 0;
          var used = 0;
          var huff = 0;
          var incr;
          var fill;
          var low;
          var mask;
          var next;
          var base = null;
          var base_index = 0;
          var end;
          var count = new utils.Buf16(MAXBITS + 1);
          var offs = new utils.Buf16(MAXBITS + 1);
          var extra = null;
          var extra_index = 0;
          var here_bits, here_op, here_val;
          for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
          }
          for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
          }
          root = bits;
          for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) {
              break;
            }
          }
          if (root > max) {
            root = max;
          }
          if (max === 0) {
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            opts.bits = 1;
            return 0;
          }
          for (min = 1; min < max; min++) {
            if (count[min] !== 0) {
              break;
            }
          }
          if (root < min) {
            root = min;
          }
          left = 1;
          for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
              return -1;
            }
          }
          if (left > 0 && (type === CODES || max !== 1)) {
            return -1;
          }
          offs[1] = 0;
          for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
          }
          for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
              work[offs[lens[lens_index + sym]]++] = sym;
            }
          }
          if (type === CODES) {
            base = extra = work;
            end = 19;
          } else if (type === LENS) {
            base = lbase;
            base_index -= 257;
            extra = lext;
            extra_index -= 257;
            end = 256;
          } else {
            base = dbase;
            extra = dext;
            end = -1;
          }
          huff = 0;
          sym = 0;
          len = min;
          next = table_index;
          curr = root;
          drop = 0;
          low = -1;
          used = 1 << root;
          mask = used - 1;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          for (; ; ) {
            here_bits = len - drop;
            if (work[sym] < end) {
              here_op = 0;
              here_val = work[sym];
            } else if (work[sym] > end) {
              here_op = extra[extra_index + work[sym]];
              here_val = base[base_index + work[sym]];
            } else {
              here_op = 32 + 64;
              here_val = 0;
            }
            incr = 1 << len - drop;
            fill = 1 << curr;
            min = fill;
            do {
              fill -= incr;
              table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
            } while (fill !== 0);
            incr = 1 << len - 1;
            while (huff & incr) {
              incr >>= 1;
            }
            if (incr !== 0) {
              huff &= incr - 1;
              huff += incr;
            } else {
              huff = 0;
            }
            sym++;
            if (--count[len] === 0) {
              if (len === max) {
                break;
              }
              len = lens[lens_index + work[sym]];
            }
            if (len > root && (huff & mask) !== low) {
              if (drop === 0) {
                drop = root;
              }
              next += min;
              curr = len - drop;
              left = 1 << curr;
              while (curr + drop < max) {
                left -= count[curr + drop];
                if (left <= 0) {
                  break;
                }
                curr++;
                left <<= 1;
              }
              used += 1 << curr;
              if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                return 1;
              }
              low = huff & mask;
              table[low] = root << 24 | curr << 16 | next - table_index | 0;
            }
          }
          if (huff !== 0) {
            table[next + huff] = len - drop << 24 | 64 << 16 | 0;
          }
          opts.bits = root;
          return 0;
        };
      }, { "../utils/common": 41 }], 51: [function(require2, module4, exports3) {
        "use strict";
        module4.exports = {
          2: "need dictionary",
          1: "stream end",
          0: "",
          "-1": "file error",
          "-2": "stream error",
          "-3": "data error",
          "-4": "insufficient memory",
          "-5": "buffer error",
          "-6": "incompatible version"
        };
      }, {}], 52: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var Z_FIXED = 4;
        var Z_BINARY = 0;
        var Z_TEXT = 1;
        var Z_UNKNOWN = 2;
        function zero(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        var STORED_BLOCK = 0;
        var STATIC_TREES = 1;
        var DYN_TREES = 2;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var Buf_size = 16;
        var MAX_BL_BITS = 7;
        var END_BLOCK = 256;
        var REP_3_6 = 16;
        var REPZ_3_10 = 17;
        var REPZ_11_138 = 18;
        var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
        var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
        var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
        var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        var DIST_CODE_LEN = 512;
        var static_ltree = new Array((L_CODES + 2) * 2);
        zero(static_ltree);
        var static_dtree = new Array(D_CODES * 2);
        zero(static_dtree);
        var _dist_code = new Array(DIST_CODE_LEN);
        zero(_dist_code);
        var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
        zero(_length_code);
        var base_length = new Array(LENGTH_CODES);
        zero(base_length);
        var base_dist = new Array(D_CODES);
        zero(base_dist);
        function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
          this.static_tree = static_tree;
          this.extra_bits = extra_bits;
          this.extra_base = extra_base;
          this.elems = elems;
          this.max_length = max_length;
          this.has_stree = static_tree && static_tree.length;
        }
        var static_l_desc;
        var static_d_desc;
        var static_bl_desc;
        function TreeDesc(dyn_tree, stat_desc) {
          this.dyn_tree = dyn_tree;
          this.max_code = 0;
          this.stat_desc = stat_desc;
        }
        function d_code(dist) {
          return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
        }
        function put_short(s3, w4) {
          s3.pending_buf[s3.pending++] = w4 & 255;
          s3.pending_buf[s3.pending++] = w4 >>> 8 & 255;
        }
        function send_bits(s3, value, length) {
          if (s3.bi_valid > Buf_size - length) {
            s3.bi_buf |= value << s3.bi_valid & 65535;
            put_short(s3, s3.bi_buf);
            s3.bi_buf = value >> Buf_size - s3.bi_valid;
            s3.bi_valid += length - Buf_size;
          } else {
            s3.bi_buf |= value << s3.bi_valid & 65535;
            s3.bi_valid += length;
          }
        }
        function send_code(s3, c3, tree) {
          send_bits(s3, tree[c3 * 2], tree[c3 * 2 + 1]);
        }
        function bi_reverse(code, len) {
          var res = 0;
          do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
          } while (--len > 0);
          return res >>> 1;
        }
        function bi_flush(s3) {
          if (s3.bi_valid === 16) {
            put_short(s3, s3.bi_buf);
            s3.bi_buf = 0;
            s3.bi_valid = 0;
          } else if (s3.bi_valid >= 8) {
            s3.pending_buf[s3.pending++] = s3.bi_buf & 255;
            s3.bi_buf >>= 8;
            s3.bi_valid -= 8;
          }
        }
        function gen_bitlen(s3, desc) {
          var tree = desc.dyn_tree;
          var max_code = desc.max_code;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var extra = desc.stat_desc.extra_bits;
          var base = desc.stat_desc.extra_base;
          var max_length = desc.stat_desc.max_length;
          var h3;
          var n2, m3;
          var bits;
          var xbits;
          var f3;
          var overflow = 0;
          for (bits = 0; bits <= MAX_BITS; bits++) {
            s3.bl_count[bits] = 0;
          }
          tree[s3.heap[s3.heap_max] * 2 + 1] = 0;
          for (h3 = s3.heap_max + 1; h3 < HEAP_SIZE; h3++) {
            n2 = s3.heap[h3];
            bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
              bits = max_length;
              overflow++;
            }
            tree[n2 * 2 + 1] = bits;
            if (n2 > max_code) {
              continue;
            }
            s3.bl_count[bits]++;
            xbits = 0;
            if (n2 >= base) {
              xbits = extra[n2 - base];
            }
            f3 = tree[n2 * 2];
            s3.opt_len += f3 * (bits + xbits);
            if (has_stree) {
              s3.static_len += f3 * (stree[n2 * 2 + 1] + xbits);
            }
          }
          if (overflow === 0) {
            return;
          }
          do {
            bits = max_length - 1;
            while (s3.bl_count[bits] === 0) {
              bits--;
            }
            s3.bl_count[bits]--;
            s3.bl_count[bits + 1] += 2;
            s3.bl_count[max_length]--;
            overflow -= 2;
          } while (overflow > 0);
          for (bits = max_length; bits !== 0; bits--) {
            n2 = s3.bl_count[bits];
            while (n2 !== 0) {
              m3 = s3.heap[--h3];
              if (m3 > max_code) {
                continue;
              }
              if (tree[m3 * 2 + 1] !== bits) {
                s3.opt_len += (bits - tree[m3 * 2 + 1]) * tree[m3 * 2];
                tree[m3 * 2 + 1] = bits;
              }
              n2--;
            }
          }
        }
        function gen_codes(tree, max_code, bl_count) {
          var next_code = new Array(MAX_BITS + 1);
          var code = 0;
          var bits;
          var n2;
          for (bits = 1; bits <= MAX_BITS; bits++) {
            next_code[bits] = code = code + bl_count[bits - 1] << 1;
          }
          for (n2 = 0; n2 <= max_code; n2++) {
            var len = tree[n2 * 2 + 1];
            if (len === 0) {
              continue;
            }
            tree[n2 * 2] = bi_reverse(next_code[len]++, len);
          }
        }
        function tr_static_init() {
          var n2;
          var bits;
          var length;
          var code;
          var dist;
          var bl_count = new Array(MAX_BITS + 1);
          length = 0;
          for (code = 0; code < LENGTH_CODES - 1; code++) {
            base_length[code] = length;
            for (n2 = 0; n2 < 1 << extra_lbits[code]; n2++) {
              _length_code[length++] = code;
            }
          }
          _length_code[length - 1] = code;
          dist = 0;
          for (code = 0; code < 16; code++) {
            base_dist[code] = dist;
            for (n2 = 0; n2 < 1 << extra_dbits[code]; n2++) {
              _dist_code[dist++] = code;
            }
          }
          dist >>= 7;
          for (; code < D_CODES; code++) {
            base_dist[code] = dist << 7;
            for (n2 = 0; n2 < 1 << extra_dbits[code] - 7; n2++) {
              _dist_code[256 + dist++] = code;
            }
          }
          for (bits = 0; bits <= MAX_BITS; bits++) {
            bl_count[bits] = 0;
          }
          n2 = 0;
          while (n2 <= 143) {
            static_ltree[n2 * 2 + 1] = 8;
            n2++;
            bl_count[8]++;
          }
          while (n2 <= 255) {
            static_ltree[n2 * 2 + 1] = 9;
            n2++;
            bl_count[9]++;
          }
          while (n2 <= 279) {
            static_ltree[n2 * 2 + 1] = 7;
            n2++;
            bl_count[7]++;
          }
          while (n2 <= 287) {
            static_ltree[n2 * 2 + 1] = 8;
            n2++;
            bl_count[8]++;
          }
          gen_codes(static_ltree, L_CODES + 1, bl_count);
          for (n2 = 0; n2 < D_CODES; n2++) {
            static_dtree[n2 * 2 + 1] = 5;
            static_dtree[n2 * 2] = bi_reverse(n2, 5);
          }
          static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
          static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
          static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
        }
        function init_block(s3) {
          var n2;
          for (n2 = 0; n2 < L_CODES; n2++) {
            s3.dyn_ltree[n2 * 2] = 0;
          }
          for (n2 = 0; n2 < D_CODES; n2++) {
            s3.dyn_dtree[n2 * 2] = 0;
          }
          for (n2 = 0; n2 < BL_CODES; n2++) {
            s3.bl_tree[n2 * 2] = 0;
          }
          s3.dyn_ltree[END_BLOCK * 2] = 1;
          s3.opt_len = s3.static_len = 0;
          s3.last_lit = s3.matches = 0;
        }
        function bi_windup(s3) {
          if (s3.bi_valid > 8) {
            put_short(s3, s3.bi_buf);
          } else if (s3.bi_valid > 0) {
            s3.pending_buf[s3.pending++] = s3.bi_buf;
          }
          s3.bi_buf = 0;
          s3.bi_valid = 0;
        }
        function copy_block(s3, buf, len, header) {
          bi_windup(s3);
          if (header) {
            put_short(s3, len);
            put_short(s3, ~len);
          }
          utils.arraySet(s3.pending_buf, s3.window, buf, len, s3.pending);
          s3.pending += len;
        }
        function smaller(tree, n2, m3, depth) {
          var _n2 = n2 * 2;
          var _m2 = m3 * 2;
          return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m3];
        }
        function pqdownheap(s3, tree, k4) {
          var v3 = s3.heap[k4];
          var j4 = k4 << 1;
          while (j4 <= s3.heap_len) {
            if (j4 < s3.heap_len && smaller(tree, s3.heap[j4 + 1], s3.heap[j4], s3.depth)) {
              j4++;
            }
            if (smaller(tree, v3, s3.heap[j4], s3.depth)) {
              break;
            }
            s3.heap[k4] = s3.heap[j4];
            k4 = j4;
            j4 <<= 1;
          }
          s3.heap[k4] = v3;
        }
        function compress_block(s3, ltree, dtree) {
          var dist;
          var lc;
          var lx = 0;
          var code;
          var extra;
          if (s3.last_lit !== 0) {
            do {
              dist = s3.pending_buf[s3.d_buf + lx * 2] << 8 | s3.pending_buf[s3.d_buf + lx * 2 + 1];
              lc = s3.pending_buf[s3.l_buf + lx];
              lx++;
              if (dist === 0) {
                send_code(s3, lc, ltree);
              } else {
                code = _length_code[lc];
                send_code(s3, code + LITERALS + 1, ltree);
                extra = extra_lbits[code];
                if (extra !== 0) {
                  lc -= base_length[code];
                  send_bits(s3, lc, extra);
                }
                dist--;
                code = d_code(dist);
                send_code(s3, code, dtree);
                extra = extra_dbits[code];
                if (extra !== 0) {
                  dist -= base_dist[code];
                  send_bits(s3, dist, extra);
                }
              }
            } while (lx < s3.last_lit);
          }
          send_code(s3, END_BLOCK, ltree);
        }
        function build_tree(s3, desc) {
          var tree = desc.dyn_tree;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var elems = desc.stat_desc.elems;
          var n2, m3;
          var max_code = -1;
          var node;
          s3.heap_len = 0;
          s3.heap_max = HEAP_SIZE;
          for (n2 = 0; n2 < elems; n2++) {
            if (tree[n2 * 2] !== 0) {
              s3.heap[++s3.heap_len] = max_code = n2;
              s3.depth[n2] = 0;
            } else {
              tree[n2 * 2 + 1] = 0;
            }
          }
          while (s3.heap_len < 2) {
            node = s3.heap[++s3.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s3.depth[node] = 0;
            s3.opt_len--;
            if (has_stree) {
              s3.static_len -= stree[node * 2 + 1];
            }
          }
          desc.max_code = max_code;
          for (n2 = s3.heap_len >> 1; n2 >= 1; n2--) {
            pqdownheap(s3, tree, n2);
          }
          node = elems;
          do {
            n2 = s3.heap[1];
            s3.heap[1] = s3.heap[s3.heap_len--];
            pqdownheap(s3, tree, 1);
            m3 = s3.heap[1];
            s3.heap[--s3.heap_max] = n2;
            s3.heap[--s3.heap_max] = m3;
            tree[node * 2] = tree[n2 * 2] + tree[m3 * 2];
            s3.depth[node] = (s3.depth[n2] >= s3.depth[m3] ? s3.depth[n2] : s3.depth[m3]) + 1;
            tree[n2 * 2 + 1] = tree[m3 * 2 + 1] = node;
            s3.heap[1] = node++;
            pqdownheap(s3, tree, 1);
          } while (s3.heap_len >= 2);
          s3.heap[--s3.heap_max] = s3.heap[1];
          gen_bitlen(s3, desc);
          gen_codes(tree, max_code, s3.bl_count);
        }
        function scan_tree(s3, tree, max_code) {
          var n2;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          tree[(max_code + 1) * 2 + 1] = 65535;
          for (n2 = 0; n2 <= max_code; n2++) {
            curlen = nextlen;
            nextlen = tree[(n2 + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              s3.bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                s3.bl_tree[curlen * 2]++;
              }
              s3.bl_tree[REP_3_6 * 2]++;
            } else if (count <= 10) {
              s3.bl_tree[REPZ_3_10 * 2]++;
            } else {
              s3.bl_tree[REPZ_11_138 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        }
        function send_tree(s3, tree, max_code) {
          var n2;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          for (n2 = 0; n2 <= max_code; n2++) {
            curlen = nextlen;
            nextlen = tree[(n2 + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              do {
                send_code(s3, curlen, s3.bl_tree);
              } while (--count !== 0);
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                send_code(s3, curlen, s3.bl_tree);
                count--;
              }
              send_code(s3, REP_3_6, s3.bl_tree);
              send_bits(s3, count - 3, 2);
            } else if (count <= 10) {
              send_code(s3, REPZ_3_10, s3.bl_tree);
              send_bits(s3, count - 3, 3);
            } else {
              send_code(s3, REPZ_11_138, s3.bl_tree);
              send_bits(s3, count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        }
        function build_bl_tree(s3) {
          var max_blindex;
          scan_tree(s3, s3.dyn_ltree, s3.l_desc.max_code);
          scan_tree(s3, s3.dyn_dtree, s3.d_desc.max_code);
          build_tree(s3, s3.bl_desc);
          for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
            if (s3.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
              break;
            }
          }
          s3.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
          return max_blindex;
        }
        function send_all_trees(s3, lcodes, dcodes, blcodes) {
          var rank;
          send_bits(s3, lcodes - 257, 5);
          send_bits(s3, dcodes - 1, 5);
          send_bits(s3, blcodes - 4, 4);
          for (rank = 0; rank < blcodes; rank++) {
            send_bits(s3, s3.bl_tree[bl_order[rank] * 2 + 1], 3);
          }
          send_tree(s3, s3.dyn_ltree, lcodes - 1);
          send_tree(s3, s3.dyn_dtree, dcodes - 1);
        }
        function detect_data_type(s3) {
          var black_mask = 4093624447;
          var n2;
          for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
            if (black_mask & 1 && s3.dyn_ltree[n2 * 2] !== 0) {
              return Z_BINARY;
            }
          }
          if (s3.dyn_ltree[9 * 2] !== 0 || s3.dyn_ltree[10 * 2] !== 0 || s3.dyn_ltree[13 * 2] !== 0) {
            return Z_TEXT;
          }
          for (n2 = 32; n2 < LITERALS; n2++) {
            if (s3.dyn_ltree[n2 * 2] !== 0) {
              return Z_TEXT;
            }
          }
          return Z_BINARY;
        }
        var static_init_done = false;
        function _tr_init(s3) {
          if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
          }
          s3.l_desc = new TreeDesc(s3.dyn_ltree, static_l_desc);
          s3.d_desc = new TreeDesc(s3.dyn_dtree, static_d_desc);
          s3.bl_desc = new TreeDesc(s3.bl_tree, static_bl_desc);
          s3.bi_buf = 0;
          s3.bi_valid = 0;
          init_block(s3);
        }
        function _tr_stored_block(s3, buf, stored_len, last) {
          send_bits(s3, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
          copy_block(s3, buf, stored_len, true);
        }
        function _tr_align(s3) {
          send_bits(s3, STATIC_TREES << 1, 3);
          send_code(s3, END_BLOCK, static_ltree);
          bi_flush(s3);
        }
        function _tr_flush_block(s3, buf, stored_len, last) {
          var opt_lenb, static_lenb;
          var max_blindex = 0;
          if (s3.level > 0) {
            if (s3.strm.data_type === Z_UNKNOWN) {
              s3.strm.data_type = detect_data_type(s3);
            }
            build_tree(s3, s3.l_desc);
            build_tree(s3, s3.d_desc);
            max_blindex = build_bl_tree(s3);
            opt_lenb = s3.opt_len + 3 + 7 >>> 3;
            static_lenb = s3.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) {
              opt_lenb = static_lenb;
            }
          } else {
            opt_lenb = static_lenb = stored_len + 5;
          }
          if (stored_len + 4 <= opt_lenb && buf !== -1) {
            _tr_stored_block(s3, buf, stored_len, last);
          } else if (s3.strategy === Z_FIXED || static_lenb === opt_lenb) {
            send_bits(s3, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
            compress_block(s3, static_ltree, static_dtree);
          } else {
            send_bits(s3, (DYN_TREES << 1) + (last ? 1 : 0), 3);
            send_all_trees(s3, s3.l_desc.max_code + 1, s3.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s3, s3.dyn_ltree, s3.dyn_dtree);
          }
          init_block(s3);
          if (last) {
            bi_windup(s3);
          }
        }
        function _tr_tally(s3, dist, lc) {
          s3.pending_buf[s3.d_buf + s3.last_lit * 2] = dist >>> 8 & 255;
          s3.pending_buf[s3.d_buf + s3.last_lit * 2 + 1] = dist & 255;
          s3.pending_buf[s3.l_buf + s3.last_lit] = lc & 255;
          s3.last_lit++;
          if (dist === 0) {
            s3.dyn_ltree[lc * 2]++;
          } else {
            s3.matches++;
            dist--;
            s3.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
            s3.dyn_dtree[d_code(dist) * 2]++;
          }
          return s3.last_lit === s3.lit_bufsize - 1;
        }
        exports3._tr_init = _tr_init;
        exports3._tr_stored_block = _tr_stored_block;
        exports3._tr_flush_block = _tr_flush_block;
        exports3._tr_tally = _tr_tally;
        exports3._tr_align = _tr_align;
      }, { "../utils/common": 41 }], 53: [function(require2, module4, exports3) {
        "use strict";
        function ZStream() {
          this.input = null;
          this.next_in = 0;
          this.avail_in = 0;
          this.total_in = 0;
          this.output = null;
          this.next_out = 0;
          this.avail_out = 0;
          this.total_out = 0;
          this.msg = "";
          this.state = null;
          this.data_type = 2;
          this.adler = 0;
        }
        module4.exports = ZStream;
      }, {}], 54: [function(require2, module4, exports3) {
        "use strict";
        module4.exports = typeof setImmediate === "function" ? setImmediate : function setImmediate2() {
          var args = [].slice.apply(arguments);
          args.splice(1, 0, 0);
          setTimeout.apply(null, args);
        };
      }, {}] }, {}, [10])(10);
    });
  }
});

// node_modules/epubjs/lib/archive.js
var require_archive = __commonJS({
  "node_modules/epubjs/lib/archive.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _request = _interopRequireDefault(require_request());
    var _mime = _interopRequireDefault(require_mime());
    var _path = _interopRequireDefault(require_path2());
    var _jszip = _interopRequireDefault(require_jszip());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Archive = class {
      constructor() {
        this.zip = void 0;
        this.urlCache = {};
        this.checkRequirements();
      }
      checkRequirements() {
        try {
          this.zip = new _jszip.default();
        } catch (e3) {
          throw new Error("JSZip lib not loaded");
        }
      }
      open(input, isBase64) {
        return this.zip.loadAsync(input, {
          "base64": isBase64
        });
      }
      openUrl(zipUrl, isBase64) {
        return (0, _request.default)(zipUrl, "binary").then(function(data) {
          return this.zip.loadAsync(data, {
            "base64": isBase64
          });
        }.bind(this));
      }
      request(url, type) {
        var deferred = new _core.defer();
        var response;
        var path = new _path.default(url);
        if (!type) {
          type = path.extension;
        }
        if (type == "blob") {
          response = this.getBlob(url);
        } else {
          response = this.getText(url);
        }
        if (response) {
          response.then(function(r3) {
            let result = this.handleResponse(r3, type);
            deferred.resolve(result);
          }.bind(this));
        } else {
          deferred.reject({
            message: "File not found in the epub: " + url,
            stack: new Error().stack
          });
        }
        return deferred.promise;
      }
      handleResponse(response, type) {
        var r3;
        if (type == "json") {
          r3 = JSON.parse(response);
        } else if ((0, _core.isXml)(type)) {
          r3 = (0, _core.parse)(response, "text/xml");
        } else if (type == "xhtml") {
          r3 = (0, _core.parse)(response, "application/xhtml+xml");
        } else if (type == "html" || type == "htm") {
          r3 = (0, _core.parse)(response, "text/html");
        } else {
          r3 = response;
        }
        return r3;
      }
      getBlob(url, mimeType) {
        var decodededUrl = window.decodeURIComponent(url.substr(1));
        var entry = this.zip.file(decodededUrl);
        if (entry) {
          mimeType = mimeType || _mime.default.lookup(entry.name);
          return entry.async("uint8array").then(function(uint8array) {
            return new Blob([uint8array], {
              type: mimeType
            });
          });
        }
      }
      getText(url, encoding) {
        var decodededUrl = window.decodeURIComponent(url.substr(1));
        var entry = this.zip.file(decodededUrl);
        if (entry) {
          return entry.async("string").then(function(text) {
            return text;
          });
        }
      }
      getBase64(url, mimeType) {
        var decodededUrl = window.decodeURIComponent(url.substr(1));
        var entry = this.zip.file(decodededUrl);
        if (entry) {
          mimeType = mimeType || _mime.default.lookup(entry.name);
          return entry.async("base64").then(function(data) {
            return "data:" + mimeType + ";base64," + data;
          });
        }
      }
      createUrl(url, options) {
        var deferred = new _core.defer();
        var _URL = window.URL || window.webkitURL || window.mozURL;
        var tempUrl;
        var response;
        var useBase64 = options && options.base64;
        if (url in this.urlCache) {
          deferred.resolve(this.urlCache[url]);
          return deferred.promise;
        }
        if (useBase64) {
          response = this.getBase64(url);
          if (response) {
            response.then(function(tempUrl2) {
              this.urlCache[url] = tempUrl2;
              deferred.resolve(tempUrl2);
            }.bind(this));
          }
        } else {
          response = this.getBlob(url);
          if (response) {
            response.then(function(blob) {
              tempUrl = _URL.createObjectURL(blob);
              this.urlCache[url] = tempUrl;
              deferred.resolve(tempUrl);
            }.bind(this));
          }
        }
        if (!response) {
          deferred.reject({
            message: "File not found in the epub: " + url,
            stack: new Error().stack
          });
        }
        return deferred.promise;
      }
      revokeUrl(url) {
        var _URL = window.URL || window.webkitURL || window.mozURL;
        var fromCache = this.urlCache[url];
        if (fromCache)
          _URL.revokeObjectURL(fromCache);
      }
      destroy() {
        var _URL = window.URL || window.webkitURL || window.mozURL;
        for (let fromCache in this.urlCache) {
          _URL.revokeObjectURL(fromCache);
        }
        this.zip = void 0;
        this.urlCache = {};
      }
    };
    var _default = Archive;
    exports.default = _default;
  }
});

// node_modules/localforage/dist/localforage.js
var require_localforage = __commonJS({
  "node_modules/localforage/dist/localforage.js"(exports, module2) {
    (function(f3) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f3();
      } else if (typeof define === "function" && define.amd) {
        define([], f3);
      } else {
        var g4;
        if (typeof window !== "undefined") {
          g4 = window;
        } else if (typeof global !== "undefined") {
          g4 = global;
        } else if (typeof self !== "undefined") {
          g4 = self;
        } else {
          g4 = this;
        }
        g4.localforage = f3();
      }
    })(function() {
      var define2, module3, exports2;
      return function e3(t3, n2, r3) {
        function s3(o4, u3) {
          if (!n2[o4]) {
            if (!t3[o4]) {
              var a3 = typeof require == "function" && require;
              if (!u3 && a3)
                return a3(o4, true);
              if (i3)
                return i3(o4, true);
              var f3 = new Error("Cannot find module '" + o4 + "'");
              throw f3.code = "MODULE_NOT_FOUND", f3;
            }
            var l3 = n2[o4] = { exports: {} };
            t3[o4][0].call(l3.exports, function(e4) {
              var n3 = t3[o4][1][e4];
              return s3(n3 ? n3 : e4);
            }, l3, l3.exports, e3, t3, n2, r3);
          }
          return n2[o4].exports;
        }
        var i3 = typeof require == "function" && require;
        for (var o3 = 0; o3 < r3.length; o3++)
          s3(r3[o3]);
        return s3;
      }({ 1: [function(_dereq_, module4, exports3) {
        (function(global2) {
          "use strict";
          var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
          var scheduleDrain;
          {
            if (Mutation) {
              var called = 0;
              var observer = new Mutation(nextTick);
              var element = global2.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              scheduleDrain = function() {
                element.data = called = ++called % 2;
              };
            } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
              var channel = new global2.MessageChannel();
              channel.port1.onmessage = nextTick;
              scheduleDrain = function() {
                channel.port2.postMessage(0);
              };
            } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
              scheduleDrain = function() {
                var scriptEl = global2.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  nextTick();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global2.document.documentElement.appendChild(scriptEl);
              };
            } else {
              scheduleDrain = function() {
                setTimeout(nextTick, 0);
              };
            }
          }
          var draining;
          var queue = [];
          function nextTick() {
            draining = true;
            var i3, oldQueue;
            var len = queue.length;
            while (len) {
              oldQueue = queue;
              queue = [];
              i3 = -1;
              while (++i3 < len) {
                oldQueue[i3]();
              }
              len = queue.length;
            }
            draining = false;
          }
          module4.exports = immediate;
          function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
              scheduleDrain();
            }
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 2: [function(_dereq_, module4, exports3) {
        "use strict";
        var immediate = _dereq_(1);
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module4.exports = Promise2;
        function Promise2(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap(this.promise, this.onRejected, value);
        };
        function unwrap(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e3) {
              return handlers.reject(promise, e3);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i3 = -1;
            var len = self2.queue.length;
            while (++i3 < len) {
              self2.queue[i3].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i3 = -1;
          var len = self2.queue.length;
          while (++i3 < len) {
            self2.queue[i3].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e3) {
            out.status = "error";
            out.value = e3;
          }
          return out;
        }
        Promise2.resolve = resolve;
        function resolve(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        Promise2.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        Promise2.all = all;
        function all(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i3 = -1;
          var promise = new this(INTERNAL);
          while (++i3 < len) {
            allResolver(iterable[i3], i3);
          }
          return promise;
          function allResolver(value, i4) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i4] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        Promise2.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i3 = -1;
          var promise = new this(INTERNAL);
          while (++i3 < len) {
            resolver(iterable[i3]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "1": 1 }], 3: [function(_dereq_, module4, exports3) {
        (function(global2) {
          "use strict";
          if (typeof global2.Promise !== "function") {
            global2.Promise = _dereq_(2);
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "2": 2 }], 4: [function(_dereq_, module4, exports3) {
        "use strict";
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function getIDB() {
          try {
            if (typeof indexedDB !== "undefined") {
              return indexedDB;
            }
            if (typeof webkitIndexedDB !== "undefined") {
              return webkitIndexedDB;
            }
            if (typeof mozIndexedDB !== "undefined") {
              return mozIndexedDB;
            }
            if (typeof OIndexedDB !== "undefined") {
              return OIndexedDB;
            }
            if (typeof msIndexedDB !== "undefined") {
              return msIndexedDB;
            }
          } catch (e3) {
            return;
          }
        }
        var idb = getIDB();
        function isIndexedDBValid() {
          try {
            if (!idb || !idb.open) {
              return false;
            }
            var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
            var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && typeof IDBKeyRange !== "undefined";
          } catch (e3) {
            return false;
          }
        }
        function createBlob(parts, properties) {
          parts = parts || [];
          properties = properties || {};
          try {
            return new Blob(parts, properties);
          } catch (e3) {
            if (e3.name !== "TypeError") {
              throw e3;
            }
            var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
            var builder = new Builder();
            for (var i3 = 0; i3 < parts.length; i3 += 1) {
              builder.append(parts[i3]);
            }
            return builder.getBlob(properties.type);
          }
        }
        if (typeof Promise === "undefined") {
          _dereq_(3);
        }
        var Promise$1 = Promise;
        function executeCallback(promise, callback) {
          if (callback) {
            promise.then(function(result) {
              callback(null, result);
            }, function(error) {
              callback(error);
            });
          }
        }
        function executeTwoCallbacks(promise, callback, errorCallback) {
          if (typeof callback === "function") {
            promise.then(callback);
          }
          if (typeof errorCallback === "function") {
            promise["catch"](errorCallback);
          }
        }
        function normalizeKey(key2) {
          if (typeof key2 !== "string") {
            console.warn(key2 + " used as a key, but it is not a string.");
            key2 = String(key2);
          }
          return key2;
        }
        function getCallback() {
          if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
            return arguments[arguments.length - 1];
          }
        }
        var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
        var supportsBlobs = void 0;
        var dbContexts = {};
        var toString = Object.prototype.toString;
        var READ_ONLY = "readonly";
        var READ_WRITE = "readwrite";
        function _binStringToArrayBuffer(bin) {
          var length2 = bin.length;
          var buf = new ArrayBuffer(length2);
          var arr = new Uint8Array(buf);
          for (var i3 = 0; i3 < length2; i3++) {
            arr[i3] = bin.charCodeAt(i3);
          }
          return buf;
        }
        function _checkBlobSupportWithoutCaching(idb2) {
          return new Promise$1(function(resolve) {
            var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
            var blob = createBlob([""]);
            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
            txn.onabort = function(e3) {
              e3.preventDefault();
              e3.stopPropagation();
              resolve(false);
            };
            txn.oncomplete = function() {
              var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
              var matchedEdge = navigator.userAgent.match(/Edge\//);
              resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
            };
          })["catch"](function() {
            return false;
          });
        }
        function _checkBlobSupport(idb2) {
          if (typeof supportsBlobs === "boolean") {
            return Promise$1.resolve(supportsBlobs);
          }
          return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
            supportsBlobs = value;
            return supportsBlobs;
          });
        }
        function _deferReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = {};
          deferredOperation.promise = new Promise$1(function(resolve, reject) {
            deferredOperation.resolve = resolve;
            deferredOperation.reject = reject;
          });
          dbContext.deferredOperations.push(deferredOperation);
          if (!dbContext.dbReady) {
            dbContext.dbReady = deferredOperation.promise;
          } else {
            dbContext.dbReady = dbContext.dbReady.then(function() {
              return deferredOperation.promise;
            });
          }
        }
        function _advanceReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.resolve();
            return deferredOperation.promise;
          }
        }
        function _rejectReadiness(dbInfo, err) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.reject(err);
            return deferredOperation.promise;
          }
        }
        function _getConnection(dbInfo, upgradeNeeded) {
          return new Promise$1(function(resolve, reject) {
            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
            if (dbInfo.db) {
              if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
              } else {
                return resolve(dbInfo.db);
              }
            }
            var dbArgs = [dbInfo.name];
            if (upgradeNeeded) {
              dbArgs.push(dbInfo.version);
            }
            var openreq = idb.open.apply(idb, dbArgs);
            if (upgradeNeeded) {
              openreq.onupgradeneeded = function(e3) {
                var db = openreq.result;
                try {
                  db.createObjectStore(dbInfo.storeName);
                  if (e3.oldVersion <= 1) {
                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                  }
                } catch (ex) {
                  if (ex.name === "ConstraintError") {
                    console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e3.oldVersion + " to version " + e3.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                  } else {
                    throw ex;
                  }
                }
              };
            }
            openreq.onerror = function(e3) {
              e3.preventDefault();
              reject(openreq.error);
            };
            openreq.onsuccess = function() {
              var db = openreq.result;
              db.onversionchange = function(e3) {
                e3.target.close();
              };
              resolve(db);
              _advanceReadiness(dbInfo);
            };
          });
        }
        function _getOriginalConnection(dbInfo) {
          return _getConnection(dbInfo, false);
        }
        function _getUpgradedConnection(dbInfo) {
          return _getConnection(dbInfo, true);
        }
        function _isUpgradeNeeded(dbInfo, defaultVersion) {
          if (!dbInfo.db) {
            return true;
          }
          var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
          var isDowngrade = dbInfo.version < dbInfo.db.version;
          var isUpgrade = dbInfo.version > dbInfo.db.version;
          if (isDowngrade) {
            if (dbInfo.version !== defaultVersion) {
              console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
            }
            dbInfo.version = dbInfo.db.version;
          }
          if (isUpgrade || isNewStore) {
            if (isNewStore) {
              var incVersion = dbInfo.db.version + 1;
              if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
              }
            }
            return true;
          }
          return false;
        }
        function _encodeBlob(blob) {
          return new Promise$1(function(resolve, reject) {
            var reader = new FileReader();
            reader.onerror = reject;
            reader.onloadend = function(e3) {
              var base64 = btoa(e3.target.result || "");
              resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
              });
            };
            reader.readAsBinaryString(blob);
          });
        }
        function _decodeBlob(encodedBlob) {
          var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
          return createBlob([arrayBuff], { type: encodedBlob.type });
        }
        function _isEncodedBlob(value) {
          return value && value.__local_forage_encoded_blob;
        }
        function _fullyReady(callback) {
          var self2 = this;
          var promise = self2._initReady().then(function() {
            var dbContext = dbContexts[self2._dbInfo.name];
            if (dbContext && dbContext.dbReady) {
              return dbContext.dbReady;
            }
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        }
        function _tryReconnect(dbInfo) {
          _deferReadiness(dbInfo);
          var dbContext = dbContexts[dbInfo.name];
          var forages = dbContext.forages;
          for (var i3 = 0; i3 < forages.length; i3++) {
            var forage = forages[i3];
            if (forage._dbInfo.db) {
              forage._dbInfo.db.close();
              forage._dbInfo.db = null;
            }
          }
          dbInfo.db = null;
          return _getOriginalConnection(dbInfo).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            for (var i4 = 0; i4 < forages.length; i4++) {
              forages[i4]._dbInfo.db = db;
            }
          })["catch"](function(err) {
            _rejectReadiness(dbInfo, err);
            throw err;
          });
        }
        function createTransaction(dbInfo, mode, callback, retries) {
          if (retries === void 0) {
            retries = 1;
          }
          try {
            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
            callback(null, tx);
          } catch (err) {
            if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
              return Promise$1.resolve().then(function() {
                if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                  if (dbInfo.db) {
                    dbInfo.version = dbInfo.db.version + 1;
                  }
                  return _getUpgradedConnection(dbInfo);
                }
              }).then(function() {
                return _tryReconnect(dbInfo).then(function() {
                  createTransaction(dbInfo, mode, callback, retries - 1);
                });
              })["catch"](callback);
            }
            callback(err);
          }
        }
        function createDbContext() {
          return {
            forages: [],
            db: null,
            dbReady: null,
            deferredOperations: []
          };
        }
        function _initStorage(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i3 in options) {
              dbInfo[i3] = options[i3];
            }
          }
          var dbContext = dbContexts[dbInfo.name];
          if (!dbContext) {
            dbContext = createDbContext();
            dbContexts[dbInfo.name] = dbContext;
          }
          dbContext.forages.push(self2);
          if (!self2._initReady) {
            self2._initReady = self2.ready;
            self2.ready = _fullyReady;
          }
          var initPromises = [];
          function ignoreErrors() {
            return Promise$1.resolve();
          }
          for (var j4 = 0; j4 < dbContext.forages.length; j4++) {
            var forage = dbContext.forages[j4];
            if (forage !== self2) {
              initPromises.push(forage._initReady()["catch"](ignoreErrors));
            }
          }
          var forages = dbContext.forages.slice(0);
          return Promise$1.all(initPromises).then(function() {
            dbInfo.db = dbContext.db;
            return _getOriginalConnection(dbInfo);
          }).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            self2._dbInfo = dbInfo;
            for (var k4 = 0; k4 < forages.length; k4++) {
              var forage2 = forages[k4];
              if (forage2 !== self2) {
                forage2._dbInfo.db = dbInfo.db;
                forage2._dbInfo.version = dbInfo.version;
              }
            }
          });
        }
        function getItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.get(key2);
                  req.onsuccess = function() {
                    var value = req.result;
                    if (value === void 0) {
                      value = null;
                    }
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    resolve(value);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openCursor();
                  var iterationNumber = 1;
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (cursor) {
                      var value = cursor.value;
                      if (_isEncodedBlob(value)) {
                        value = _decodeBlob(value);
                      }
                      var result = iterator(value, cursor.key, iterationNumber++);
                      if (result !== void 0) {
                        resolve(result);
                      } else {
                        cursor["continue"]();
                      }
                    } else {
                      resolve();
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            var dbInfo;
            self2.ready().then(function() {
              dbInfo = self2._dbInfo;
              if (toString.call(value) === "[object Blob]") {
                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                  if (blobSupport) {
                    return value;
                  }
                  return _encodeBlob(value);
                });
              }
              return value;
            }).then(function(value2) {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  if (value2 === null) {
                    value2 = void 0;
                  }
                  var req = store.put(value2, key2);
                  transaction.oncomplete = function() {
                    if (value2 === void 0) {
                      value2 = null;
                    }
                    resolve(value2);
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store["delete"](key2);
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onerror = function() {
                    reject(req.error);
                  };
                  transaction.onabort = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.clear();
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.count();
                  req.onsuccess = function() {
                    resolve(req.result);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key(n2, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            if (n2 < 0) {
              resolve(null);
              return;
            }
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var advanced = false;
                  var req = store.openKeyCursor();
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(null);
                      return;
                    }
                    if (n2 === 0) {
                      resolve(cursor.key);
                    } else {
                      if (!advanced) {
                        advanced = true;
                        cursor.advance(n2);
                      } else {
                        resolve(cursor.key);
                      }
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openKeyCursor();
                  var keys2 = [];
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(keys2);
                      return;
                    }
                    keys2.push(cursor.key);
                    cursor["continue"]();
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e3) {
                  reject(e3);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
            var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              dbContext.db = db;
              for (var i3 = 0; i3 < forages.length; i3++) {
                forages[i3]._dbInfo.db = db;
              }
              return db;
            });
            if (!options.storeName) {
              promise = dbPromise.then(function(db) {
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i3 = 0; i3 < forages.length; i3++) {
                  var forage = forages[i3];
                  forage._dbInfo.db = null;
                }
                var dropDBPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.deleteDatabase(options.name);
                  req.onerror = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    reject(req.error);
                  };
                  req.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    resolve(db2);
                  };
                });
                return dropDBPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var i4 = 0; i4 < forages.length; i4++) {
                    var _forage = forages[i4];
                    _advanceReadiness(_forage._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            } else {
              promise = dbPromise.then(function(db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                  return;
                }
                var newVersion = db.version + 1;
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i3 = 0; i3 < forages.length; i3++) {
                  var forage = forages[i3];
                  forage._dbInfo.db = null;
                  forage._dbInfo.version = newVersion;
                }
                var dropObjectPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.open(options.name, newVersion);
                  req.onerror = function(err) {
                    var db2 = req.result;
                    db2.close();
                    reject(err);
                  };
                  req.onupgradeneeded = function() {
                    var db2 = req.result;
                    db2.deleteObjectStore(options.storeName);
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    db2.close();
                    resolve(db2);
                  };
                });
                return dropObjectPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var j4 = 0; j4 < forages.length; j4++) {
                    var _forage2 = forages[j4];
                    _forage2._dbInfo.db = db2;
                    _advanceReadiness(_forage2._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            }
          }
          executeCallback(promise, callback);
          return promise;
        }
        var asyncStorage = {
          _driver: "asyncStorage",
          _initStorage,
          _support: isIndexedDBValid(),
          iterate,
          getItem,
          setItem,
          removeItem,
          clear,
          length,
          key,
          keys,
          dropInstance
        };
        function isWebSQLValid() {
          return typeof openDatabase === "function";
        }
        var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var BLOB_TYPE_PREFIX = "~~local_forage_type~";
        var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
        var SERIALIZED_MARKER = "__lfsc__:";
        var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
        var TYPE_ARRAYBUFFER = "arbf";
        var TYPE_BLOB = "blob";
        var TYPE_INT8ARRAY = "si08";
        var TYPE_UINT8ARRAY = "ui08";
        var TYPE_UINT8CLAMPEDARRAY = "uic8";
        var TYPE_INT16ARRAY = "si16";
        var TYPE_INT32ARRAY = "si32";
        var TYPE_UINT16ARRAY = "ur16";
        var TYPE_UINT32ARRAY = "ui32";
        var TYPE_FLOAT32ARRAY = "fl32";
        var TYPE_FLOAT64ARRAY = "fl64";
        var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
        var toString$1 = Object.prototype.toString;
        function stringToBuffer(serializedString) {
          var bufferLength = serializedString.length * 0.75;
          var len = serializedString.length;
          var i3;
          var p3 = 0;
          var encoded1, encoded2, encoded3, encoded4;
          if (serializedString[serializedString.length - 1] === "=") {
            bufferLength--;
            if (serializedString[serializedString.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = new ArrayBuffer(bufferLength);
          var bytes = new Uint8Array(buffer);
          for (i3 = 0; i3 < len; i3 += 4) {
            encoded1 = BASE_CHARS.indexOf(serializedString[i3]);
            encoded2 = BASE_CHARS.indexOf(serializedString[i3 + 1]);
            encoded3 = BASE_CHARS.indexOf(serializedString[i3 + 2]);
            encoded4 = BASE_CHARS.indexOf(serializedString[i3 + 3]);
            bytes[p3++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p3++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p3++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        }
        function bufferToString(buffer) {
          var bytes = new Uint8Array(buffer);
          var base64String = "";
          var i3;
          for (i3 = 0; i3 < bytes.length; i3 += 3) {
            base64String += BASE_CHARS[bytes[i3] >> 2];
            base64String += BASE_CHARS[(bytes[i3] & 3) << 4 | bytes[i3 + 1] >> 4];
            base64String += BASE_CHARS[(bytes[i3 + 1] & 15) << 2 | bytes[i3 + 2] >> 6];
            base64String += BASE_CHARS[bytes[i3 + 2] & 63];
          }
          if (bytes.length % 3 === 2) {
            base64String = base64String.substring(0, base64String.length - 1) + "=";
          } else if (bytes.length % 3 === 1) {
            base64String = base64String.substring(0, base64String.length - 2) + "==";
          }
          return base64String;
        }
        function serialize(value, callback) {
          var valueType = "";
          if (value) {
            valueType = toString$1.call(value);
          }
          if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
            var buffer;
            var marker = SERIALIZED_MARKER;
            if (value instanceof ArrayBuffer) {
              buffer = value;
              marker += TYPE_ARRAYBUFFER;
            } else {
              buffer = value.buffer;
              if (valueType === "[object Int8Array]") {
                marker += TYPE_INT8ARRAY;
              } else if (valueType === "[object Uint8Array]") {
                marker += TYPE_UINT8ARRAY;
              } else if (valueType === "[object Uint8ClampedArray]") {
                marker += TYPE_UINT8CLAMPEDARRAY;
              } else if (valueType === "[object Int16Array]") {
                marker += TYPE_INT16ARRAY;
              } else if (valueType === "[object Uint16Array]") {
                marker += TYPE_UINT16ARRAY;
              } else if (valueType === "[object Int32Array]") {
                marker += TYPE_INT32ARRAY;
              } else if (valueType === "[object Uint32Array]") {
                marker += TYPE_UINT32ARRAY;
              } else if (valueType === "[object Float32Array]") {
                marker += TYPE_FLOAT32ARRAY;
              } else if (valueType === "[object Float64Array]") {
                marker += TYPE_FLOAT64ARRAY;
              } else {
                callback(new Error("Failed to get type for BinaryArray"));
              }
            }
            callback(marker + bufferToString(buffer));
          } else if (valueType === "[object Blob]") {
            var fileReader = new FileReader();
            fileReader.onload = function() {
              var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
              callback(SERIALIZED_MARKER + TYPE_BLOB + str);
            };
            fileReader.readAsArrayBuffer(value);
          } else {
            try {
              callback(JSON.stringify(value));
            } catch (e3) {
              console.error("Couldn't convert value into a JSON string: ", value);
              callback(null, e3);
            }
          }
        }
        function deserialize(value) {
          if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
            return JSON.parse(value);
          }
          var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
          var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
          var blobType;
          if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
            blobType = matcher[1];
            serializedString = serializedString.substring(matcher[0].length);
          }
          var buffer = stringToBuffer(serializedString);
          switch (type) {
            case TYPE_ARRAYBUFFER:
              return buffer;
            case TYPE_BLOB:
              return createBlob([buffer], { type: blobType });
            case TYPE_INT8ARRAY:
              return new Int8Array(buffer);
            case TYPE_UINT8ARRAY:
              return new Uint8Array(buffer);
            case TYPE_UINT8CLAMPEDARRAY:
              return new Uint8ClampedArray(buffer);
            case TYPE_INT16ARRAY:
              return new Int16Array(buffer);
            case TYPE_UINT16ARRAY:
              return new Uint16Array(buffer);
            case TYPE_INT32ARRAY:
              return new Int32Array(buffer);
            case TYPE_UINT32ARRAY:
              return new Uint32Array(buffer);
            case TYPE_FLOAT32ARRAY:
              return new Float32Array(buffer);
            case TYPE_FLOAT64ARRAY:
              return new Float64Array(buffer);
            default:
              throw new Error("Unkown type: " + type);
          }
        }
        var localforageSerializer = {
          serialize,
          deserialize,
          stringToBuffer,
          bufferToString
        };
        function createDbTable(t3, dbInfo, callback, errorCallback) {
          t3.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
        }
        function _initStorage$1(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i3 in options) {
              dbInfo[i3] = typeof options[i3] !== "string" ? options[i3].toString() : options[i3];
            }
          }
          var dbInfoPromise = new Promise$1(function(resolve, reject) {
            try {
              dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
            } catch (e3) {
              return reject(e3);
            }
            dbInfo.db.transaction(function(t3) {
              createDbTable(t3, dbInfo, function() {
                self2._dbInfo = dbInfo;
                resolve();
              }, function(t4, error) {
                reject(error);
              });
            }, reject);
          });
          dbInfo.serializer = localforageSerializer;
          return dbInfoPromise;
        }
        function tryExecuteSql(t3, dbInfo, sqlStatement, args, callback, errorCallback) {
          t3.executeSql(sqlStatement, args, callback, function(t4, error) {
            if (error.code === error.SYNTAX_ERR) {
              t4.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t5, results) {
                if (!results.rows.length) {
                  createDbTable(t5, dbInfo, function() {
                    t5.executeSql(sqlStatement, args, callback, errorCallback);
                  }, errorCallback);
                } else {
                  errorCallback(t5, error);
                }
              }, errorCallback);
            } else {
              errorCallback(t4, error);
            }
          }, errorCallback);
        }
        function getItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t3) {
                tryExecuteSql(t3, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t4, results) {
                  var result = results.rows.length ? results.rows.item(0).value : null;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  resolve(result);
                }, function(t4, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$1(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t3) {
                tryExecuteSql(t3, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t4, results) {
                  var rows = results.rows;
                  var length2 = rows.length;
                  for (var i3 = 0; i3 < length2; i3++) {
                    var item = rows.item(i3);
                    var result = item.value;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    result = iterator(result, item.key, i3 + 1);
                    if (result !== void 0) {
                      resolve(result);
                      return;
                    }
                  }
                  resolve();
                }, function(t4, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function _setItem(key2, value, callback, retriesLeft) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              if (value === void 0) {
                value = null;
              }
              var originalValue = value;
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  dbInfo.db.transaction(function(t3) {
                    tryExecuteSql(t3, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                      resolve(originalValue);
                    }, function(t4, error2) {
                      reject(error2);
                    });
                  }, function(sqlError) {
                    if (sqlError.code === sqlError.QUOTA_ERR) {
                      if (retriesLeft > 0) {
                        resolve(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                        return;
                      }
                      reject(sqlError);
                    }
                  });
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$1(key2, value, callback) {
          return _setItem.apply(this, [key2, value, callback, 1]);
        }
        function removeItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t3) {
                tryExecuteSql(t3, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                  resolve();
                }, function(t4, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t3) {
                tryExecuteSql(t3, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                  resolve();
                }, function(t4, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t3) {
                tryExecuteSql(t3, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t4, results) {
                  var result = results.rows.item(0).c;
                  resolve(result);
                }, function(t4, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$1(n2, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t3) {
                tryExecuteSql(t3, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n2 + 1], function(t4, results) {
                  var result = results.rows.length ? results.rows.item(0).key : null;
                  resolve(result);
                }, function(t4, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t3) {
                tryExecuteSql(t3, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t4, results) {
                  var keys2 = [];
                  for (var i3 = 0; i3 < results.rows.length; i3++) {
                    keys2.push(results.rows.item(i3).key);
                  }
                  resolve(keys2);
                }, function(t4, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getAllStoreNames(db) {
          return new Promise$1(function(resolve, reject) {
            db.transaction(function(t3) {
              t3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t4, results) {
                var storeNames = [];
                for (var i3 = 0; i3 < results.rows.length; i3++) {
                  storeNames.push(results.rows.item(i3).name);
                }
                resolve({
                  db,
                  storeNames
                });
              }, function(t4, error) {
                reject(error);
              });
            }, function(sqlError) {
              reject(sqlError);
            });
          });
        }
        function dropInstance$1(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              var db;
              if (options.name === currentConfig.name) {
                db = self2._dbInfo.db;
              } else {
                db = openDatabase(options.name, "", "", 0);
              }
              if (!options.storeName) {
                resolve(getAllStoreNames(db));
              } else {
                resolve({
                  db,
                  storeNames: [options.storeName]
                });
              }
            }).then(function(operationInfo) {
              return new Promise$1(function(resolve, reject) {
                operationInfo.db.transaction(function(t3) {
                  function dropTable(storeName) {
                    return new Promise$1(function(resolve2, reject2) {
                      t3.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                        resolve2();
                      }, function(t4, error) {
                        reject2(error);
                      });
                    });
                  }
                  var operations = [];
                  for (var i3 = 0, len = operationInfo.storeNames.length; i3 < len; i3++) {
                    operations.push(dropTable(operationInfo.storeNames[i3]));
                  }
                  Promise$1.all(operations).then(function() {
                    resolve();
                  })["catch"](function(e3) {
                    reject(e3);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var webSQLStorage = {
          _driver: "webSQLStorage",
          _initStorage: _initStorage$1,
          _support: isWebSQLValid(),
          iterate: iterate$1,
          getItem: getItem$1,
          setItem: setItem$1,
          removeItem: removeItem$1,
          clear: clear$1,
          length: length$1,
          key: key$1,
          keys: keys$1,
          dropInstance: dropInstance$1
        };
        function isLocalStorageValid() {
          try {
            return typeof localStorage !== "undefined" && "setItem" in localStorage && !!localStorage.setItem;
          } catch (e3) {
            return false;
          }
        }
        function _getKeyPrefix(options, defaultConfig) {
          var keyPrefix = options.name + "/";
          if (options.storeName !== defaultConfig.storeName) {
            keyPrefix += options.storeName + "/";
          }
          return keyPrefix;
        }
        function checkIfLocalStorageThrows() {
          var localStorageTestKey = "_localforage_support_test";
          try {
            localStorage.setItem(localStorageTestKey, true);
            localStorage.removeItem(localStorageTestKey);
            return false;
          } catch (e3) {
            return true;
          }
        }
        function _isLocalStorageUsable() {
          return !checkIfLocalStorageThrows() || localStorage.length > 0;
        }
        function _initStorage$2(options) {
          var self2 = this;
          var dbInfo = {};
          if (options) {
            for (var i3 in options) {
              dbInfo[i3] = options[i3];
            }
          }
          dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
          if (!_isLocalStorageUsable()) {
            return Promise$1.reject();
          }
          self2._dbInfo = dbInfo;
          dbInfo.serializer = localforageSerializer;
          return Promise$1.resolve();
        }
        function clear$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var keyPrefix = self2._dbInfo.keyPrefix;
            for (var i3 = localStorage.length - 1; i3 >= 0; i3--) {
              var key2 = localStorage.key(i3);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result = localStorage.getItem(dbInfo.keyPrefix + key2);
            if (result) {
              result = dbInfo.serializer.deserialize(result);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$2(iterator, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var keyPrefix = dbInfo.keyPrefix;
            var keyPrefixLength = keyPrefix.length;
            var length2 = localStorage.length;
            var iterationNumber = 1;
            for (var i3 = 0; i3 < length2; i3++) {
              var key2 = localStorage.key(i3);
              if (key2.indexOf(keyPrefix) !== 0) {
                continue;
              }
              var value = localStorage.getItem(key2);
              if (value) {
                value = dbInfo.serializer.deserialize(value);
              }
              value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
              if (value !== void 0) {
                return value;
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$2(n2, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result;
            try {
              result = localStorage.key(n2);
            } catch (error) {
              result = null;
            }
            if (result) {
              result = result.substring(dbInfo.keyPrefix.length);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var length2 = localStorage.length;
            var keys2 = [];
            for (var i3 = 0; i3 < length2; i3++) {
              var itemKey = localStorage.key(i3);
              if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
              }
            }
            return keys2;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$2(callback) {
          var self2 = this;
          var promise = self2.keys().then(function(keys2) {
            return keys2.length;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            localStorage.removeItem(dbInfo.keyPrefix + key2);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$2(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            return new Promise$1(function(resolve, reject) {
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  try {
                    localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                    resolve(originalValue);
                  } catch (e3) {
                    if (e3.name === "QuotaExceededError" || e3.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                      reject(e3);
                    }
                    reject(e3);
                  }
                }
              });
            });
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance$2(options, callback) {
          callback = getCallback.apply(this, arguments);
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            var currentConfig = this.config();
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              if (!options.storeName) {
                resolve(options.name + "/");
              } else {
                resolve(_getKeyPrefix(options, self2._defaultConfig));
              }
            }).then(function(keyPrefix) {
              for (var i3 = localStorage.length - 1; i3 >= 0; i3--) {
                var key2 = localStorage.key(i3);
                if (key2.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key2);
                }
              }
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var localStorageWrapper = {
          _driver: "localStorageWrapper",
          _initStorage: _initStorage$2,
          _support: isLocalStorageValid(),
          iterate: iterate$2,
          getItem: getItem$2,
          setItem: setItem$2,
          removeItem: removeItem$2,
          clear: clear$2,
          length: length$2,
          key: key$2,
          keys: keys$2,
          dropInstance: dropInstance$2
        };
        var sameValue = function sameValue2(x4, y3) {
          return x4 === y3 || typeof x4 === "number" && typeof y3 === "number" && isNaN(x4) && isNaN(y3);
        };
        var includes = function includes2(array, searchElement) {
          var len = array.length;
          var i3 = 0;
          while (i3 < len) {
            if (sameValue(array[i3], searchElement)) {
              return true;
            }
            i3++;
          }
          return false;
        };
        var isArray = Array.isArray || function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
        var DefinedDrivers = {};
        var DriverSupport = {};
        var DefaultDrivers = {
          INDEXEDDB: asyncStorage,
          WEBSQL: webSQLStorage,
          LOCALSTORAGE: localStorageWrapper
        };
        var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
        var OptionalDriverMethods = ["dropInstance"];
        var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
        var DefaultConfig = {
          description: "",
          driver: DefaultDriverOrder.slice(),
          name: "localforage",
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function callWhenReady(localForageInstance, libraryMethod) {
          localForageInstance[libraryMethod] = function() {
            var _args = arguments;
            return localForageInstance.ready().then(function() {
              return localForageInstance[libraryMethod].apply(localForageInstance, _args);
            });
          };
        }
        function extend() {
          for (var i3 = 1; i3 < arguments.length; i3++) {
            var arg = arguments[i3];
            if (arg) {
              for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                  if (isArray(arg[_key])) {
                    arguments[0][_key] = arg[_key].slice();
                  } else {
                    arguments[0][_key] = arg[_key];
                  }
                }
              }
            }
          }
          return arguments[0];
        }
        var LocalForage = function() {
          function LocalForage2(options) {
            _classCallCheck(this, LocalForage2);
            for (var driverTypeKey in DefaultDrivers) {
              if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;
                if (!DefinedDrivers[driverName]) {
                  this.defineDriver(driver);
                }
              }
            }
            this._defaultConfig = extend({}, DefaultConfig);
            this._config = extend({}, this._defaultConfig, options);
            this._driverSet = null;
            this._initDriver = null;
            this._ready = false;
            this._dbInfo = null;
            this._wrapLibraryMethodsWithReady();
            this.setDriver(this._config.driver)["catch"](function() {
            });
          }
          LocalForage2.prototype.config = function config(options) {
            if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
              if (this._ready) {
                return new Error("Can't call config() after localforage has been used.");
              }
              for (var i3 in options) {
                if (i3 === "storeName") {
                  options[i3] = options[i3].replace(/\W/g, "_");
                }
                if (i3 === "version" && typeof options[i3] !== "number") {
                  return new Error("Database version must be a number.");
                }
                this._config[i3] = options[i3];
              }
              if ("driver" in options && options.driver) {
                return this.setDriver(this._config.driver);
              }
              return true;
            } else if (typeof options === "string") {
              return this._config[options];
            } else {
              return this._config;
            }
          };
          LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
            var promise = new Promise$1(function(resolve, reject) {
              try {
                var driverName = driverObject._driver;
                var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!driverObject._driver) {
                  reject(complianceError);
                  return;
                }
                var driverMethods = LibraryMethods.concat("_initStorage");
                for (var i3 = 0, len = driverMethods.length; i3 < len; i3++) {
                  var driverMethodName = driverMethods[i3];
                  var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                  if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                    reject(complianceError);
                    return;
                  }
                }
                var configureMissingMethods = function configureMissingMethods2() {
                  var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                    return function() {
                      var error = new Error("Method " + methodName + " is not implemented by the current driver");
                      var promise2 = Promise$1.reject(error);
                      executeCallback(promise2, arguments[arguments.length - 1]);
                      return promise2;
                    };
                  };
                  for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                    var optionalDriverMethod = OptionalDriverMethods[_i];
                    if (!driverObject[optionalDriverMethod]) {
                      driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                    }
                  }
                };
                configureMissingMethods();
                var setDriverSupport = function setDriverSupport2(support) {
                  if (DefinedDrivers[driverName]) {
                    console.info("Redefining LocalForage driver: " + driverName);
                  }
                  DefinedDrivers[driverName] = driverObject;
                  DriverSupport[driverName] = support;
                  resolve();
                };
                if ("_support" in driverObject) {
                  if (driverObject._support && typeof driverObject._support === "function") {
                    driverObject._support().then(setDriverSupport, reject);
                  } else {
                    setDriverSupport(!!driverObject._support);
                  }
                } else {
                  setDriverSupport(true);
                }
              } catch (e3) {
                reject(e3);
              }
            });
            executeTwoCallbacks(promise, callback, errorCallback);
            return promise;
          };
          LocalForage2.prototype.driver = function driver() {
            return this._driver || null;
          };
          LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
            var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
            executeTwoCallbacks(getDriverPromise, callback, errorCallback);
            return getDriverPromise;
          };
          LocalForage2.prototype.getSerializer = function getSerializer(callback) {
            var serializerPromise = Promise$1.resolve(localforageSerializer);
            executeTwoCallbacks(serializerPromise, callback);
            return serializerPromise;
          };
          LocalForage2.prototype.ready = function ready(callback) {
            var self2 = this;
            var promise = self2._driverSet.then(function() {
              if (self2._ready === null) {
                self2._ready = self2._initDriver();
              }
              return self2._ready;
            });
            executeTwoCallbacks(promise, callback, callback);
            return promise;
          };
          LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
            var self2 = this;
            if (!isArray(drivers)) {
              drivers = [drivers];
            }
            var supportedDrivers = this._getSupportedDrivers(drivers);
            function setDriverToConfig() {
              self2._config.driver = self2.driver();
            }
            function extendSelfWithDriver(driver) {
              self2._extend(driver);
              setDriverToConfig();
              self2._ready = self2._initStorage(self2._config);
              return self2._ready;
            }
            function initDriver(supportedDrivers2) {
              return function() {
                var currentDriverIndex = 0;
                function driverPromiseLoop() {
                  while (currentDriverIndex < supportedDrivers2.length) {
                    var driverName = supportedDrivers2[currentDriverIndex];
                    currentDriverIndex++;
                    self2._dbInfo = null;
                    self2._ready = null;
                    return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                  }
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$1.reject(error);
                  return self2._driverSet;
                }
                return driverPromiseLoop();
              };
            }
            var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
              return Promise$1.resolve();
            }) : Promise$1.resolve();
            this._driverSet = oldDriverSetDone.then(function() {
              var driverName = supportedDrivers[0];
              self2._dbInfo = null;
              self2._ready = null;
              return self2.getDriver(driverName).then(function(driver) {
                self2._driver = driver._driver;
                setDriverToConfig();
                self2._wrapLibraryMethodsWithReady();
                self2._initDriver = initDriver(supportedDrivers);
              });
            })["catch"](function() {
              setDriverToConfig();
              var error = new Error("No available storage method found.");
              self2._driverSet = Promise$1.reject(error);
              return self2._driverSet;
            });
            executeTwoCallbacks(this._driverSet, callback, errorCallback);
            return this._driverSet;
          };
          LocalForage2.prototype.supports = function supports(driverName) {
            return !!DriverSupport[driverName];
          };
          LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
            extend(this, libraryMethodsAndProperties);
          };
          LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
            var supportedDrivers = [];
            for (var i3 = 0, len = drivers.length; i3 < len; i3++) {
              var driverName = drivers[i3];
              if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
              }
            }
            return supportedDrivers;
          };
          LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
            for (var i3 = 0, len = LibraryMethods.length; i3 < len; i3++) {
              callWhenReady(this, LibraryMethods[i3]);
            }
          };
          LocalForage2.prototype.createInstance = function createInstance(options) {
            return new LocalForage2(options);
          };
          return LocalForage2;
        }();
        var localforage_js = new LocalForage();
        module4.exports = localforage_js;
      }, { "3": 3 }] }, {}, [4])(4);
    });
  }
});

// node_modules/epubjs/lib/store.js
var require_store = __commonJS({
  "node_modules/epubjs/lib/store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _request = _interopRequireDefault(require_request());
    var _mime = _interopRequireDefault(require_mime());
    var _path = _interopRequireDefault(require_path2());
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _localforage = _interopRequireDefault(require_localforage());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Store = class {
      constructor(name, requester, resolver) {
        this.urlCache = {};
        this.storage = void 0;
        this.name = name;
        this.requester = requester || _request.default;
        this.resolver = resolver;
        this.online = true;
        this.checkRequirements();
        this.addListeners();
      }
      checkRequirements() {
        try {
          let store;
          if (typeof _localforage.default === "undefined") {
            store = _localforage.default;
          }
          this.storage = store.createInstance({
            name: this.name
          });
        } catch (e3) {
          throw new Error("localForage lib not loaded");
        }
      }
      addListeners() {
        this._status = this.status.bind(this);
        window.addEventListener("online", this._status);
        window.addEventListener("offline", this._status);
      }
      removeListeners() {
        window.removeEventListener("online", this._status);
        window.removeEventListener("offline", this._status);
        this._status = void 0;
      }
      status(event) {
        let online = navigator.onLine;
        this.online = online;
        if (online) {
          this.emit("online", this);
        } else {
          this.emit("offline", this);
        }
      }
      add(resources, force) {
        let mapped = resources.resources.map((item) => {
          let {
            href
          } = item;
          let url = this.resolver(href);
          let encodedUrl = window.encodeURIComponent(url);
          return this.storage.getItem(encodedUrl).then((item2) => {
            if (!item2 || force) {
              return this.requester(url, "binary").then((data) => {
                return this.storage.setItem(encodedUrl, data);
              });
            } else {
              return item2;
            }
          });
        });
        return Promise.all(mapped);
      }
      put(url, withCredentials, headers) {
        let encodedUrl = window.encodeURIComponent(url);
        return this.storage.getItem(encodedUrl).then((result) => {
          if (!result) {
            return this.requester(url, "binary", withCredentials, headers).then((data) => {
              return this.storage.setItem(encodedUrl, data);
            });
          }
          return result;
        });
      }
      request(url, type, withCredentials, headers) {
        if (this.online) {
          return this.requester(url, type, withCredentials, headers).then((data) => {
            this.put(url);
            return data;
          });
        } else {
          return this.retrieve(url, type);
        }
      }
      retrieve(url, type) {
        var deferred = new _core.defer();
        var response;
        var path = new _path.default(url);
        if (!type) {
          type = path.extension;
        }
        if (type == "blob") {
          response = this.getBlob(url);
        } else {
          response = this.getText(url);
        }
        return response.then((r3) => {
          var deferred2 = new _core.defer();
          var result;
          if (r3) {
            result = this.handleResponse(r3, type);
            deferred2.resolve(result);
          } else {
            deferred2.reject({
              message: "File not found in storage: " + url,
              stack: new Error().stack
            });
          }
          return deferred2.promise;
        });
      }
      handleResponse(response, type) {
        var r3;
        if (type == "json") {
          r3 = JSON.parse(response);
        } else if ((0, _core.isXml)(type)) {
          r3 = (0, _core.parse)(response, "text/xml");
        } else if (type == "xhtml") {
          r3 = (0, _core.parse)(response, "application/xhtml+xml");
        } else if (type == "html" || type == "htm") {
          r3 = (0, _core.parse)(response, "text/html");
        } else {
          r3 = response;
        }
        return r3;
      }
      getBlob(url, mimeType) {
        let encodedUrl = window.encodeURIComponent(url);
        return this.storage.getItem(encodedUrl).then(function(uint8array) {
          if (!uint8array)
            return;
          mimeType = mimeType || _mime.default.lookup(url);
          return new Blob([uint8array], {
            type: mimeType
          });
        });
      }
      getText(url, mimeType) {
        let encodedUrl = window.encodeURIComponent(url);
        mimeType = mimeType || _mime.default.lookup(url);
        return this.storage.getItem(encodedUrl).then(function(uint8array) {
          var deferred = new _core.defer();
          var reader = new FileReader();
          var blob;
          if (!uint8array)
            return;
          blob = new Blob([uint8array], {
            type: mimeType
          });
          reader.addEventListener("loadend", () => {
            deferred.resolve(reader.result);
          });
          reader.readAsText(blob, mimeType);
          return deferred.promise;
        });
      }
      getBase64(url, mimeType) {
        let encodedUrl = window.encodeURIComponent(url);
        mimeType = mimeType || _mime.default.lookup(url);
        return this.storage.getItem(encodedUrl).then((uint8array) => {
          var deferred = new _core.defer();
          var reader = new FileReader();
          var blob;
          if (!uint8array)
            return;
          blob = new Blob([uint8array], {
            type: mimeType
          });
          reader.addEventListener("loadend", () => {
            deferred.resolve(reader.result);
          });
          reader.readAsDataURL(blob, mimeType);
          return deferred.promise;
        });
      }
      createUrl(url, options) {
        var deferred = new _core.defer();
        var _URL = window.URL || window.webkitURL || window.mozURL;
        var tempUrl;
        var response;
        var useBase64 = options && options.base64;
        if (url in this.urlCache) {
          deferred.resolve(this.urlCache[url]);
          return deferred.promise;
        }
        if (useBase64) {
          response = this.getBase64(url);
          if (response) {
            response.then(function(tempUrl2) {
              this.urlCache[url] = tempUrl2;
              deferred.resolve(tempUrl2);
            }.bind(this));
          }
        } else {
          response = this.getBlob(url);
          if (response) {
            response.then(function(blob) {
              tempUrl = _URL.createObjectURL(blob);
              this.urlCache[url] = tempUrl;
              deferred.resolve(tempUrl);
            }.bind(this));
          }
        }
        if (!response) {
          deferred.reject({
            message: "File not found in storage: " + url,
            stack: new Error().stack
          });
        }
        return deferred.promise;
      }
      revokeUrl(url) {
        var _URL = window.URL || window.webkitURL || window.mozURL;
        var fromCache = this.urlCache[url];
        if (fromCache)
          _URL.revokeObjectURL(fromCache);
      }
      destroy() {
        var _URL = window.URL || window.webkitURL || window.mozURL;
        for (let fromCache in this.urlCache) {
          _URL.revokeObjectURL(fromCache);
        }
        this.urlCache = {};
        this.removeListeners();
      }
    };
    (0, _eventEmitter.default)(Store.prototype);
    var _default = Store;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/displayoptions.js
var require_displayoptions = __commonJS({
  "node_modules/epubjs/lib/displayoptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var DisplayOptions = class {
      constructor(displayOptionsDocument) {
        this.interactive = "";
        this.fixedLayout = "";
        this.openToSpread = "";
        this.orientationLock = "";
        if (displayOptionsDocument) {
          this.parse(displayOptionsDocument);
        }
      }
      parse(displayOptionsDocument) {
        if (!displayOptionsDocument) {
          return this;
        }
        const displayOptionsNode = (0, _core.qs)(displayOptionsDocument, "display_options");
        if (!displayOptionsNode) {
          return this;
        }
        const options = (0, _core.qsa)(displayOptionsNode, "option");
        options.forEach((el) => {
          let value = "";
          if (el.childNodes.length) {
            value = el.childNodes[0].nodeValue;
          }
          switch (el.attributes.name.value) {
            case "interactive":
              this.interactive = value;
              break;
            case "fixed-layout":
              this.fixedLayout = value;
              break;
            case "open-to-spread":
              this.openToSpread = value;
              break;
            case "orientation-lock":
              this.orientationLock = value;
              break;
          }
        });
        return this;
      }
      destroy() {
        this.interactive = void 0;
        this.fixedLayout = void 0;
        this.openToSpread = void 0;
        this.orientationLock = void 0;
      }
    };
    var _default = DisplayOptions;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/book.js
var require_book = __commonJS({
  "node_modules/epubjs/lib/book.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _core = require_core();
    var _url = _interopRequireDefault(require_url());
    var _path = _interopRequireDefault(require_path2());
    var _spine = _interopRequireDefault(require_spine());
    var _locations = _interopRequireDefault(require_locations());
    var _container = _interopRequireDefault(require_container());
    var _packaging = _interopRequireDefault(require_packaging());
    var _navigation = _interopRequireDefault(require_navigation());
    var _resources = _interopRequireDefault(require_resources());
    var _pagelist = _interopRequireDefault(require_pagelist());
    var _rendition = _interopRequireDefault(require_rendition());
    var _archive = _interopRequireDefault(require_archive());
    var _request2 = _interopRequireDefault(require_request());
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _store = _interopRequireDefault(require_store());
    var _displayoptions = _interopRequireDefault(require_displayoptions());
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var CONTAINER_PATH = "META-INF/container.xml";
    var IBOOKS_DISPLAY_OPTIONS_PATH = "META-INF/com.apple.ibooks.display-options.xml";
    var INPUT_TYPE = {
      BINARY: "binary",
      BASE64: "base64",
      EPUB: "epub",
      OPF: "opf",
      MANIFEST: "json",
      DIRECTORY: "directory"
    };
    var Book = class {
      constructor(url, options) {
        if (typeof options === "undefined" && typeof url !== "string" && url instanceof Blob === false && url instanceof ArrayBuffer === false) {
          options = url;
          url = void 0;
        }
        this.settings = (0, _core.extend)(this.settings || {}, {
          requestMethod: void 0,
          requestCredentials: void 0,
          requestHeaders: void 0,
          encoding: void 0,
          replacements: void 0,
          canonical: void 0,
          openAs: void 0,
          store: void 0
        });
        (0, _core.extend)(this.settings, options);
        this.opening = new _core.defer();
        this.opened = this.opening.promise;
        this.isOpen = false;
        this.loading = {
          manifest: new _core.defer(),
          spine: new _core.defer(),
          metadata: new _core.defer(),
          cover: new _core.defer(),
          navigation: new _core.defer(),
          pageList: new _core.defer(),
          resources: new _core.defer(),
          displayOptions: new _core.defer()
        };
        this.loaded = {
          manifest: this.loading.manifest.promise,
          spine: this.loading.spine.promise,
          metadata: this.loading.metadata.promise,
          cover: this.loading.cover.promise,
          navigation: this.loading.navigation.promise,
          pageList: this.loading.pageList.promise,
          resources: this.loading.resources.promise,
          displayOptions: this.loading.displayOptions.promise
        };
        this.ready = Promise.all([this.loaded.manifest, this.loaded.spine, this.loaded.metadata, this.loaded.cover, this.loaded.navigation, this.loaded.resources, this.loaded.displayOptions]);
        this.isRendered = false;
        this.request = this.settings.requestMethod || _request2.default;
        this.spine = new _spine.default();
        this.locations = new _locations.default(this.spine, this.load.bind(this));
        this.navigation = void 0;
        this.pageList = void 0;
        this.url = void 0;
        this.path = void 0;
        this.archived = false;
        this.archive = void 0;
        this.storage = void 0;
        this.resources = void 0;
        this.rendition = void 0;
        this.container = void 0;
        this.packaging = void 0;
        this.displayOptions = void 0;
        if (this.settings.store) {
          this.store(this.settings.store);
        }
        if (url) {
          this.open(url, this.settings.openAs).catch((error) => {
            var err = new Error("Cannot load book at " + url);
            this.emit(_constants.EVENTS.BOOK.OPEN_FAILED, err);
          });
        }
      }
      open(input, what) {
        var opening;
        var type = what || this.determineType(input);
        if (type === INPUT_TYPE.BINARY) {
          this.archived = true;
          this.url = new _url.default("/", "");
          opening = this.openEpub(input);
        } else if (type === INPUT_TYPE.BASE64) {
          this.archived = true;
          this.url = new _url.default("/", "");
          opening = this.openEpub(input, type);
        } else if (type === INPUT_TYPE.EPUB) {
          this.archived = true;
          this.url = new _url.default("/", "");
          opening = this.request(input, "binary", this.settings.requestCredentials, this.settings.requestHeaders).then(this.openEpub.bind(this));
        } else if (type == INPUT_TYPE.OPF) {
          this.url = new _url.default(input);
          opening = this.openPackaging(this.url.Path.toString());
        } else if (type == INPUT_TYPE.MANIFEST) {
          this.url = new _url.default(input);
          opening = this.openManifest(this.url.Path.toString());
        } else {
          this.url = new _url.default(input);
          opening = this.openContainer(CONTAINER_PATH).then(this.openPackaging.bind(this));
        }
        return opening;
      }
      openEpub(data, encoding) {
        return this.unarchive(data, encoding || this.settings.encoding).then(() => {
          return this.openContainer(CONTAINER_PATH);
        }).then((packagePath) => {
          return this.openPackaging(packagePath);
        });
      }
      openContainer(url) {
        return this.load(url).then((xml) => {
          this.container = new _container.default(xml);
          return this.resolve(this.container.packagePath);
        });
      }
      openPackaging(url) {
        this.path = new _path.default(url);
        return this.load(url).then((xml) => {
          this.packaging = new _packaging.default(xml);
          return this.unpack(this.packaging);
        });
      }
      openManifest(url) {
        this.path = new _path.default(url);
        return this.load(url).then((json) => {
          this.packaging = new _packaging.default();
          this.packaging.load(json);
          return this.unpack(this.packaging);
        });
      }
      load(path) {
        var resolved = this.resolve(path);
        if (this.archived) {
          return this.archive.request(resolved);
        } else {
          return this.request(resolved, null, this.settings.requestCredentials, this.settings.requestHeaders);
        }
      }
      resolve(path, absolute) {
        if (!path) {
          return;
        }
        var resolved = path;
        var isAbsolute = path.indexOf("://") > -1;
        if (isAbsolute) {
          return path;
        }
        if (this.path) {
          resolved = this.path.resolve(path);
        }
        if (absolute != false && this.url) {
          resolved = this.url.resolve(resolved);
        }
        return resolved;
      }
      canonical(path) {
        var url = path;
        if (!path) {
          return "";
        }
        if (this.settings.canonical) {
          url = this.settings.canonical(path);
        } else {
          url = this.resolve(path, true);
        }
        return url;
      }
      determineType(input) {
        var url;
        var path;
        var extension;
        if (this.settings.encoding === "base64") {
          return INPUT_TYPE.BASE64;
        }
        if (typeof input != "string") {
          return INPUT_TYPE.BINARY;
        }
        url = new _url.default(input);
        path = url.path();
        extension = path.extension;
        if (extension) {
          extension = extension.replace(/\?.*$/, "");
        }
        if (!extension) {
          return INPUT_TYPE.DIRECTORY;
        }
        if (extension === "epub") {
          return INPUT_TYPE.EPUB;
        }
        if (extension === "opf") {
          return INPUT_TYPE.OPF;
        }
        if (extension === "json") {
          return INPUT_TYPE.MANIFEST;
        }
      }
      unpack(packaging) {
        this.package = packaging;
        if (this.packaging.metadata.layout === "") {
          this.load(this.url.resolve(IBOOKS_DISPLAY_OPTIONS_PATH)).then((xml) => {
            this.displayOptions = new _displayoptions.default(xml);
            this.loading.displayOptions.resolve(this.displayOptions);
          }).catch((err) => {
            this.displayOptions = new _displayoptions.default();
            this.loading.displayOptions.resolve(this.displayOptions);
          });
        } else {
          this.displayOptions = new _displayoptions.default();
          this.loading.displayOptions.resolve(this.displayOptions);
        }
        this.spine.unpack(this.packaging, this.resolve.bind(this), this.canonical.bind(this));
        this.resources = new _resources.default(this.packaging.manifest, {
          archive: this.archive,
          resolver: this.resolve.bind(this),
          request: this.request.bind(this),
          replacements: this.settings.replacements || (this.archived ? "blobUrl" : "base64")
        });
        this.loadNavigation(this.packaging).then(() => {
          this.loading.navigation.resolve(this.navigation);
        });
        if (this.packaging.coverPath) {
          this.cover = this.resolve(this.packaging.coverPath);
        }
        this.loading.manifest.resolve(this.packaging.manifest);
        this.loading.metadata.resolve(this.packaging.metadata);
        this.loading.spine.resolve(this.spine);
        this.loading.cover.resolve(this.cover);
        this.loading.resources.resolve(this.resources);
        this.loading.pageList.resolve(this.pageList);
        this.isOpen = true;
        if (this.archived || this.settings.replacements && this.settings.replacements != "none") {
          this.replacements().then(() => {
            this.loaded.displayOptions.then(() => {
              this.opening.resolve(this);
            });
          }).catch((err) => {
            console.error(err);
          });
        } else {
          this.loaded.displayOptions.then(() => {
            this.opening.resolve(this);
          });
        }
      }
      loadNavigation(packaging) {
        let navPath = packaging.navPath || packaging.ncxPath;
        let toc = packaging.toc;
        if (toc) {
          return new Promise((resolve, reject) => {
            this.navigation = new _navigation.default(toc);
            if (packaging.pageList) {
              this.pageList = new _pagelist.default(packaging.pageList);
            }
            resolve(this.navigation);
          });
        }
        if (!navPath) {
          return new Promise((resolve, reject) => {
            this.navigation = new _navigation.default();
            this.pageList = new _pagelist.default();
            resolve(this.navigation);
          });
        }
        return this.load(navPath, "xml").then((xml) => {
          this.navigation = new _navigation.default(xml);
          this.pageList = new _pagelist.default(xml);
          return this.navigation;
        });
      }
      section(target) {
        return this.spine.get(target);
      }
      renderTo(element, options) {
        this.rendition = new _rendition.default(this, options);
        this.rendition.attachTo(element);
        return this.rendition;
      }
      setRequestCredentials(credentials) {
        this.settings.requestCredentials = credentials;
      }
      setRequestHeaders(headers) {
        this.settings.requestHeaders = headers;
      }
      unarchive(input, encoding) {
        this.archive = new _archive.default();
        return this.archive.open(input, encoding);
      }
      store(name) {
        let replacementsSetting = this.settings.replacements && this.settings.replacements !== "none";
        let originalUrl = this.url;
        let requester = this.settings.requestMethod || _request2.default.bind(this);
        this.storage = new _store.default(name, requester, this.resolve.bind(this));
        this.request = this.storage.request.bind(this.storage);
        this.opened.then(() => {
          if (this.archived) {
            this.storage.requester = this.archive.request.bind(this.archive);
          }
          let substituteResources = (output, section) => {
            section.output = this.resources.substitute(output, section.url);
          };
          this.resources.settings.replacements = replacementsSetting || "blobUrl";
          this.resources.replacements().then(() => {
            return this.resources.replaceCss();
          });
          this.storage.on("offline", () => {
            this.url = new _url.default("/", "");
            this.spine.hooks.serialize.register(substituteResources);
          });
          this.storage.on("online", () => {
            this.url = originalUrl;
            this.spine.hooks.serialize.deregister(substituteResources);
          });
        });
        return this.storage;
      }
      coverUrl() {
        return this.loaded.cover.then(() => {
          if (!this.cover) {
            return null;
          }
          if (this.archived) {
            return this.archive.createUrl(this.cover);
          } else {
            return this.cover;
          }
        });
      }
      replacements() {
        this.spine.hooks.serialize.register((output, section) => {
          section.output = this.resources.substitute(output, section.url);
        });
        return this.resources.replacements().then(() => {
          return this.resources.replaceCss();
        });
      }
      getRange(cfiRange) {
        var cfi = new _epubcfi.default(cfiRange);
        var item = this.spine.get(cfi.spinePos);
        var _request = this.load.bind(this);
        if (!item) {
          return new Promise((resolve, reject) => {
            reject("CFI could not be found");
          });
        }
        return item.load(_request).then(function(contents) {
          var range = cfi.toRange(item.document);
          return range;
        });
      }
      key(identifier) {
        var ident = identifier || this.packaging.metadata.identifier || this.url.filename;
        return `epubjs:${_constants.EPUBJS_VERSION}:${ident}`;
      }
      destroy() {
        this.opened = void 0;
        this.loading = void 0;
        this.loaded = void 0;
        this.ready = void 0;
        this.isOpen = false;
        this.isRendered = false;
        this.spine && this.spine.destroy();
        this.locations && this.locations.destroy();
        this.pageList && this.pageList.destroy();
        this.archive && this.archive.destroy();
        this.resources && this.resources.destroy();
        this.container && this.container.destroy();
        this.packaging && this.packaging.destroy();
        this.rendition && this.rendition.destroy();
        this.displayOptions && this.displayOptions.destroy();
        this.spine = void 0;
        this.locations = void 0;
        this.pageList = void 0;
        this.archive = void 0;
        this.resources = void 0;
        this.container = void 0;
        this.packaging = void 0;
        this.rendition = void 0;
        this.navigation = void 0;
        this.url = void 0;
        this.path = void 0;
        this.archived = false;
      }
    };
    (0, _eventEmitter.default)(Book.prototype);
    var _default = Book;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/epub.js
var require_epub = __commonJS({
  "node_modules/epubjs/lib/epub.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _book = _interopRequireDefault(require_book());
    var _rendition = _interopRequireDefault(require_rendition());
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _contents = _interopRequireDefault(require_contents());
    var utils = _interopRequireWildcard(require_core());
    var _constants = require_constants();
    var _iframe = _interopRequireDefault(require_iframe());
    var _default2 = _interopRequireDefault(require_default());
    var _continuous = _interopRequireDefault(require_continuous());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ePub(url, options) {
      return new _book.default(url, options);
    }
    ePub.VERSION = _constants.EPUBJS_VERSION;
    if (typeof global !== "undefined") {
      global.EPUBJS_VERSION = _constants.EPUBJS_VERSION;
    }
    ePub.Book = _book.default;
    ePub.Rendition = _rendition.default;
    ePub.Contents = _contents.default;
    ePub.CFI = _epubcfi.default;
    ePub.utils = utils;
    var _default = ePub;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/epubjs/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Book", {
      enumerable: true,
      get: function() {
        return _book.default;
      }
    });
    Object.defineProperty(exports, "Contents", {
      enumerable: true,
      get: function() {
        return _contents.default;
      }
    });
    Object.defineProperty(exports, "EpubCFI", {
      enumerable: true,
      get: function() {
        return _epubcfi.default;
      }
    });
    Object.defineProperty(exports, "Layout", {
      enumerable: true,
      get: function() {
        return _layout.default;
      }
    });
    Object.defineProperty(exports, "Rendition", {
      enumerable: true,
      get: function() {
        return _rendition.default;
      }
    });
    exports.default = void 0;
    var _book = _interopRequireDefault(require_book());
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _rendition = _interopRequireDefault(require_rendition());
    var _contents = _interopRequireDefault(require_contents());
    var _layout = _interopRequireDefault(require_layout());
    var _epub = _interopRequireDefault(require_epub());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _default = _epub.default;
    exports.default = _default;
  }
});

// node_modules/react-reader/lib/EpubView/style.js
var require_style = __commonJS({
  "node_modules/react-reader/lib/EpubView/style.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var epubViewStyles = {
      viewHolder: {
        position: "relative",
        height: "100%",
        width: "100%"
      },
      view: {
        height: "100%"
      }
    };
    var _default = epubViewStyles;
    exports.default = _default;
  }
});

// node_modules/react-reader/lib/EpubView/EpubView.js
var require_EpubView = __commonJS({
  "node_modules/react-reader/lib/EpubView/EpubView.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _index = _interopRequireDefault(require_lib2());
    var _style = _interopRequireDefault(require_style());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = arguments[i3] != null ? arguments[i3] : {};
        i3 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o3, p3) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o4, p4) {
        o4.__proto__ = p4;
        return o4;
      };
      return _setPrototypeOf(o3, p3);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e3) {
        return false;
      }
    }
    function _getPrototypeOf(o3) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
        return o4.__proto__ || Object.getPrototypeOf(o4);
      };
      return _getPrototypeOf(o3);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var EpubView2 = /* @__PURE__ */ function(_Component) {
      _inherits(EpubView3, _Component);
      var _super = _createSuper(EpubView3);
      function EpubView3(props) {
        var _this;
        _classCallCheck(this, EpubView3);
        _this = _super.call(this, props);
        _defineProperty(_assertThisInitialized(_this), "onLocationChange", function(loc) {
          var _this$props = _this.props, location = _this$props.location, locationChanged = _this$props.locationChanged;
          var newLocation = loc && loc.start;
          if (location !== newLocation) {
            _this.location = newLocation;
            locationChanged && locationChanged(newLocation);
          }
        });
        _defineProperty(_assertThisInitialized(_this), "handleKeyPress", function(_ref) {
          var key = _ref.key;
          key && key === "ArrowRight" && _this.nextPage();
          key && key === "ArrowLeft" && _this.prevPage();
        });
        _this.state = {
          isLoaded: false,
          toc: []
        };
        _this.viewerRef = /* @__PURE__ */ _react.default.createRef();
        _this.location = props.location;
        _this.book = _this.rendition = _this.prevPage = _this.nextPage = null;
        return _this;
      }
      _createClass(EpubView3, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.initBook(true);
          document.addEventListener("keyup", this.handleKeyPress, false);
        }
      }, {
        key: "initBook",
        value: function initBook() {
          var _this2 = this;
          var _this$props2 = this.props, url = _this$props2.url, tocChanged = _this$props2.tocChanged, epubInitOptions = _this$props2.epubInitOptions;
          if (this.book) {
            this.book.destroy();
          }
          this.book = new _index.default(url, epubInitOptions);
          this.book.loaded.navigation.then(function(_ref2) {
            var toc = _ref2.toc;
            _this2.setState({
              isLoaded: true,
              toc
            }, function() {
              tocChanged && tocChanged(toc);
              _this2.initReader();
            });
          });
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.book = this.rendition = this.prevPage = this.nextPage = null;
          document.removeEventListener("keyup", this.handleKeyPress, false);
        }
      }, {
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps) {
          return !this.state.isLoaded || nextProps.location !== this.props.location || nextProps.location !== this.props.location;
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (prevProps.location !== this.props.location && this.location !== this.props.location) {
            this.rendition.display(this.props.location);
          }
          if (prevProps.url !== this.props.url) {
            this.initBook();
          }
        }
      }, {
        key: "initReader",
        value: function initReader() {
          var _this3 = this;
          var toc = this.state.toc;
          var _this$props3 = this.props, location = _this$props3.location, epubOptions = _this$props3.epubOptions, getRendition = _this$props3.getRendition;
          var node = this.viewerRef.current;
          this.rendition = this.book.renderTo(node, _objectSpread({
            contained: true,
            width: "100%",
            height: "100%"
          }, epubOptions));
          this.prevPage = function() {
            _this3.rendition.prev();
          };
          this.nextPage = function() {
            _this3.rendition.next();
          };
          this.registerEvents();
          getRendition && getRendition(this.rendition);
          if (typeof location === "string" || typeof location === "number") {
            this.rendition.display(location);
          } else if (toc.length > 0 && toc[0].href) {
            this.rendition.display(toc[0].href);
          } else {
            this.rendition.display();
          }
        }
      }, {
        key: "registerEvents",
        value: function registerEvents() {
          var _this$props4 = this.props, handleKeyPress = _this$props4.handleKeyPress, handleTextSelected = _this$props4.handleTextSelected;
          this.rendition.on("locationChanged", this.onLocationChange);
          this.rendition.on("keyup", handleKeyPress || this.handleKeyPress);
          if (handleTextSelected) {
            this.rendition.on("selected", handleTextSelected);
          }
        }
      }, {
        key: "renderBook",
        value: function renderBook() {
          var styles = this.props.styles;
          return /* @__PURE__ */ _react.default.createElement("div", {
            ref: this.viewerRef,
            style: styles.view
          });
        }
      }, {
        key: "render",
        value: function render() {
          var isLoaded = this.state.isLoaded;
          var _this$props5 = this.props, loadingView = _this$props5.loadingView, styles = _this$props5.styles;
          return /* @__PURE__ */ _react.default.createElement("div", {
            style: styles.viewHolder
          }, isLoaded && this.renderBook() || loadingView);
        }
      }]);
      return EpubView3;
    }(_react.Component);
    EpubView2.defaultProps = {
      loadingView: null,
      locationChanged: null,
      tocChanged: null,
      styles: _style.default,
      epubOptions: {},
      epubInitOptions: {}
    };
    EpubView2.propTypes = {
      url: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.instanceOf(ArrayBuffer)]),
      loadingView: _propTypes.default.element,
      location: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
      locationChanged: _propTypes.default.func,
      tocChanged: _propTypes.default.func,
      styles: _propTypes.default.object,
      epubInitOptions: _propTypes.default.object,
      epubOptions: _propTypes.default.object,
      getRendition: _propTypes.default.func,
      handleKeyPress: _propTypes.default.func,
      handleTextSelected: _propTypes.default.func
    };
    var _default = EpubView2;
    exports.default = _default;
  }
});

// node_modules/react-swipeable/dist/react-swipeable.umd.js
var require_react_swipeable_umd = __commonJS({
  "node_modules/react-swipeable/dist/react-swipeable.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_react()) : typeof define === "function" && define.amd ? define(["exports", "react"], factory) : (global2 = global2 || self, factory(global2.swipeable = {}, global2.react));
    })(exports, function(exports2, React) {
      function _interopNamespace(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var n2 = /* @__PURE__ */ Object.create(null);
        if (e3) {
          Object.keys(e3).forEach(function(k4) {
            if (k4 !== "default") {
              var d3 = Object.getOwnPropertyDescriptor(e3, k4);
              Object.defineProperty(n2, k4, d3.get ? d3 : {
                enumerable: true,
                get: function() {
                  return e3[k4];
                }
              });
            }
          });
        }
        n2["default"] = e3;
        return n2;
      }
      var React__namespace = /* @__PURE__ */ _interopNamespace(React);
      function _extends() {
        _extends = Object.assign || function(target) {
          for (var i3 = 1; i3 < arguments.length; i3++) {
            var source = arguments[i3];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      var LEFT = "Left";
      var RIGHT = "Right";
      var UP = "Up";
      var DOWN = "Down";
      var defaultProps = {
        delta: 10,
        preventDefaultTouchmoveEvent: false,
        rotationAngle: 0,
        trackMouse: false,
        trackTouch: true
      };
      var initialState = {
        first: true,
        initial: [0, 0],
        start: 0,
        swiping: false,
        xy: [0, 0]
      };
      var mouseMove = "mousemove";
      var mouseUp = "mouseup";
      var touchEnd = "touchend";
      var touchMove = "touchmove";
      var touchStart = "touchstart";
      function getDirection(absX, absY, deltaX, deltaY) {
        if (absX > absY) {
          if (deltaX > 0) {
            return RIGHT;
          }
          return LEFT;
        } else if (deltaY > 0) {
          return DOWN;
        }
        return UP;
      }
      function rotateXYByAngle(pos, angle) {
        if (angle === 0)
          return pos;
        var angleInRadians = Math.PI / 180 * angle;
        var x4 = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);
        var y3 = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);
        return [x4, y3];
      }
      function getHandlers(set, handlerProps) {
        var onStart = function onStart2(event) {
          if (event && "touches" in event && event.touches.length > 1)
            return;
          set(function(state, props) {
            if (props.trackMouse) {
              document.addEventListener(mouseMove, onMove);
              document.addEventListener(mouseUp, onUp);
            }
            var _ref = "touches" in event ? event.touches[0] : event, clientX = _ref.clientX, clientY = _ref.clientY;
            var xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);
            return _extends({}, state, initialState, {
              initial: [].concat(xy),
              xy,
              start: event.timeStamp || 0
            });
          });
        };
        var onMove = function onMove2(event) {
          set(function(state, props) {
            if ("touches" in event && event.touches.length > 1) {
              return state;
            }
            var _ref2 = "touches" in event ? event.touches[0] : event, clientX = _ref2.clientX, clientY = _ref2.clientY;
            var _rotateXYByAngle = rotateXYByAngle([clientX, clientY], props.rotationAngle), x4 = _rotateXYByAngle[0], y3 = _rotateXYByAngle[1];
            var deltaX = x4 - state.xy[0];
            var deltaY = y3 - state.xy[1];
            var absX = Math.abs(deltaX);
            var absY = Math.abs(deltaY);
            var time = (event.timeStamp || 0) - state.start;
            var velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);
            var vxvy = [deltaX / (time || 1), deltaY / (time || 1)];
            var dir = getDirection(absX, absY, deltaX, deltaY);
            var delta = typeof props.delta === "number" ? props.delta : props.delta[dir.toLowerCase()] || defaultProps.delta;
            if (absX < delta && absY < delta && !state.swiping)
              return state;
            var eventData = {
              absX,
              absY,
              deltaX,
              deltaY,
              dir,
              event,
              first: state.first,
              initial: state.initial,
              velocity,
              vxvy
            };
            eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);
            props.onSwiping && props.onSwiping(eventData);
            var cancelablePageSwipe = false;
            if (props.onSwiping || props.onSwiped || "onSwiped" + dir in props) {
              cancelablePageSwipe = true;
            }
            if (cancelablePageSwipe && props.preventDefaultTouchmoveEvent && props.trackTouch && event.cancelable)
              event.preventDefault();
            return _extends({}, state, {
              first: false,
              eventData,
              swiping: true
            });
          });
        };
        var onEnd = function onEnd2(event) {
          set(function(state, props) {
            var eventData;
            if (state.swiping && state.eventData) {
              eventData = _extends({}, state.eventData, {
                event
              });
              props.onSwiped && props.onSwiped(eventData);
              var onSwipedDir = props["onSwiped" + eventData.dir];
              onSwipedDir && onSwipedDir(eventData);
            } else {
              props.onTap && props.onTap({
                event
              });
            }
            return _extends({}, state, initialState, {
              eventData
            });
          });
        };
        var cleanUpMouse = function cleanUpMouse2() {
          document.removeEventListener(mouseMove, onMove);
          document.removeEventListener(mouseUp, onUp);
        };
        var onUp = function onUp2(e3) {
          cleanUpMouse();
          onEnd(e3);
        };
        var attachTouch = function attachTouch2(el, passive) {
          var cleanup = function cleanup2() {
          };
          if (el && el.addEventListener) {
            var tls = [[touchStart, onStart], [touchMove, onMove], [touchEnd, onEnd]];
            tls.forEach(function(_ref3) {
              var e3 = _ref3[0], h3 = _ref3[1];
              return el.addEventListener(e3, h3, {
                passive
              });
            });
            cleanup = function cleanup2() {
              return tls.forEach(function(_ref4) {
                var e3 = _ref4[0], h3 = _ref4[1];
                return el.removeEventListener(e3, h3);
              });
            };
          }
          return cleanup;
        };
        var onRef = function onRef2(el) {
          if (el === null)
            return;
          set(function(state, props) {
            if (state.el === el)
              return state;
            var addState = {};
            if (state.el && state.el !== el && state.cleanUpTouch) {
              state.cleanUpTouch();
              addState.cleanUpTouch = void 0;
            }
            if (props.trackTouch && el) {
              addState.cleanUpTouch = attachTouch(el, !props.preventDefaultTouchmoveEvent);
            }
            return _extends({}, state, {
              el
            }, addState);
          });
        };
        var output = {
          ref: onRef
        };
        if (handlerProps.trackMouse) {
          output.onMouseDown = onStart;
        }
        return [output, attachTouch];
      }
      function updateTransientState(state, props, attachTouch) {
        var addState = {};
        if (!props.trackTouch && state.cleanUpTouch) {
          state.cleanUpTouch();
          addState.cleanUpTouch = void 0;
        } else if (props.trackTouch && !state.cleanUpTouch) {
          if (state.el) {
            addState.cleanUpTouch = attachTouch(state.el, !props.preventDefaultTouchmoveEvent);
          }
        }
        return _extends({}, state, addState);
      }
      function useSwipeable(options) {
        var trackMouse = options.trackMouse;
        var transientState = React__namespace.useRef(_extends({}, initialState));
        var transientProps = React__namespace.useRef(_extends({}, defaultProps));
        transientProps.current = _extends({}, defaultProps, options, {
          delta: options.delta === void 0 ? defaultProps.delta : options.delta,
          rotationAngle: options.rotationAngle === void 0 ? defaultProps.rotationAngle : options.rotationAngle,
          trackTouch: options.trackTouch === void 0 ? defaultProps.trackTouch : options.trackTouch
        });
        var _React$useMemo = React__namespace.useMemo(function() {
          return getHandlers(function(stateSetter) {
            return transientState.current = stateSetter(transientState.current, transientProps.current);
          }, {
            trackMouse
          });
        }, [trackMouse]), handlers = _React$useMemo[0], attachTouch = _React$useMemo[1];
        transientState.current = updateTransientState(transientState.current, transientProps.current, attachTouch);
        return handlers;
      }
      exports2.DOWN = DOWN;
      exports2.LEFT = LEFT;
      exports2.RIGHT = RIGHT;
      exports2.UP = UP;
      exports2.useSwipeable = useSwipeable;
    });
  }
});

// node_modules/react-reader/lib/ReactReader/style.js
var require_style2 = __commonJS({
  "node_modules/react-reader/lib/ReactReader/style.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var reactReaderStyles = {
      container: {
        overflow: "hidden",
        height: "100%"
      },
      readerArea: {
        position: "relative",
        zIndex: 1,
        height: "100%",
        width: "100%",
        backgroundColor: "#fff",
        transition: "all .3s ease"
      },
      containerExpanded: {
        transform: "translateX(256px)"
      },
      titleArea: {
        position: "absolute",
        top: 20,
        left: 50,
        right: 50,
        textAlign: "center",
        color: "#999"
      },
      reader: {
        position: "absolute",
        top: 50,
        left: 50,
        bottom: 20,
        right: 50
      },
      swipeWrapper: {
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        zIndex: 200
      },
      prev: {
        left: 1
      },
      next: {
        right: 1
      },
      arrow: {
        outline: "none",
        border: "none",
        background: "none",
        position: "absolute",
        top: "50%",
        marginTop: -32,
        fontSize: 64,
        padding: "0 10px",
        color: "#E2E2E2",
        fontFamily: "arial, sans-serif",
        cursor: "pointer",
        userSelect: "none",
        appearance: "none",
        fontWeight: "normal"
      },
      arrowHover: {
        color: "#777"
      },
      tocBackground: {
        position: "absolute",
        left: 256,
        top: 0,
        bottom: 0,
        right: 0,
        zIndex: 1
      },
      tocArea: {
        position: "absolute",
        left: 0,
        top: 0,
        bottom: 0,
        zIndex: 0,
        width: 256,
        overflowY: "auto",
        WebkitOverflowScrolling: "touch",
        background: "#f2f2f2",
        padding: "10px 0"
      },
      tocAreaButton: {
        userSelect: "none",
        appearance: "none",
        background: "none",
        border: "none",
        display: "block",
        fontFamily: "sans-serif",
        width: "100%",
        fontSize: ".9em",
        textAlign: "left",
        padding: ".9em 1em",
        borderBottom: "1px solid #ddd",
        color: "#aaa",
        boxSizing: "border-box",
        outline: "none",
        cursor: "pointer"
      },
      tocButton: {
        background: "none",
        border: "none",
        width: 32,
        height: 32,
        position: "absolute",
        top: 10,
        left: 10,
        borderRadius: 2,
        outline: "none",
        cursor: "pointer"
      },
      tocButtonExpanded: {
        background: "#f2f2f2"
      },
      tocButtonBar: {
        position: "absolute",
        width: "60%",
        background: "#ccc",
        height: 2,
        left: "50%",
        margin: "-1px -30%",
        top: "50%",
        transition: "all .5s ease"
      },
      tocButtonBarTop: {
        top: "35%"
      },
      tocButtonBottom: {
        top: "66%"
      },
      loadingView: {
        position: "absolute",
        top: "50%",
        left: "10%",
        right: "10%",
        color: "#ccc",
        textAlign: "center",
        margintop: "-.5em"
      }
    };
    var _default = reactReaderStyles;
    exports.default = _default;
  }
});

// node_modules/react-reader/lib/ReactReader/ReactReader.js
var require_ReactReader = __commonJS({
  "node_modules/react-reader/lib/ReactReader/ReactReader.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _reactSwipeable = require_react_swipeable_umd();
    var _3 = require_lib3();
    var _style = _interopRequireDefault(require_style2());
    var _excluded = ["children"];
    var _excluded2 = ["title", "showToc", "loadingView", "styles", "locationChanged", "swipeable", "epubViewStyles"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i3 = 1; i3 < arguments.length; i3++) {
          var source = arguments[i3];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o3, p3) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o4, p4) {
        o4.__proto__ = p4;
        return o4;
      };
      return _setPrototypeOf(o3, p3);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e3) {
        return false;
      }
    }
    function _getPrototypeOf(o3) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
        return o4.__proto__ || Object.getPrototypeOf(o4);
      };
      return _getPrototypeOf(o3);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i3;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
          key = sourceSymbolKeys[i3];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i3;
      for (i3 = 0; i3 < sourceKeys.length; i3++) {
        key = sourceKeys[i3];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var Swipeable = function Swipeable2(_ref) {
      var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded);
      var handlers = (0, _reactSwipeable.useSwipeable)(props);
      return /* @__PURE__ */ _react.default.createElement("div", handlers, children);
    };
    var TocItem = /* @__PURE__ */ function(_PureComponent) {
      _inherits(TocItem2, _PureComponent);
      var _super = _createSuper(TocItem2);
      function TocItem2() {
        var _this;
        _classCallCheck(this, TocItem2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "setLocation", function() {
          _this.props.setLocation(_this.props.href);
        });
        return _this;
      }
      _createClass(TocItem2, [{
        key: "render",
        value: function render() {
          var _this$props = this.props, label = _this$props.label, styles = _this$props.styles;
          return /* @__PURE__ */ _react.default.createElement("button", {
            onClick: this.setLocation,
            style: styles
          }, label);
        }
      }]);
      return TocItem2;
    }(_react.PureComponent);
    TocItem.propTypes = {
      label: _propTypes.default.string,
      href: _propTypes.default.string,
      setLocation: _propTypes.default.func,
      styles: _propTypes.default.object
    };
    var ReactReader2 = /* @__PURE__ */ function(_PureComponent2) {
      _inherits(ReactReader3, _PureComponent2);
      var _super2 = _createSuper(ReactReader3);
      function ReactReader3(props) {
        var _this2;
        _classCallCheck(this, ReactReader3);
        _this2 = _super2.call(this, props);
        _defineProperty(_assertThisInitialized(_this2), "toggleToc", function() {
          _this2.setState({
            expandedToc: !_this2.state.expandedToc
          });
        });
        _defineProperty(_assertThisInitialized(_this2), "next", function() {
          var node = _this2.readerRef.current;
          node.nextPage();
        });
        _defineProperty(_assertThisInitialized(_this2), "prev", function() {
          var node = _this2.readerRef.current;
          node.prevPage();
        });
        _defineProperty(_assertThisInitialized(_this2), "onTocChange", function(toc) {
          var tocChanged = _this2.props.tocChanged;
          _this2.setState({
            toc
          }, function() {
            return tocChanged && tocChanged(toc);
          });
        });
        _defineProperty(_assertThisInitialized(_this2), "setLocation", function(loc) {
          var locationChanged = _this2.props.locationChanged;
          _this2.setState({
            expandedToc: false
          }, function() {
            return locationChanged && locationChanged(loc);
          });
        });
        _this2.readerRef = /* @__PURE__ */ _react.default.createRef();
        _this2.state = {
          expandedToc: false,
          toc: false
        };
        return _this2;
      }
      _createClass(ReactReader3, [{
        key: "renderToc",
        value: function renderToc() {
          var _this3 = this;
          var _this$state = this.state, toc = _this$state.toc, expandedToc = _this$state.expandedToc;
          var styles = this.props.styles;
          return /* @__PURE__ */ _react.default.createElement("div", null, /* @__PURE__ */ _react.default.createElement("div", {
            style: styles.tocArea
          }, /* @__PURE__ */ _react.default.createElement("div", {
            style: styles.toc
          }, toc.map(function(item, i3) {
            return /* @__PURE__ */ _react.default.createElement(TocItem, _extends({}, item, {
              key: i3,
              setLocation: _this3.setLocation,
              styles: styles.tocAreaButton
            }));
          }))), expandedToc && /* @__PURE__ */ _react.default.createElement("div", {
            style: styles.tocBackground,
            onClick: this.toggleToc
          }));
        }
      }, {
        key: "renderTocToggle",
        value: function renderTocToggle() {
          var expandedToc = this.state.expandedToc;
          var styles = this.props.styles;
          return /* @__PURE__ */ _react.default.createElement("button", {
            style: Object.assign({}, styles.tocButton, expandedToc ? styles.tocButtonExpanded : {}),
            onClick: this.toggleToc
          }, /* @__PURE__ */ _react.default.createElement("span", {
            style: Object.assign({}, styles.tocButtonBar, styles.tocButtonBarTop)
          }), /* @__PURE__ */ _react.default.createElement("span", {
            style: Object.assign({}, styles.tocButtonBar, styles.tocButtonBottom)
          }));
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props2 = this.props, title = _this$props2.title, showToc = _this$props2.showToc, loadingView = _this$props2.loadingView, styles = _this$props2.styles, locationChanged = _this$props2.locationChanged, swipeable = _this$props2.swipeable, epubViewStyles = _this$props2.epubViewStyles, props = _objectWithoutProperties(_this$props2, _excluded2);
          var _this$state2 = this.state, toc = _this$state2.toc, expandedToc = _this$state2.expandedToc;
          return /* @__PURE__ */ _react.default.createElement("div", {
            style: styles.container
          }, /* @__PURE__ */ _react.default.createElement("div", {
            style: Object.assign({}, styles.readerArea, expandedToc ? styles.containerExpanded : {})
          }, showToc && this.renderTocToggle(), /* @__PURE__ */ _react.default.createElement("div", {
            style: styles.titleArea
          }, title), /* @__PURE__ */ _react.default.createElement(Swipeable, {
            onSwipedRight: this.prev,
            onSwipedLeft: this.next,
            trackMouse: true
          }, /* @__PURE__ */ _react.default.createElement("div", {
            style: styles.reader
          }, /* @__PURE__ */ _react.default.createElement(_3.EpubView, _extends({
            ref: this.readerRef,
            loadingView,
            styles: epubViewStyles
          }, props, {
            tocChanged: this.onTocChange,
            locationChanged
          })), swipeable && /* @__PURE__ */ _react.default.createElement("div", {
            style: styles.swipeWrapper
          }))), /* @__PURE__ */ _react.default.createElement("button", {
            style: Object.assign({}, styles.arrow, styles.prev),
            onClick: this.prev
          }, "\u2039"), /* @__PURE__ */ _react.default.createElement("button", {
            style: Object.assign({}, styles.arrow, styles.next),
            onClick: this.next
          }, "\u203A")), showToc && toc && this.renderToc());
        }
      }]);
      return ReactReader3;
    }(_react.PureComponent);
    ReactReader2.defaultProps = {
      loadingView: /* @__PURE__ */ _react.default.createElement("div", {
        style: _style.default.loadingView
      }, "Loading\u2026"),
      locationChanged: null,
      tocChanged: null,
      showToc: true,
      styles: _style.default
    };
    ReactReader2.propTypes = {
      title: _propTypes.default.string,
      loadingView: _propTypes.default.element,
      showToc: _propTypes.default.bool,
      locationChanged: _propTypes.default.func,
      tocChanged: _propTypes.default.func,
      styles: _propTypes.default.object,
      epubViewStyles: _propTypes.default.object,
      swipeable: _propTypes.default.bool
    };
    var _default = ReactReader2;
    exports.default = _default;
  }
});

// node_modules/react-reader/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/react-reader/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "EpubView", {
      enumerable: true,
      get: function get() {
        return _EpubView.default;
      }
    });
    Object.defineProperty(exports, "EpubViewStyle", {
      enumerable: true,
      get: function get() {
        return _style.default;
      }
    });
    Object.defineProperty(exports, "ReactReader", {
      enumerable: true,
      get: function get() {
        return _ReactReader.default;
      }
    });
    Object.defineProperty(exports, "ReactReaderStyle", {
      enumerable: true,
      get: function get() {
        return _style2.default;
      }
    });
    var _EpubView = _interopRequireDefault(require_EpubView());
    var _style = _interopRequireDefault(require_style());
    var _ReactReader = _interopRequireDefault(require_ReactReader());
    var _style2 = _interopRequireDefault(require_style2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EpubPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/EpubPluginSettings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  scrolledView: false
};
var EpubSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "EPUB Settings" });
    new import_obsidian.Setting(containerEl).setName("Scrolled View").setDesc("This enables seamless scrolling between pages.").addToggle((toggle) => toggle.setValue(this.plugin.settings.scrolledView).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.scrolledView = value;
      yield this.plugin.saveSettings();
    })));
  }
};

// src/EpubView.tsx
var import_obsidian2 = require("obsidian");

// node_modules/react/index.mjs
init_compat_module();
init_compat_module();

// node_modules/react-dom/index.mjs
init_compat_module();
init_compat_module();

// src/EpubReader.tsx
var import_react_reader = __toESM(require_lib3());
var EpubReader = ({ contents, title, scrolled, tocOffset }) => {
  const [location, setLocation] = m2(null);
  const locationChanged = (epubcifi) => setLocation(epubcifi);
  return /* @__PURE__ */ v("div", {
    style: { height: "100vh" }
  }, /* @__PURE__ */ v(import_react_reader.ReactReader, {
    title,
    showToc: true,
    location,
    locationChanged,
    swipeable: false,
    url: contents,
    epubOptions: scrolled ? {
      flow: "scrolled",
      manager: "continuous"
    } : {},
    styles: __spreadProps(__spreadValues({}, import_react_reader.ReactReaderStyle), {
      tocArea: __spreadProps(__spreadValues({}, import_react_reader.ReactReaderStyle.tocArea), {
        top: (tocOffset + 20).toString() + "px",
        bottom: "20px",
        left: "auto",
        backgroundColor: "currentColor"
      }),
      tocButtonExpanded: __spreadProps(__spreadValues({}, import_react_reader.ReactReaderStyle.tocButtonExpanded), {
        backgroundColor: "currentColor"
      })
    })
  }));
};

// src/EpubView.tsx
var EPUB_FILE_EXTENSION = "epub";
var VIEW_TYPE_EPUB = "epub";
var ICON_EPUB = "doc-epub";
var EpubView = class extends import_obsidian2.FileView {
  constructor(leaf, settings) {
    super(leaf);
    this.settings = settings;
  }
  onLoadFile(file) {
    return __async(this, null, function* () {
      un(this.contentEl);
      this.contentEl.empty();
      const style = getComputedStyle(this.containerEl.parentElement.querySelector("div.view-header"));
      const width = parseFloat(style.width);
      const height = parseFloat(style.height);
      const tocOffset = height < width ? height : 0;
      this.app.vault.adapter.readBinary(file.path).then((contents) => {
        B2(/* @__PURE__ */ v(EpubReader, {
          contents,
          title: file.basename,
          scrolled: this.settings.scrolledView,
          tocOffset
        }), this.contentEl);
      });
    });
  }
  onunload() {
    un(this.contentEl);
  }
  getDisplayText() {
    if (this.file) {
      return this.file.basename;
    } else {
      return "No File";
    }
  }
  canAcceptExtension(extension) {
    return extension == EPUB_FILE_EXTENSION;
  }
  getViewType() {
    return VIEW_TYPE_EPUB;
  }
  getIcon() {
    return ICON_EPUB;
  }
};

// src/main.ts
var EpubPlugin = class extends import_obsidian3.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      (0, import_obsidian3.addIcon)(ICON_EPUB, `
			<path
				fill="currentColor"
				stroke="currentColor"
				d="M 90.695312 47.296875 C 90.046875 46.589844 89.136719 46.1875 88.175781 46.1875 C 87.21875 46.1875 86.304688 46.589844 85.660156 47.296875 L 70.535156 63.277344 L 52.855469 81.933594 C 51.558594 83.339844 49.734375 84.144531 47.820312 84.144531 C 45.90625 84.144531 44.078125 83.339844 42.785156 81.933594 L 17.582031 55.292969 C 14.792969 52.292969 14.792969 47.648438 17.582031 44.648438 L 42.785156 18.023438 C 44.078125 16.617188 45.90625 15.816406 47.820312 15.816406 C 49.734375 15.816406 51.558594 16.617188 52.855469 18.023438 L 64.382812 30.207031 L 40.417969 55.5 C 39.730469 56.257812 39.730469 57.410156 40.417969 58.167969 L 42.945312 60.839844 C 43.652344 61.566406 44.761719 61.566406 45.472656 60.839844 L 73.222656 31.566406 C 73.90625 30.808594 73.90625 29.652344 73.222656 28.894531 L 70.691406 26.226562 L 70.511719 26.054688 L 57.886719 12.722656 C 55.28125 9.921875 51.628906 8.332031 47.804688 8.332031 C 43.980469 8.332031 40.332031 9.921875 37.726562 12.722656 L 12.503906 39.347656 C 6.941406 45.222656 6.941406 54.769531 12.503906 60.644531 L 37.703125 87.269531 C 40.308594 90.070312 43.960938 91.664062 47.789062 91.664062 C 51.613281 91.664062 55.265625 90.070312 57.871094 87.269531 L 83.070312 60.644531 L 90.632812 52.679688 C 92.007812 51.171875 92.007812 48.863281 90.632812 47.359375 L 90.695312 47.292969 Z M 90.695312 47.296875"
			/>
		`);
      this.registerView(VIEW_TYPE_EPUB, (leaf) => {
        return new EpubView(leaf, this.settings);
      });
      try {
        this.registerExtensions([EPUB_FILE_EXTENSION], VIEW_TYPE_EPUB);
      } catch (error) {
        console.log(`Existing file extension ${EPUB_FILE_EXTENSION}`);
      }
      this.addSettingTab(new EpubSettingTab(this.app, this));
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!

JSZip v3.9.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
